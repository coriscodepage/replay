
use std::ffi::c_void;
          
use gl::types::{GLbitfield, GLboolean, GLdouble, GLenum, GLfloat, GLint, GLsizei, GLuint, GLvoid};

use crate::{call::Call, test::ScopedAllocator, gl_context::Context};

//static GLint
//_getActiveProgram(void);

//static void
//_validateActiveProgram(trace::Call &call);



struct GlRetracer {
context: Context,
static retrace::map<GLuint> _list_map,
static retrace::map<GLuint> _texture_map,
static retrace::map<GLuint> _query_map,
static retrace::map<GLuint> _buffer_map,
static retrace::map<GLuint> _program_map,
static retrace::map<GLuint> _shader_map,
static std::map<GLhandleARB, retrace::map<GLint> > _location_map,
static retrace::map<GLuint> _fence_map,
static retrace::map<GLsync> _sync_map,
static retrace::map<GLuint> _arrayAPPLE_map,
static retrace::map<GLuint64> _textureHandle_map,
static retrace::map<GLuint> _sampler_map,
static retrace::map<GLuint64> _imageHandle_map,
static retrace::map<GLuint> _feedback_map,
static retrace::map<GLuint> _framebuffer_map,
static retrace::map<GLuint> _renderbuffer_map,
static std::map<uintptr_t, retrace::map<GLuint> > _array_map,
static retrace::map<GLuint> _pipeline_map,
static retrace::map<GLhandleARB> _handleARB_map,
static std::map<GLhandleARB, retrace::map<GLuint> > _subroutine_map,
static retrace::map<GLeglImageOES> _eglImageOES_map,
static std::map<GLuint, retrace::map<GLuint> > _uniformBlock_map,
static retrace::map<GLuint> _programARB_map,
static retrace::map<GLuint> _fragmentShaderATI_map,
static retrace::map<GLuint> _region_map,
}

impl GlRetracer {
pub fn retrace_glCullFace(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::CullFace(mode) };
}

pub fn retrace_glFrontFace(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::FrontFace(mode) };
}

pub fn retrace_glHint(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::Hint(target, mode) };
}

pub fn retrace_glLineWidth(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut width: GLfloat;
    width = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::LineWidth(width) };
}

pub fn retrace_glPointSize(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLfloat;
    size = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::PointSize(size) };
}

pub fn retrace_glPolygonMode(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::PolygonMode(face, mode) };
}

pub fn retrace_glScissor(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Scissor(x, y, width, height) };
}

pub fn retrace_glTexParameterf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::TexParameterf(target, pname, param) };
}

pub fn retrace_glTexParameterfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat86_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat86_0) = _a_GLfloat86_0 {
        for _jGLfloat86 in 0.._a_GLfloat86_0.values.len() {
    params[_jGLfloat86] = (*_a_GLfloat86_0.values[_jGLfloat86]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexParameterfv(target, pname, params) };
}

pub fn retrace_glTexParameteri(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TexParameteri(target, pname, param) };
}

pub fn retrace_glTexParameteriv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint129_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint129_0) = _a_GLint129_0 {
        for _jGLint129 in 0.._a_GLint129_0.values.len() {
    params[_jGLint129] = (*_a_GLint129_0.values[_jGLint129]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexParameteriv(target, pname, params) };
}

pub fn retrace_glTexImage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLint;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(4)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexImage1D(target, level, internalformat, width, border, format, _type, pixels) };
}

pub fn retrace_glTexImage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLint;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(5)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexImage2D(target, level, internalformat, width, height, border, format, _type, pixels) };
}

pub fn retrace_glDrawBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::DrawBuffer(mode) };
}

pub fn retrace_glClear(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLbitfield;
    mask = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::Clear(mask) };
}

pub fn retrace_glClearColor(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLfloat;
    red = (call.arg(0)).to_f32().unwrap();

    let mut green: GLfloat;
    green = (call.arg(1)).to_f32().unwrap();

    let mut blue: GLfloat;
    blue = (call.arg(2)).to_f32().unwrap();

    let mut alpha: GLfloat;
    alpha = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::ClearColor(red, green, blue, alpha) };
}

pub fn retrace_glClearStencil(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLint;
    s = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::ClearStencil(s) };
}

pub fn retrace_glClearDepth(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut depth: GLdouble;
    depth = (call.arg(0)).to_f64().unwrap();

    unsafe { gl::ClearDepth(depth) };
}

pub fn retrace_glStencilMask(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLuint;
    mask = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::StencilMask(mask) };
}

pub fn retrace_glColorMask(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLboolean;
    red = (call.arg(0)).to_u32().unwrap() as u8;

    let mut green: GLboolean;
    green = (call.arg(1)).to_u32().unwrap() as u8;

    let mut blue: GLboolean;
    blue = (call.arg(2)).to_u32().unwrap() as u8;

    let mut alpha: GLboolean;
    alpha = (call.arg(3)).to_u32().unwrap() as u8;

    unsafe { gl::ColorMask(red, green, blue, alpha) };
}

pub fn retrace_glDepthMask(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut flag: GLboolean;
    flag = (call.arg(0)).to_u32().unwrap() as u8;

    unsafe { gl::DepthMask(flag) };
}

pub fn retrace_glDisable(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut cap: GLenum;
    cap = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    if (cap == gl::DEBUG_OUTPUT_SYNCHRONOUS) {return } ;
    unsafe { gl::Disable(cap) };
}

pub fn retrace_glEnable(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut cap: GLenum;
    cap = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    if (cap == gl::DEBUG_OUTPUT_SYNCHRONOUS) {return } ;
    unsafe { gl::Enable(cap) };
}

pub fn retrace_glFinish(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::Finish() };
    self.context.needs_flush = false;
    if !self.double_buffer {
        glretrace::frame_complete(call);
    }
}

pub fn retrace_glFlush(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::Flush() };
    self.context.needs_flush = false;
    if !self.double_buffer {
        glretrace::frame_complete(call);
    }
}

pub fn retrace_glBlendFunc(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sfactor: GLenum;
    sfactor = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dfactor: GLenum;
    dfactor = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFunc(sfactor, dfactor) };
}

pub fn retrace_glLogicOp(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut opcode: GLenum;
    opcode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::LogicOp(opcode) };
}

pub fn retrace_glStencilFunc(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut func: GLenum;
    func = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _ref: GLint;
    _ref = (call.arg(1)).to_i32().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::StencilFunc(func, _ref, mask) };
}

pub fn retrace_glStencilOp(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut fail: GLenum;
    fail = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut zfail: GLenum;
    zfail = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut zpass: GLenum;
    zpass = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::StencilOp(fail, zfail, zpass) };
}

pub fn retrace_glDepthFunc(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut func: GLenum;
    func = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::DepthFunc(func) };
}

pub fn retrace_glPixelStoref(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PixelStoref(pname, param) };
}

pub fn retrace_glPixelStorei(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PixelStorei(pname, param) };
}

pub fn retrace_glReadBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ReadBuffer(mode) };
}

pub fn retrace_glReadPixels(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    pixels = (call.arg(6)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
     let _w = call.arg(2).to_i32().unwrap();
     let _h = call.arg(3).to_i32().unwrap();
     buffer.resize(_w * _h * 64);
    }
    pixels = buffer.data();
    unsafe { gl::ReadPixels(x, y, width, height, format, _type, pixels) };
}

pub fn retrace_glGetTexImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    pixels = (call.arg(4)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
        return;
    }
    pixels = buffer.data();
    unsafe { gl::GetTexImage(target, level, format, _type, pixels) };
}

pub fn retrace_glDepthRange(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut zNear: GLdouble;
    zNear = (call.arg(0)).to_f64().unwrap();

    let mut zFar: GLdouble;
    zFar = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::DepthRange(zNear, zFar) };
}

pub fn retrace_glViewport(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    glretrace::updateDrawable(x + width, y + height);
    unsafe { gl::Viewport(x, y, width, height) };
}

pub fn retrace_glNewList(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut list: GLuint;
    list = (call.arg(0)).to_u32().unwrap();
    list = _list_map[list];

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    currentContext.insideList = true;
    unsafe { gl::NewList(list, mode) };
}

pub fn retrace_glEndList(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    currentContext.insideList = false;
    unsafe { gl::EndList() };
}

pub fn retrace_glCallList(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut list: GLuint;
    list = (call.arg(0)).to_u32().unwrap();
    list = _list_map[list];

    unsafe { gl::CallList(list) };
}

pub fn retrace_glCallLists(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let lists: &mut [GLvoid];
    let lists = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CallLists(n, _type, lists) };
}

pub fn retrace_glDeleteLists(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut list: GLuint;
    list = (call.arg(0)).to_u32().unwrap();
    list = _list_map[list];

    let mut range: GLsizei;
    range = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::DeleteLists(list, range) };
}

pub fn retrace_glGenLists(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut range: GLsizei;
    range = (call.arg(0)).to_i32().unwrap();

    let _result = unsafe { gl::GenLists(range) };

    let _origResult: GLuint;
    _origResult = (*call.ret).to_u32().unwrap();
    for _hPGLuint20 in 0..range {
        _list_map[_origResult + _hPGLuint20] = _result + _hPGLuint20;
    }
}

pub fn retrace_glListBase(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut base: GLuint;
    base = (call.arg(0)).to_u32().unwrap();
    base = _list_map[base];

    unsafe { gl::ListBase(base) };
}

pub fn retrace_glBegin(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::Begin(mode) };
    self.context.inside_begin_end = true;
}

pub fn retrace_glBitmap(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut width: GLsizei;
    width = (call.arg(0)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(1)).to_i32().unwrap();

    let mut xorig: GLfloat;
    xorig = (call.arg(2)).to_f32().unwrap();

    let mut yorig: GLfloat;
    yorig = (call.arg(3)).to_f32().unwrap();

    let mut xmove: GLfloat;
    xmove = (call.arg(4)).to_f32().unwrap();

    let mut ymove: GLfloat;
    ymove = (call.arg(5)).to_f32().unwrap();

    let bitmap: &mut [GLubyte];
    let bitmap = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::Bitmap(width, height, xorig, yorig, xmove, ymove, bitmap) };
}

pub fn retrace_glColor3b(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLbyte;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLbyte;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLbyte;
    blue = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Color3b(red, green, blue) };
}

pub fn retrace_glColor3bv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(0));
    let _a_GLbyte1_0 = (call.arg(0)).to_array();
    if let Some(_a_GLbyte1_0) = _a_GLbyte1_0 {
        for _jGLbyte1 in 0.._a_GLbyte1_0.values.len() {
    v[_jGLbyte1] = (*_a_GLbyte1_0.values[_jGLbyte1]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color3bv(v) };
}

pub fn retrace_glColor3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLdouble;
    red = (call.arg(0)).to_f64().unwrap();

    let mut green: GLdouble;
    green = (call.arg(1)).to_f64().unwrap();

    let mut blue: GLdouble;
    blue = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::Color3d(red, green, blue) };
}

pub fn retrace_glColor3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble25_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble25_0) = _a_GLdouble25_0 {
        for _jGLdouble25 in 0.._a_GLdouble25_0.values.len() {
    v[_jGLdouble25] = (*_a_GLdouble25_0.values[_jGLdouble25]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color3dv(v) };
}

pub fn retrace_glColor3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLfloat;
    red = (call.arg(0)).to_f32().unwrap();

    let mut green: GLfloat;
    green = (call.arg(1)).to_f32().unwrap();

    let mut blue: GLfloat;
    blue = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Color3f(red, green, blue) };
}

pub fn retrace_glColor3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat87_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat87_0) = _a_GLfloat87_0 {
        for _jGLfloat87 in 0.._a_GLfloat87_0.values.len() {
    v[_jGLfloat87] = (*_a_GLfloat87_0.values[_jGLfloat87]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color3fv(v) };
}

pub fn retrace_glColor3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLint;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLint;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLint;
    blue = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Color3i(red, green, blue) };
}

pub fn retrace_glColor3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint130_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint130_0) = _a_GLint130_0 {
        for _jGLint130 in 0.._a_GLint130_0.values.len() {
    v[_jGLint130] = (*_a_GLint130_0.values[_jGLint130]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color3iv(v) };
}

pub fn retrace_glColor3s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLshort;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLshort;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLshort;
    blue = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Color3s(red, green, blue) };
}

pub fn retrace_glColor3sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort1_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort1_0) = _a_GLshort1_0 {
        for _jGLshort1 in 0.._a_GLshort1_0.values.len() {
    v[_jGLshort1] = (*_a_GLshort1_0.values[_jGLshort1]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color3sv(v) };
}

pub fn retrace_glColor3ub(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLubyte;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLubyte;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLubyte;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::Color3ub(red, green, blue) };
}

pub fn retrace_glColor3ubv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(0));
    let _a_GLubyte6_0 = (call.arg(0)).to_array();
    if let Some(_a_GLubyte6_0) = _a_GLubyte6_0 {
        for _jGLubyte6 in 0.._a_GLubyte6_0.values.len() {
    v[_jGLubyte6] = (*_a_GLubyte6_0.values[_jGLubyte6]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color3ubv(v) };
}

pub fn retrace_glColor3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLuint;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLuint;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLuint;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::Color3ui(red, green, blue) };
}

pub fn retrace_glColor3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_GLuint79_0 = (call.arg(0)).to_array();
    if let Some(_a_GLuint79_0) = _a_GLuint79_0 {
        for _jGLuint79 in 0.._a_GLuint79_0.values.len() {
    v[_jGLuint79] = (*_a_GLuint79_0.values[_jGLuint79]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color3uiv(v) };
}

pub fn retrace_glColor3us(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLushort;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLushort;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLushort;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::Color3us(red, green, blue) };
}

pub fn retrace_glColor3usv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLushort];
    v = _allocator.alloc_array::<GLushort>(&call.arg(0));
    let _a_GLushort3_0 = (call.arg(0)).to_array();
    if let Some(_a_GLushort3_0) = _a_GLushort3_0 {
        for _jGLushort3 in 0.._a_GLushort3_0.values.len() {
    v[_jGLushort3] = (*_a_GLushort3_0.values[_jGLushort3]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color3usv(v) };
}

pub fn retrace_glColor4b(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLbyte;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLbyte;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLbyte;
    blue = (call.arg(2)).to_i32().unwrap();

    let mut alpha: GLbyte;
    alpha = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Color4b(red, green, blue, alpha) };
}

pub fn retrace_glColor4bv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(0));
    let _a_GLbyte2_0 = (call.arg(0)).to_array();
    if let Some(_a_GLbyte2_0) = _a_GLbyte2_0 {
        for _jGLbyte2 in 0.._a_GLbyte2_0.values.len() {
    v[_jGLbyte2] = (*_a_GLbyte2_0.values[_jGLbyte2]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4bv(v) };
}

pub fn retrace_glColor4d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLdouble;
    red = (call.arg(0)).to_f64().unwrap();

    let mut green: GLdouble;
    green = (call.arg(1)).to_f64().unwrap();

    let mut blue: GLdouble;
    blue = (call.arg(2)).to_f64().unwrap();

    let mut alpha: GLdouble;
    alpha = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::Color4d(red, green, blue, alpha) };
}

pub fn retrace_glColor4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble26_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble26_0) = _a_GLdouble26_0 {
        for _jGLdouble26 in 0.._a_GLdouble26_0.values.len() {
    v[_jGLdouble26] = (*_a_GLdouble26_0.values[_jGLdouble26]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4dv(v) };
}

pub fn retrace_glColor4f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLfloat;
    red = (call.arg(0)).to_f32().unwrap();

    let mut green: GLfloat;
    green = (call.arg(1)).to_f32().unwrap();

    let mut blue: GLfloat;
    blue = (call.arg(2)).to_f32().unwrap();

    let mut alpha: GLfloat;
    alpha = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::Color4f(red, green, blue, alpha) };
}

pub fn retrace_glColor4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat88_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat88_0) = _a_GLfloat88_0 {
        for _jGLfloat88 in 0.._a_GLfloat88_0.values.len() {
    v[_jGLfloat88] = (*_a_GLfloat88_0.values[_jGLfloat88]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4fv(v) };
}

pub fn retrace_glColor4i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLint;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLint;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLint;
    blue = (call.arg(2)).to_i32().unwrap();

    let mut alpha: GLint;
    alpha = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Color4i(red, green, blue, alpha) };
}

pub fn retrace_glColor4iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint131_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint131_0) = _a_GLint131_0 {
        for _jGLint131 in 0.._a_GLint131_0.values.len() {
    v[_jGLint131] = (*_a_GLint131_0.values[_jGLint131]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4iv(v) };
}

pub fn retrace_glColor4s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLshort;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLshort;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLshort;
    blue = (call.arg(2)).to_i32().unwrap();

    let mut alpha: GLshort;
    alpha = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Color4s(red, green, blue, alpha) };
}

pub fn retrace_glColor4sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort2_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort2_0) = _a_GLshort2_0 {
        for _jGLshort2 in 0.._a_GLshort2_0.values.len() {
    v[_jGLshort2] = (*_a_GLshort2_0.values[_jGLshort2]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4sv(v) };
}

pub fn retrace_glColor4ub(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLubyte;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLubyte;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLubyte;
    blue = (call.arg(2)).to_u32().unwrap();

    let mut alpha: GLubyte;
    alpha = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::Color4ub(red, green, blue, alpha) };
}

pub fn retrace_glColor4ubv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(0));
    let _a_GLubyte7_0 = (call.arg(0)).to_array();
    if let Some(_a_GLubyte7_0) = _a_GLubyte7_0 {
        for _jGLubyte7 in 0.._a_GLubyte7_0.values.len() {
    v[_jGLubyte7] = (*_a_GLubyte7_0.values[_jGLubyte7]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4ubv(v) };
}

pub fn retrace_glColor4ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLuint;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLuint;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLuint;
    blue = (call.arg(2)).to_u32().unwrap();

    let mut alpha: GLuint;
    alpha = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::Color4ui(red, green, blue, alpha) };
}

pub fn retrace_glColor4uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_GLuint80_0 = (call.arg(0)).to_array();
    if let Some(_a_GLuint80_0) = _a_GLuint80_0 {
        for _jGLuint80 in 0.._a_GLuint80_0.values.len() {
    v[_jGLuint80] = (*_a_GLuint80_0.values[_jGLuint80]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4uiv(v) };
}

pub fn retrace_glColor4us(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLushort;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLushort;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLushort;
    blue = (call.arg(2)).to_u32().unwrap();

    let mut alpha: GLushort;
    alpha = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::Color4us(red, green, blue, alpha) };
}

pub fn retrace_glColor4usv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLushort];
    v = _allocator.alloc_array::<GLushort>(&call.arg(0));
    let _a_GLushort4_0 = (call.arg(0)).to_array();
    if let Some(_a_GLushort4_0) = _a_GLushort4_0 {
        for _jGLushort4 in 0.._a_GLushort4_0.values.len() {
    v[_jGLushort4] = (*_a_GLushort4_0.values[_jGLushort4]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4usv(v) };
}

pub fn retrace_glEdgeFlag(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut flag: GLboolean;
    flag = (call.arg(0)).to_u32().unwrap() as u8;

    unsafe { gl::EdgeFlag(flag) };
}

pub fn retrace_glEdgeFlagv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let flag: &mut [GLboolean];
    flag = _allocator.alloc_array::<GLboolean>(&call.arg(0));
    let _a_PGLboolean_0 = (call.arg(0)).to_array().unwrap();
    flag[0] = (_a_PGLboolean_0.values[0]).to_u32().unwrap() as u8;

    unsafe { gl::EdgeFlagv(flag) };
}

pub fn retrace_glEnd(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    currentContext.insideBeginEnd = false;
    unsafe { gl::End() };
}

pub fn retrace_glIndexd(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut c: GLdouble;
    c = (call.arg(0)).to_f64().unwrap();

    unsafe { gl::Indexd(c) };
}

pub fn retrace_glIndexdv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let c: &mut [GLdouble];
    c = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_PGLdouble1_0 = (call.arg(0)).to_array().unwrap();
    c[0] = (_a_PGLdouble1_0.values[0]).to_f64().unwrap();

    unsafe { gl::Indexdv(c) };
}

pub fn retrace_glIndexf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut c: GLfloat;
    c = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::Indexf(c) };
}

pub fn retrace_glIndexfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let c: &mut [GLfloat];
    c = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_PGLfloat11_0 = (call.arg(0)).to_array().unwrap();
    c[0] = (_a_PGLfloat11_0.values[0]).to_f32().unwrap();

    unsafe { gl::Indexfv(c) };
}

pub fn retrace_glIndexi(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut c: GLint;
    c = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::Indexi(c) };
}

pub fn retrace_glIndexiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let c: &mut [GLint];
    c = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_PGLint29_0 = (call.arg(0)).to_array().unwrap();
    c[0] = (_a_PGLint29_0.values[0]).to_i32().unwrap();

    unsafe { gl::Indexiv(c) };
}

pub fn retrace_glIndexs(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut c: GLshort;
    c = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::Indexs(c) };
}

pub fn retrace_glIndexsv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let c: &mut [GLshort];
    c = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_PGLshort_0 = (call.arg(0)).to_array().unwrap();
    c[0] = (_a_PGLshort_0.values[0]).to_i32().unwrap();

    unsafe { gl::Indexsv(c) };
}

pub fn retrace_glNormal3b(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut nx: GLbyte;
    nx = (call.arg(0)).to_i32().unwrap();

    let mut ny: GLbyte;
    ny = (call.arg(1)).to_i32().unwrap();

    let mut nz: GLbyte;
    nz = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Normal3b(nx, ny, nz) };
}

pub fn retrace_glNormal3bv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(0));
    let _a_GLbyte3_0 = (call.arg(0)).to_array();
    if let Some(_a_GLbyte3_0) = _a_GLbyte3_0 {
        for _jGLbyte3 in 0.._a_GLbyte3_0.values.len() {
    v[_jGLbyte3] = (*_a_GLbyte3_0.values[_jGLbyte3]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Normal3bv(v) };
}

pub fn retrace_glNormal3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut nx: GLdouble;
    nx = (call.arg(0)).to_f64().unwrap();

    let mut ny: GLdouble;
    ny = (call.arg(1)).to_f64().unwrap();

    let mut nz: GLdouble;
    nz = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::Normal3d(nx, ny, nz) };
}

pub fn retrace_glNormal3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble27_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble27_0) = _a_GLdouble27_0 {
        for _jGLdouble27 in 0.._a_GLdouble27_0.values.len() {
    v[_jGLdouble27] = (*_a_GLdouble27_0.values[_jGLdouble27]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Normal3dv(v) };
}

pub fn retrace_glNormal3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut nx: GLfloat;
    nx = (call.arg(0)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(1)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Normal3f(nx, ny, nz) };
}

pub fn retrace_glNormal3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat89_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat89_0) = _a_GLfloat89_0 {
        for _jGLfloat89 in 0.._a_GLfloat89_0.values.len() {
    v[_jGLfloat89] = (*_a_GLfloat89_0.values[_jGLfloat89]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Normal3fv(v) };
}

pub fn retrace_glNormal3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut nx: GLint;
    nx = (call.arg(0)).to_i32().unwrap();

    let mut ny: GLint;
    ny = (call.arg(1)).to_i32().unwrap();

    let mut nz: GLint;
    nz = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Normal3i(nx, ny, nz) };
}

pub fn retrace_glNormal3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint132_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint132_0) = _a_GLint132_0 {
        for _jGLint132 in 0.._a_GLint132_0.values.len() {
    v[_jGLint132] = (*_a_GLint132_0.values[_jGLint132]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Normal3iv(v) };
}

pub fn retrace_glNormal3s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut nx: GLshort;
    nx = (call.arg(0)).to_i32().unwrap();

    let mut ny: GLshort;
    ny = (call.arg(1)).to_i32().unwrap();

    let mut nz: GLshort;
    nz = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Normal3s(nx, ny, nz) };
}

pub fn retrace_glNormal3sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort3_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort3_0) = _a_GLshort3_0 {
        for _jGLshort3 in 0.._a_GLshort3_0.values.len() {
    v[_jGLshort3] = (*_a_GLshort3_0.values[_jGLshort3]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Normal3sv(v) };
}

pub fn retrace_glRasterPos2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::RasterPos2d(x, y) };
}

pub fn retrace_glRasterPos2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble28_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble28_0) = _a_GLdouble28_0 {
        for _jGLdouble28 in 0.._a_GLdouble28_0.values.len() {
    v[_jGLdouble28] = (*_a_GLdouble28_0.values[_jGLdouble28]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos2dv(v) };
}

pub fn retrace_glRasterPos2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::RasterPos2f(x, y) };
}

pub fn retrace_glRasterPos2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat90_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat90_0) = _a_GLfloat90_0 {
        for _jGLfloat90 in 0.._a_GLfloat90_0.values.len() {
    v[_jGLfloat90] = (*_a_GLfloat90_0.values[_jGLfloat90]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos2fv(v) };
}

pub fn retrace_glRasterPos2i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::RasterPos2i(x, y) };
}

pub fn retrace_glRasterPos2iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint133_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint133_0) = _a_GLint133_0 {
        for _jGLint133 in 0.._a_GLint133_0.values.len() {
    v[_jGLint133] = (*_a_GLint133_0.values[_jGLint133]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos2iv(v) };
}

pub fn retrace_glRasterPos2s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::RasterPos2s(x, y) };
}

pub fn retrace_glRasterPos2sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort4_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort4_0) = _a_GLshort4_0 {
        for _jGLshort4 in 0.._a_GLshort4_0.values.len() {
    v[_jGLshort4] = (*_a_GLshort4_0.values[_jGLshort4]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos2sv(v) };
}

pub fn retrace_glRasterPos3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::RasterPos3d(x, y, z) };
}

pub fn retrace_glRasterPos3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble29_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble29_0) = _a_GLdouble29_0 {
        for _jGLdouble29 in 0.._a_GLdouble29_0.values.len() {
    v[_jGLdouble29] = (*_a_GLdouble29_0.values[_jGLdouble29]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos3dv(v) };
}

pub fn retrace_glRasterPos3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::RasterPos3f(x, y, z) };
}

pub fn retrace_glRasterPos3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat91_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat91_0) = _a_GLfloat91_0 {
        for _jGLfloat91 in 0.._a_GLfloat91_0.values.len() {
    v[_jGLfloat91] = (*_a_GLfloat91_0.values[_jGLfloat91]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos3fv(v) };
}

pub fn retrace_glRasterPos3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::RasterPos3i(x, y, z) };
}

pub fn retrace_glRasterPos3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint134_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint134_0) = _a_GLint134_0 {
        for _jGLint134 in 0.._a_GLint134_0.values.len() {
    v[_jGLint134] = (*_a_GLint134_0.values[_jGLint134]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos3iv(v) };
}

pub fn retrace_glRasterPos3s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::RasterPos3s(x, y, z) };
}

pub fn retrace_glRasterPos3sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort5_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort5_0) = _a_GLshort5_0 {
        for _jGLshort5 in 0.._a_GLshort5_0.values.len() {
    v[_jGLshort5] = (*_a_GLshort5_0.values[_jGLshort5]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos3sv(v) };
}

pub fn retrace_glRasterPos4d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(2)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::RasterPos4d(x, y, z, w) };
}

pub fn retrace_glRasterPos4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble30_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble30_0) = _a_GLdouble30_0 {
        for _jGLdouble30 in 0.._a_GLdouble30_0.values.len() {
    v[_jGLdouble30] = (*_a_GLdouble30_0.values[_jGLdouble30]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos4dv(v) };
}

pub fn retrace_glRasterPos4f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::RasterPos4f(x, y, z, w) };
}

pub fn retrace_glRasterPos4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat92_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat92_0) = _a_GLfloat92_0 {
        for _jGLfloat92 in 0.._a_GLfloat92_0.values.len() {
    v[_jGLfloat92] = (*_a_GLfloat92_0.values[_jGLfloat92]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos4fv(v) };
}

pub fn retrace_glRasterPos4i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(2)).to_i32().unwrap();

    let mut w: GLint;
    w = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::RasterPos4i(x, y, z, w) };
}

pub fn retrace_glRasterPos4iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint135_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint135_0) = _a_GLint135_0 {
        for _jGLint135 in 0.._a_GLint135_0.values.len() {
    v[_jGLint135] = (*_a_GLint135_0.values[_jGLint135]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos4iv(v) };
}

pub fn retrace_glRasterPos4s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(2)).to_i32().unwrap();

    let mut w: GLshort;
    w = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::RasterPos4s(x, y, z, w) };
}

pub fn retrace_glRasterPos4sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort6_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort6_0) = _a_GLshort6_0 {
        for _jGLshort6 in 0.._a_GLshort6_0.values.len() {
    v[_jGLshort6] = (*_a_GLshort6_0.values[_jGLshort6]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RasterPos4sv(v) };
}

pub fn retrace_glRectd(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x1: GLdouble;
    x1 = (call.arg(0)).to_f64().unwrap();

    let mut y1: GLdouble;
    y1 = (call.arg(1)).to_f64().unwrap();

    let mut x2: GLdouble;
    x2 = (call.arg(2)).to_f64().unwrap();

    let mut y2: GLdouble;
    y2 = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::Rectd(x1, y1, x2, y2) };
}

pub fn retrace_glRectdv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v1: &mut [GLdouble];
    v1 = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble31_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble31_0) = _a_GLdouble31_0 {
        for _jGLdouble31 in 0.._a_GLdouble31_0.values.len() {
    v1[_jGLdouble31] = (*_a_GLdouble31_0.values[_jGLdouble31]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v2: &mut [GLdouble];
    v2 = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble32_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble32_0) = _a_GLdouble32_0 {
        for _jGLdouble32 in 0.._a_GLdouble32_0.values.len() {
    v2[_jGLdouble32] = (*_a_GLdouble32_0.values[_jGLdouble32]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Rectdv(v1, v2) };
}

pub fn retrace_glRectf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x1: GLfloat;
    x1 = (call.arg(0)).to_f32().unwrap();

    let mut y1: GLfloat;
    y1 = (call.arg(1)).to_f32().unwrap();

    let mut x2: GLfloat;
    x2 = (call.arg(2)).to_f32().unwrap();

    let mut y2: GLfloat;
    y2 = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::Rectf(x1, y1, x2, y2) };
}

pub fn retrace_glRectfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v1: &mut [GLfloat];
    v1 = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat93_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat93_0) = _a_GLfloat93_0 {
        for _jGLfloat93 in 0.._a_GLfloat93_0.values.len() {
    v1[_jGLfloat93] = (*_a_GLfloat93_0.values[_jGLfloat93]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v2: &mut [GLfloat];
    v2 = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat94_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat94_0) = _a_GLfloat94_0 {
        for _jGLfloat94 in 0.._a_GLfloat94_0.values.len() {
    v2[_jGLfloat94] = (*_a_GLfloat94_0.values[_jGLfloat94]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Rectfv(v1, v2) };
}

pub fn retrace_glRecti(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x1: GLint;
    x1 = (call.arg(0)).to_i32().unwrap();

    let mut y1: GLint;
    y1 = (call.arg(1)).to_i32().unwrap();

    let mut x2: GLint;
    x2 = (call.arg(2)).to_i32().unwrap();

    let mut y2: GLint;
    y2 = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Recti(x1, y1, x2, y2) };
}

pub fn retrace_glRectiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v1: &mut [GLint];
    v1 = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint136_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint136_0) = _a_GLint136_0 {
        for _jGLint136 in 0.._a_GLint136_0.values.len() {
    v1[_jGLint136] = (*_a_GLint136_0.values[_jGLint136]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v2: &mut [GLint];
    v2 = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint137_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint137_0) = _a_GLint137_0 {
        for _jGLint137 in 0.._a_GLint137_0.values.len() {
    v2[_jGLint137] = (*_a_GLint137_0.values[_jGLint137]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Rectiv(v1, v2) };
}

pub fn retrace_glRects(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x1: GLshort;
    x1 = (call.arg(0)).to_i32().unwrap();

    let mut y1: GLshort;
    y1 = (call.arg(1)).to_i32().unwrap();

    let mut x2: GLshort;
    x2 = (call.arg(2)).to_i32().unwrap();

    let mut y2: GLshort;
    y2 = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Rects(x1, y1, x2, y2) };
}

pub fn retrace_glRectsv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v1: &mut [GLshort];
    v1 = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort7_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort7_0) = _a_GLshort7_0 {
        for _jGLshort7 in 0.._a_GLshort7_0.values.len() {
    v1[_jGLshort7] = (*_a_GLshort7_0.values[_jGLshort7]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v2: &mut [GLshort];
    v2 = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort8_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort8_0) = _a_GLshort8_0 {
        for _jGLshort8 in 0.._a_GLshort8_0.values.len() {
    v2[_jGLshort8] = (*_a_GLshort8_0.values[_jGLshort8]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Rectsv(v1, v2) };
}

pub fn retrace_glTexCoord1d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLdouble;
    s = (call.arg(0)).to_f64().unwrap();

    unsafe { gl::TexCoord1d(s) };
}

pub fn retrace_glTexCoord1dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_PGLdouble2_0 = (call.arg(0)).to_array().unwrap();
    v[0] = (_a_PGLdouble2_0.values[0]).to_f64().unwrap();

    unsafe { gl::TexCoord1dv(v) };
}

pub fn retrace_glTexCoord1f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::TexCoord1f(s) };
}

pub fn retrace_glTexCoord1fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_PGLfloat12_0 = (call.arg(0)).to_array().unwrap();
    v[0] = (_a_PGLfloat12_0.values[0]).to_f32().unwrap();

    unsafe { gl::TexCoord1fv(v) };
}

pub fn retrace_glTexCoord1i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLint;
    s = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::TexCoord1i(s) };
}

pub fn retrace_glTexCoord1iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_PGLint30_0 = (call.arg(0)).to_array().unwrap();
    v[0] = (_a_PGLint30_0.values[0]).to_i32().unwrap();

    unsafe { gl::TexCoord1iv(v) };
}

pub fn retrace_glTexCoord1s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLshort;
    s = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::TexCoord1s(s) };
}

pub fn retrace_glTexCoord1sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_PGLshort1_0 = (call.arg(0)).to_array().unwrap();
    v[0] = (_a_PGLshort1_0.values[0]).to_i32().unwrap();

    unsafe { gl::TexCoord1sv(v) };
}

pub fn retrace_glTexCoord2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLdouble;
    s = (call.arg(0)).to_f64().unwrap();

    let mut t: GLdouble;
    t = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::TexCoord2d(s, t) };
}

pub fn retrace_glTexCoord2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble33_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble33_0) = _a_GLdouble33_0 {
        for _jGLdouble33 in 0.._a_GLdouble33_0.values.len() {
    v[_jGLdouble33] = (*_a_GLdouble33_0.values[_jGLdouble33]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord2dv(v) };
}

pub fn retrace_glTexCoord2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::TexCoord2f(s, t) };
}

pub fn retrace_glTexCoord2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat95_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat95_0) = _a_GLfloat95_0 {
        for _jGLfloat95 in 0.._a_GLfloat95_0.values.len() {
    v[_jGLfloat95] = (*_a_GLfloat95_0.values[_jGLfloat95]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord2fv(v) };
}

pub fn retrace_glTexCoord2i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLint;
    s = (call.arg(0)).to_i32().unwrap();

    let mut t: GLint;
    t = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::TexCoord2i(s, t) };
}

pub fn retrace_glTexCoord2iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint138_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint138_0) = _a_GLint138_0 {
        for _jGLint138 in 0.._a_GLint138_0.values.len() {
    v[_jGLint138] = (*_a_GLint138_0.values[_jGLint138]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord2iv(v) };
}

pub fn retrace_glTexCoord2s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLshort;
    s = (call.arg(0)).to_i32().unwrap();

    let mut t: GLshort;
    t = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::TexCoord2s(s, t) };
}

pub fn retrace_glTexCoord2sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort9_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort9_0) = _a_GLshort9_0 {
        for _jGLshort9 in 0.._a_GLshort9_0.values.len() {
    v[_jGLshort9] = (*_a_GLshort9_0.values[_jGLshort9]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord2sv(v) };
}

pub fn retrace_glTexCoord3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLdouble;
    s = (call.arg(0)).to_f64().unwrap();

    let mut t: GLdouble;
    t = (call.arg(1)).to_f64().unwrap();

    let mut r: GLdouble;
    r = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::TexCoord3d(s, t, r) };
}

pub fn retrace_glTexCoord3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble34_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble34_0) = _a_GLdouble34_0 {
        for _jGLdouble34 in 0.._a_GLdouble34_0.values.len() {
    v[_jGLdouble34] = (*_a_GLdouble34_0.values[_jGLdouble34]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord3dv(v) };
}

pub fn retrace_glTexCoord3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(1)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::TexCoord3f(s, t, r) };
}

pub fn retrace_glTexCoord3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat96_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat96_0) = _a_GLfloat96_0 {
        for _jGLfloat96 in 0.._a_GLfloat96_0.values.len() {
    v[_jGLfloat96] = (*_a_GLfloat96_0.values[_jGLfloat96]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord3fv(v) };
}

pub fn retrace_glTexCoord3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLint;
    s = (call.arg(0)).to_i32().unwrap();

    let mut t: GLint;
    t = (call.arg(1)).to_i32().unwrap();

    let mut r: GLint;
    r = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TexCoord3i(s, t, r) };
}

pub fn retrace_glTexCoord3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint139_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint139_0) = _a_GLint139_0 {
        for _jGLint139 in 0.._a_GLint139_0.values.len() {
    v[_jGLint139] = (*_a_GLint139_0.values[_jGLint139]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord3iv(v) };
}

pub fn retrace_glTexCoord3s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLshort;
    s = (call.arg(0)).to_i32().unwrap();

    let mut t: GLshort;
    t = (call.arg(1)).to_i32().unwrap();

    let mut r: GLshort;
    r = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TexCoord3s(s, t, r) };
}

pub fn retrace_glTexCoord3sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort10_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort10_0) = _a_GLshort10_0 {
        for _jGLshort10 in 0.._a_GLshort10_0.values.len() {
    v[_jGLshort10] = (*_a_GLshort10_0.values[_jGLshort10]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord3sv(v) };
}

pub fn retrace_glTexCoord4d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLdouble;
    s = (call.arg(0)).to_f64().unwrap();

    let mut t: GLdouble;
    t = (call.arg(1)).to_f64().unwrap();

    let mut r: GLdouble;
    r = (call.arg(2)).to_f64().unwrap();

    let mut q: GLdouble;
    q = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::TexCoord4d(s, t, r, q) };
}

pub fn retrace_glTexCoord4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble35_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble35_0) = _a_GLdouble35_0 {
        for _jGLdouble35 in 0.._a_GLdouble35_0.values.len() {
    v[_jGLdouble35] = (*_a_GLdouble35_0.values[_jGLdouble35]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord4dv(v) };
}

pub fn retrace_glTexCoord4f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(1)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(2)).to_f32().unwrap();

    let mut q: GLfloat;
    q = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::TexCoord4f(s, t, r, q) };
}

pub fn retrace_glTexCoord4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat97_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat97_0) = _a_GLfloat97_0 {
        for _jGLfloat97 in 0.._a_GLfloat97_0.values.len() {
    v[_jGLfloat97] = (*_a_GLfloat97_0.values[_jGLfloat97]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord4fv(v) };
}

pub fn retrace_glTexCoord4i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLint;
    s = (call.arg(0)).to_i32().unwrap();

    let mut t: GLint;
    t = (call.arg(1)).to_i32().unwrap();

    let mut r: GLint;
    r = (call.arg(2)).to_i32().unwrap();

    let mut q: GLint;
    q = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::TexCoord4i(s, t, r, q) };
}

pub fn retrace_glTexCoord4iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint140_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint140_0) = _a_GLint140_0 {
        for _jGLint140 in 0.._a_GLint140_0.values.len() {
    v[_jGLint140] = (*_a_GLint140_0.values[_jGLint140]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord4iv(v) };
}

pub fn retrace_glTexCoord4s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLshort;
    s = (call.arg(0)).to_i32().unwrap();

    let mut t: GLshort;
    t = (call.arg(1)).to_i32().unwrap();

    let mut r: GLshort;
    r = (call.arg(2)).to_i32().unwrap();

    let mut q: GLshort;
    q = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::TexCoord4s(s, t, r, q) };
}

pub fn retrace_glTexCoord4sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort11_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort11_0) = _a_GLshort11_0 {
        for _jGLshort11 in 0.._a_GLshort11_0.values.len() {
    v[_jGLshort11] = (*_a_GLshort11_0.values[_jGLshort11]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord4sv(v) };
}

pub fn retrace_glVertex2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::Vertex2d(x, y) };
}

pub fn retrace_glVertex2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble36_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble36_0) = _a_GLdouble36_0 {
        for _jGLdouble36 in 0.._a_GLdouble36_0.values.len() {
    v[_jGLdouble36] = (*_a_GLdouble36_0.values[_jGLdouble36]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex2dv(v) };
}

pub fn retrace_glVertex2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::Vertex2f(x, y) };
}

pub fn retrace_glVertex2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat98_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat98_0) = _a_GLfloat98_0 {
        for _jGLfloat98 in 0.._a_GLfloat98_0.values.len() {
    v[_jGLfloat98] = (*_a_GLfloat98_0.values[_jGLfloat98]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex2fv(v) };
}

pub fn retrace_glVertex2i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::Vertex2i(x, y) };
}

pub fn retrace_glVertex2iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint141_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint141_0) = _a_GLint141_0 {
        for _jGLint141 in 0.._a_GLint141_0.values.len() {
    v[_jGLint141] = (*_a_GLint141_0.values[_jGLint141]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex2iv(v) };
}

pub fn retrace_glVertex2s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::Vertex2s(x, y) };
}

pub fn retrace_glVertex2sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort12_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort12_0) = _a_GLshort12_0 {
        for _jGLshort12 in 0.._a_GLshort12_0.values.len() {
    v[_jGLshort12] = (*_a_GLshort12_0.values[_jGLshort12]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex2sv(v) };
}

pub fn retrace_glVertex3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::Vertex3d(x, y, z) };
}

pub fn retrace_glVertex3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble37_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble37_0) = _a_GLdouble37_0 {
        for _jGLdouble37 in 0.._a_GLdouble37_0.values.len() {
    v[_jGLdouble37] = (*_a_GLdouble37_0.values[_jGLdouble37]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex3dv(v) };
}

pub fn retrace_glVertex3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Vertex3f(x, y, z) };
}

pub fn retrace_glVertex3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat99_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat99_0) = _a_GLfloat99_0 {
        for _jGLfloat99 in 0.._a_GLfloat99_0.values.len() {
    v[_jGLfloat99] = (*_a_GLfloat99_0.values[_jGLfloat99]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex3fv(v) };
}

pub fn retrace_glVertex3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Vertex3i(x, y, z) };
}

pub fn retrace_glVertex3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint142_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint142_0) = _a_GLint142_0 {
        for _jGLint142 in 0.._a_GLint142_0.values.len() {
    v[_jGLint142] = (*_a_GLint142_0.values[_jGLint142]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex3iv(v) };
}

pub fn retrace_glVertex3s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Vertex3s(x, y, z) };
}

pub fn retrace_glVertex3sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort13_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort13_0) = _a_GLshort13_0 {
        for _jGLshort13 in 0.._a_GLshort13_0.values.len() {
    v[_jGLshort13] = (*_a_GLshort13_0.values[_jGLshort13]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex3sv(v) };
}

pub fn retrace_glVertex4d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(2)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::Vertex4d(x, y, z, w) };
}

pub fn retrace_glVertex4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble38_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble38_0) = _a_GLdouble38_0 {
        for _jGLdouble38 in 0.._a_GLdouble38_0.values.len() {
    v[_jGLdouble38] = (*_a_GLdouble38_0.values[_jGLdouble38]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex4dv(v) };
}

pub fn retrace_glVertex4f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::Vertex4f(x, y, z, w) };
}

pub fn retrace_glVertex4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat100_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat100_0) = _a_GLfloat100_0 {
        for _jGLfloat100 in 0.._a_GLfloat100_0.values.len() {
    v[_jGLfloat100] = (*_a_GLfloat100_0.values[_jGLfloat100]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex4fv(v) };
}

pub fn retrace_glVertex4i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(2)).to_i32().unwrap();

    let mut w: GLint;
    w = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Vertex4i(x, y, z, w) };
}

pub fn retrace_glVertex4iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint143_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint143_0) = _a_GLint143_0 {
        for _jGLint143 in 0.._a_GLint143_0.values.len() {
    v[_jGLint143] = (*_a_GLint143_0.values[_jGLint143]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex4iv(v) };
}

pub fn retrace_glVertex4s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(2)).to_i32().unwrap();

    let mut w: GLshort;
    w = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Vertex4s(x, y, z, w) };
}

pub fn retrace_glVertex4sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort14_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort14_0) = _a_GLshort14_0 {
        for _jGLshort14 in 0.._a_GLshort14_0.values.len() {
    v[_jGLshort14] = (*_a_GLshort14_0.values[_jGLshort14]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex4sv(v) };
}

pub fn retrace_glClipPlane(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut plane: GLenum;
    plane = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let equation: &mut [GLdouble];
    equation = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble39_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble39_0) = _a_GLdouble39_0 {
        for _jGLdouble39 in 0.._a_GLdouble39_0.values.len() {
    equation[_jGLdouble39] = (*_a_GLdouble39_0.values[_jGLdouble39]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClipPlane(plane, equation) };
}

pub fn retrace_glColorMaterial(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ColorMaterial(face, mode) };
}

pub fn retrace_glFogf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::Fogf(pname, param) };
}

pub fn retrace_glFogfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat101_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat101_0) = _a_GLfloat101_0 {
        for _jGLfloat101 in 0.._a_GLfloat101_0.values.len() {
    params[_jGLfloat101] = (*_a_GLfloat101_0.values[_jGLfloat101]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Fogfv(pname, params) };
}

pub fn retrace_glFogi(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::Fogi(pname, param) };
}

pub fn retrace_glFogiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint144_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint144_0) = _a_GLint144_0 {
        for _jGLint144 in 0.._a_GLint144_0.values.len() {
    params[_jGLint144] = (*_a_GLint144_0.values[_jGLint144]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Fogiv(pname, params) };
}

pub fn retrace_glLightf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Lightf(light, pname, param) };
}

pub fn retrace_glLightfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat102_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat102_0) = _a_GLfloat102_0 {
        for _jGLfloat102 in 0.._a_GLfloat102_0.values.len() {
    params[_jGLfloat102] = (*_a_GLfloat102_0.values[_jGLfloat102]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Lightfv(light, pname, params) };
}

pub fn retrace_glLighti(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Lighti(light, pname, param) };
}

pub fn retrace_glLightiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint145_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint145_0) = _a_GLint145_0 {
        for _jGLint145 in 0.._a_GLint145_0.values.len() {
    params[_jGLint145] = (*_a_GLint145_0.values[_jGLint145]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Lightiv(light, pname, params) };
}

pub fn retrace_glLightModelf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::LightModelf(pname, param) };
}

pub fn retrace_glLightModelfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat103_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat103_0) = _a_GLfloat103_0 {
        for _jGLfloat103 in 0.._a_GLfloat103_0.values.len() {
    params[_jGLfloat103] = (*_a_GLfloat103_0.values[_jGLfloat103]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::LightModelfv(pname, params) };
}

pub fn retrace_glLightModeli(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::LightModeli(pname, param) };
}

pub fn retrace_glLightModeliv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint146_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint146_0) = _a_GLint146_0 {
        for _jGLint146 in 0.._a_GLint146_0.values.len() {
    params[_jGLint146] = (*_a_GLint146_0.values[_jGLint146]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::LightModeliv(pname, params) };
}

pub fn retrace_glLineStipple(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLint;
    factor = (call.arg(0)).to_i32().unwrap();

    let mut pattern: GLushort;
    pattern = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::LineStipple(factor, pattern) };
}

pub fn retrace_glMaterialf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Materialf(face, pname, param) };
}

pub fn retrace_glMaterialfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat104_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat104_0) = _a_GLfloat104_0 {
        for _jGLfloat104 in 0.._a_GLfloat104_0.values.len() {
    params[_jGLfloat104] = (*_a_GLfloat104_0.values[_jGLfloat104]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Materialfv(face, pname, params) };
}

pub fn retrace_glMateriali(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Materiali(face, pname, param) };
}

pub fn retrace_glMaterialiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint147_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint147_0) = _a_GLint147_0 {
        for _jGLint147 in 0.._a_GLint147_0.values.len() {
    params[_jGLint147] = (*_a_GLint147_0.values[_jGLint147]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Materialiv(face, pname, params) };
}

pub fn retrace_glPolygonStipple(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mask: &mut [GLubyte];
    mask = _allocator.alloc_array::<GLubyte>(&call.arg(0));
    let _a_GLubyte8_0 = (call.arg(0)).to_array();
    if let Some(_a_GLubyte8_0) = _a_GLubyte8_0 {
        for _jGLubyte8 in 0.._a_GLubyte8_0.values.len() {
    mask[_jGLubyte8] = (*_a_GLubyte8_0.values[_jGLubyte8]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PolygonStipple(mask) };
}

pub fn retrace_glShadeModel(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ShadeModel(mode) };
}

pub fn retrace_glTexEnvf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::TexEnvf(target, pname, param) };
}

pub fn retrace_glTexEnvfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat105_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat105_0) = _a_GLfloat105_0 {
        for _jGLfloat105 in 0.._a_GLfloat105_0.values.len() {
    params[_jGLfloat105] = (*_a_GLfloat105_0.values[_jGLfloat105]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexEnvfv(target, pname, params) };
}

pub fn retrace_glTexEnvi(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TexEnvi(target, pname, param) };
}

pub fn retrace_glTexEnviv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint148_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint148_0) = _a_GLint148_0 {
        for _jGLint148 in 0.._a_GLint148_0.values.len() {
    params[_jGLint148] = (*_a_GLint148_0.values[_jGLint148]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexEnviv(target, pname, params) };
}

pub fn retrace_glTexGend(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLdouble;
    param = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::TexGend(coord, pname, param) };
}

pub fn retrace_glTexGendv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLdouble];
    params = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble40_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble40_0) = _a_GLdouble40_0 {
        for _jGLdouble40 in 0.._a_GLdouble40_0.values.len() {
    params[_jGLdouble40] = (*_a_GLdouble40_0.values[_jGLdouble40]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexGendv(coord, pname, params) };
}

pub fn retrace_glTexGenf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::TexGenf(coord, pname, param) };
}

pub fn retrace_glTexGenfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat106_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat106_0) = _a_GLfloat106_0 {
        for _jGLfloat106 in 0.._a_GLfloat106_0.values.len() {
    params[_jGLfloat106] = (*_a_GLfloat106_0.values[_jGLfloat106]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexGenfv(coord, pname, params) };
}

pub fn retrace_glTexGeni(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TexGeni(coord, pname, param) };
}

pub fn retrace_glTexGeniv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint149_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint149_0) = _a_GLint149_0 {
        for _jGLint149 in 0.._a_GLint149_0.values.len() {
    params[_jGLint149] = (*_a_GLint149_0.values[_jGLint149]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexGeniv(coord, pname, params) };
}

pub fn retrace_glFeedbackBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLsizei;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let buffer: &mut [GLfloat];
    buffer = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    _allocator.bind(buffer);

    unsafe { gl::FeedbackBuffer(size, _type, buffer) };
    let _aGLfloat108 = (call.arg(2)).to_array();
    if (_aGLfloat108) {
        for _jGLfloat108 in 0..length {
        }
    }
}

pub fn retrace_glSelectBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLsizei;
    size = (call.arg(0)).to_i32().unwrap();

    let buffer: &mut [GLuint];
    buffer = _allocator.alloc_array::<GLuint>(&call.arg(1));
    _allocator.bind(buffer);

    unsafe { gl::SelectBuffer(size, buffer) };
    let _aGLuint82 = (call.arg(1)).to_array();
    if (_aGLuint82) {
        for _jGLuint82 in 0..length {
        }
    }
}

pub fn retrace_glRenderMode(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::RenderMode(mode) };

}

pub fn retrace_glInitNames(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::InitNames() };
}

pub fn retrace_glLoadName(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut name: GLuint;
    name = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::LoadName(name) };
}

pub fn retrace_glPassThrough(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut token: GLfloat;
    token = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::PassThrough(token) };
}

pub fn retrace_glPopName(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PopName() };
}

pub fn retrace_glPushName(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut name: GLuint;
    name = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::PushName(name) };
}

pub fn retrace_glClearAccum(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLfloat;
    red = (call.arg(0)).to_f32().unwrap();

    let mut green: GLfloat;
    green = (call.arg(1)).to_f32().unwrap();

    let mut blue: GLfloat;
    blue = (call.arg(2)).to_f32().unwrap();

    let mut alpha: GLfloat;
    alpha = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::ClearAccum(red, green, blue, alpha) };
}

pub fn retrace_glClearIndex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut c: GLfloat;
    c = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::ClearIndex(c) };
}

pub fn retrace_glIndexMask(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLuint;
    mask = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::IndexMask(mask) };
}

pub fn retrace_glAccum(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut op: GLenum;
    op = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLfloat;
    value = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::Accum(op, value) };
}

pub fn retrace_glPopAttrib(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PopAttrib() };
}

pub fn retrace_glPushAttrib(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLbitfield;
    mask = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::PushAttrib(mask) };
}

pub fn retrace_glMap1d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut u1: GLdouble;
    u1 = (call.arg(1)).to_f64().unwrap();

    let mut u2: GLdouble;
    u2 = (call.arg(2)).to_f64().unwrap();

    let mut stride: GLint;
    stride = (call.arg(3)).to_i32().unwrap();

    let mut order: GLint;
    order = (call.arg(4)).to_i32().unwrap();

    let points: &mut [GLdouble];
    points = _allocator.alloc_array::<GLdouble>(&call.arg(5));
    let _a_GLdouble41_0 = (call.arg(5)).to_array();
    if let Some(_a_GLdouble41_0) = _a_GLdouble41_0 {
        for _jGLdouble41 in 0.._a_GLdouble41_0.values.len() {
    points[_jGLdouble41] = (*_a_GLdouble41_0.values[_jGLdouble41]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Map1d(target, u1, u2, stride, order, points) };
}

pub fn retrace_glMap1f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut u1: GLfloat;
    u1 = (call.arg(1)).to_f32().unwrap();

    let mut u2: GLfloat;
    u2 = (call.arg(2)).to_f32().unwrap();

    let mut stride: GLint;
    stride = (call.arg(3)).to_i32().unwrap();

    let mut order: GLint;
    order = (call.arg(4)).to_i32().unwrap();

    let points: &mut [GLfloat];
    points = _allocator.alloc_array::<GLfloat>(&call.arg(5));
    let _a_GLfloat109_0 = (call.arg(5)).to_array();
    if let Some(_a_GLfloat109_0) = _a_GLfloat109_0 {
        for _jGLfloat109 in 0.._a_GLfloat109_0.values.len() {
    points[_jGLfloat109] = (*_a_GLfloat109_0.values[_jGLfloat109]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Map1f(target, u1, u2, stride, order, points) };
}

pub fn retrace_glMap2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut u1: GLdouble;
    u1 = (call.arg(1)).to_f64().unwrap();

    let mut u2: GLdouble;
    u2 = (call.arg(2)).to_f64().unwrap();

    let mut ustride: GLint;
    ustride = (call.arg(3)).to_i32().unwrap();

    let mut uorder: GLint;
    uorder = (call.arg(4)).to_i32().unwrap();

    let mut v1: GLdouble;
    v1 = (call.arg(5)).to_f64().unwrap();

    let mut v2: GLdouble;
    v2 = (call.arg(6)).to_f64().unwrap();

    let mut vstride: GLint;
    vstride = (call.arg(7)).to_i32().unwrap();

    let mut vorder: GLint;
    vorder = (call.arg(8)).to_i32().unwrap();

    let points: &mut [GLdouble];
    points = _allocator.alloc_array::<GLdouble>(&call.arg(9));
    let _a_GLdouble42_0 = (call.arg(9)).to_array();
    if let Some(_a_GLdouble42_0) = _a_GLdouble42_0 {
        for _jGLdouble42 in 0.._a_GLdouble42_0.values.len() {
    points[_jGLdouble42] = (*_a_GLdouble42_0.values[_jGLdouble42]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) };
}

pub fn retrace_glMap2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut u1: GLfloat;
    u1 = (call.arg(1)).to_f32().unwrap();

    let mut u2: GLfloat;
    u2 = (call.arg(2)).to_f32().unwrap();

    let mut ustride: GLint;
    ustride = (call.arg(3)).to_i32().unwrap();

    let mut uorder: GLint;
    uorder = (call.arg(4)).to_i32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(5)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(6)).to_f32().unwrap();

    let mut vstride: GLint;
    vstride = (call.arg(7)).to_i32().unwrap();

    let mut vorder: GLint;
    vorder = (call.arg(8)).to_i32().unwrap();

    let points: &mut [GLfloat];
    points = _allocator.alloc_array::<GLfloat>(&call.arg(9));
    let _a_GLfloat110_0 = (call.arg(9)).to_array();
    if let Some(_a_GLfloat110_0) = _a_GLfloat110_0 {
        for _jGLfloat110 in 0.._a_GLfloat110_0.values.len() {
    points[_jGLfloat110] = (*_a_GLfloat110_0.values[_jGLfloat110]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) };
}

pub fn retrace_glMapGrid1d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut un: GLint;
    un = (call.arg(0)).to_i32().unwrap();

    let mut u1: GLdouble;
    u1 = (call.arg(1)).to_f64().unwrap();

    let mut u2: GLdouble;
    u2 = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::MapGrid1d(un, u1, u2) };
}

pub fn retrace_glMapGrid1f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut un: GLint;
    un = (call.arg(0)).to_i32().unwrap();

    let mut u1: GLfloat;
    u1 = (call.arg(1)).to_f32().unwrap();

    let mut u2: GLfloat;
    u2 = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::MapGrid1f(un, u1, u2) };
}

pub fn retrace_glMapGrid2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut un: GLint;
    un = (call.arg(0)).to_i32().unwrap();

    let mut u1: GLdouble;
    u1 = (call.arg(1)).to_f64().unwrap();

    let mut u2: GLdouble;
    u2 = (call.arg(2)).to_f64().unwrap();

    let mut vn: GLint;
    vn = (call.arg(3)).to_i32().unwrap();

    let mut v1: GLdouble;
    v1 = (call.arg(4)).to_f64().unwrap();

    let mut v2: GLdouble;
    v2 = (call.arg(5)).to_f64().unwrap();

    unsafe { gl::MapGrid2d(un, u1, u2, vn, v1, v2) };
}

pub fn retrace_glMapGrid2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut un: GLint;
    un = (call.arg(0)).to_i32().unwrap();

    let mut u1: GLfloat;
    u1 = (call.arg(1)).to_f32().unwrap();

    let mut u2: GLfloat;
    u2 = (call.arg(2)).to_f32().unwrap();

    let mut vn: GLint;
    vn = (call.arg(3)).to_i32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(4)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::MapGrid2f(un, u1, u2, vn, v1, v2) };
}

pub fn retrace_glEvalCoord1d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut u: GLdouble;
    u = (call.arg(0)).to_f64().unwrap();

    unsafe { gl::EvalCoord1d(u) };
}

pub fn retrace_glEvalCoord1dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let u: &mut [GLdouble];
    u = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_PGLdouble3_0 = (call.arg(0)).to_array().unwrap();
    u[0] = (_a_PGLdouble3_0.values[0]).to_f64().unwrap();

    unsafe { gl::EvalCoord1dv(u) };
}

pub fn retrace_glEvalCoord1f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut u: GLfloat;
    u = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::EvalCoord1f(u) };
}

pub fn retrace_glEvalCoord1fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let u: &mut [GLfloat];
    u = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_PGLfloat13_0 = (call.arg(0)).to_array().unwrap();
    u[0] = (_a_PGLfloat13_0.values[0]).to_f32().unwrap();

    unsafe { gl::EvalCoord1fv(u) };
}

pub fn retrace_glEvalCoord2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut u: GLdouble;
    u = (call.arg(0)).to_f64().unwrap();

    let mut v: GLdouble;
    v = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::EvalCoord2d(u, v) };
}

pub fn retrace_glEvalCoord2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let u: &mut [GLdouble];
    u = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble43_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble43_0) = _a_GLdouble43_0 {
        for _jGLdouble43 in 0.._a_GLdouble43_0.values.len() {
    u[_jGLdouble43] = (*_a_GLdouble43_0.values[_jGLdouble43]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::EvalCoord2dv(u) };
}

pub fn retrace_glEvalCoord2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut u: GLfloat;
    u = (call.arg(0)).to_f32().unwrap();

    let mut v: GLfloat;
    v = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::EvalCoord2f(u, v) };
}

pub fn retrace_glEvalCoord2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let u: &mut [GLfloat];
    u = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat111_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat111_0) = _a_GLfloat111_0 {
        for _jGLfloat111 in 0.._a_GLfloat111_0.values.len() {
    u[_jGLfloat111] = (*_a_GLfloat111_0.values[_jGLfloat111]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::EvalCoord2fv(u) };
}

pub fn retrace_glEvalMesh1(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut i1: GLint;
    i1 = (call.arg(1)).to_i32().unwrap();

    let mut i2: GLint;
    i2 = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::EvalMesh1(mode, i1, i2) };
}

pub fn retrace_glEvalPoint1(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut i: GLint;
    i = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::EvalPoint1(i) };
}

pub fn retrace_glEvalMesh2(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut i1: GLint;
    i1 = (call.arg(1)).to_i32().unwrap();

    let mut i2: GLint;
    i2 = (call.arg(2)).to_i32().unwrap();

    let mut j1: GLint;
    j1 = (call.arg(3)).to_i32().unwrap();

    let mut j2: GLint;
    j2 = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::EvalMesh2(mode, i1, i2, j1, j2) };
}

pub fn retrace_glEvalPoint2(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut i: GLint;
    i = (call.arg(0)).to_i32().unwrap();

    let mut j: GLint;
    j = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::EvalPoint2(i, j) };
}

pub fn retrace_glAlphaFunc(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut func: GLenum;
    func = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _ref: GLfloat;
    _ref = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::AlphaFunc(func, _ref) };
}

pub fn retrace_glPixelZoom(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut xfactor: GLfloat;
    xfactor = (call.arg(0)).to_f32().unwrap();

    let mut yfactor: GLfloat;
    yfactor = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PixelZoom(xfactor, yfactor) };
}

pub fn retrace_glPixelTransferf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PixelTransferf(pname, param) };
}

pub fn retrace_glPixelTransferi(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PixelTransferi(pname, param) };
}

pub fn retrace_glPixelMapfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mapsize: GLsizei;
    mapsize = (call.arg(1)).to_i32().unwrap();

    let values: &mut [GLfloat];
    values = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat112_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat112_0) = _a_GLfloat112_0 {
        for _jGLfloat112 in 0.._a_GLfloat112_0.values.len() {
    values[_jGLfloat112] = (*_a_GLfloat112_0.values[_jGLfloat112]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PixelMapfv(map, mapsize, values) };
}

pub fn retrace_glPixelMapuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mapsize: GLsizei;
    mapsize = (call.arg(1)).to_i32().unwrap();

    let values: &mut [GLuint];
    values = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint83_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint83_0) = _a_GLuint83_0 {
        for _jGLuint83 in 0.._a_GLuint83_0.values.len() {
    values[_jGLuint83] = (*_a_GLuint83_0.values[_jGLuint83]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PixelMapuiv(map, mapsize, values) };
}

pub fn retrace_glPixelMapusv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mapsize: GLsizei;
    mapsize = (call.arg(1)).to_i32().unwrap();

    let values: &mut [GLushort];
    values = _allocator.alloc_array::<GLushort>(&call.arg(2));
    let _a_GLushort5_0 = (call.arg(2)).to_array();
    if let Some(_a_GLushort5_0) = _a_GLushort5_0 {
        for _jGLushort5 in 0.._a_GLushort5_0.values.len() {
    values[_jGLushort5] = (*_a_GLushort5_0.values[_jGLushort5]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PixelMapusv(map, mapsize, values) };
}

pub fn retrace_glCopyPixels(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::CopyPixels(x, y, width, height, _type) };
}

pub fn retrace_glDrawPixels(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut width: GLsizei;
    width = (call.arg(0)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(1)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(4)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::DrawPixels(width, height, format, _type, pixels) };
}

pub fn retrace_glGetPixelMapfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let values: &mut [GLfloat];
    values = (call.arg(1)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetPixelMapfv(map, values) };
    let _aPGLfloat1 = (call.arg(1)).to_array();
    if (_aPGLfloat1) {
    }
}

pub fn retrace_glGetPixelMapuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let values: &mut [GLuint];
    values = (call.arg(1)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetPixelMapuiv(map, values) };
    let _aPGLuint21 = (call.arg(1)).to_array();
    if (_aPGLuint21) {
    }
}

pub fn retrace_glGetPixelMapusv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let values: &mut [GLushort];
    values = (call.arg(1)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetPixelMapusv(map, values) };
    let _aPGLushort = (call.arg(1)).to_array();
    if (_aPGLushort) {
    }
}

pub fn retrace_glGetPolygonStipple(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mask: &mut [GLubyte];
    mask = (call.arg(0)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetPolygonStipple(mask) };
}

pub fn retrace_glFrustum(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut left: GLdouble;
    left = (call.arg(0)).to_f64().unwrap();

    let mut right: GLdouble;
    right = (call.arg(1)).to_f64().unwrap();

    let mut bottom: GLdouble;
    bottom = (call.arg(2)).to_f64().unwrap();

    let mut top: GLdouble;
    top = (call.arg(3)).to_f64().unwrap();

    let mut zNear: GLdouble;
    zNear = (call.arg(4)).to_f64().unwrap();

    let mut zFar: GLdouble;
    zFar = (call.arg(5)).to_f64().unwrap();

    unsafe { gl::Frustum(left, right, bottom, top, zNear, zFar) };
}

pub fn retrace_glLoadIdentity(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::LoadIdentity() };
}

pub fn retrace_glLoadMatrixf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat113_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat113_0) = _a_GLfloat113_0 {
        for _jGLfloat113 in 0.._a_GLfloat113_0.values.len() {
    m[_jGLfloat113] = (*_a_GLfloat113_0.values[_jGLfloat113]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::LoadMatrixf(m) };
}

pub fn retrace_glLoadMatrixd(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLdouble];
    m = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble44_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble44_0) = _a_GLdouble44_0 {
        for _jGLdouble44 in 0.._a_GLdouble44_0.values.len() {
    m[_jGLdouble44] = (*_a_GLdouble44_0.values[_jGLdouble44]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::LoadMatrixd(m) };
}

pub fn retrace_glMatrixMode(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::MatrixMode(mode) };
}

pub fn retrace_glMultMatrixf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat114_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat114_0) = _a_GLfloat114_0 {
        for _jGLfloat114 in 0.._a_GLfloat114_0.values.len() {
    m[_jGLfloat114] = (*_a_GLfloat114_0.values[_jGLfloat114]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultMatrixf(m) };
}

pub fn retrace_glMultMatrixd(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLdouble];
    m = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble45_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble45_0) = _a_GLdouble45_0 {
        for _jGLdouble45 in 0.._a_GLdouble45_0.values.len() {
    m[_jGLdouble45] = (*_a_GLdouble45_0.values[_jGLdouble45]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultMatrixd(m) };
}

pub fn retrace_glOrtho(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut left: GLdouble;
    left = (call.arg(0)).to_f64().unwrap();

    let mut right: GLdouble;
    right = (call.arg(1)).to_f64().unwrap();

    let mut bottom: GLdouble;
    bottom = (call.arg(2)).to_f64().unwrap();

    let mut top: GLdouble;
    top = (call.arg(3)).to_f64().unwrap();

    let mut zNear: GLdouble;
    zNear = (call.arg(4)).to_f64().unwrap();

    let mut zFar: GLdouble;
    zFar = (call.arg(5)).to_f64().unwrap();

    unsafe { gl::Ortho(left, right, bottom, top, zNear, zFar) };
}

pub fn retrace_glPopMatrix(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PopMatrix() };
}

pub fn retrace_glPushMatrix(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PushMatrix() };
}

pub fn retrace_glRotated(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut angle: GLdouble;
    angle = (call.arg(0)).to_f64().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::Rotated(angle, x, y, z) };
}

pub fn retrace_glRotatef(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut angle: GLfloat;
    angle = (call.arg(0)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::Rotatef(angle, x, y, z) };
}

pub fn retrace_glScaled(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::Scaled(x, y, z) };
}

pub fn retrace_glScalef(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Scalef(x, y, z) };
}

pub fn retrace_glTranslated(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::Translated(x, y, z) };
}

pub fn retrace_glTranslatef(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Translatef(x, y, z) };
}

pub fn retrace_glDrawArrays(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLint;
    first = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::DrawArrays(mode, first, count) };
}

pub fn retrace_glDrawElements(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::DrawElements(mode, count, _type, indices) };
}

pub fn retrace_glPolygonOffset(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLfloat;
    factor = (call.arg(0)).to_f32().unwrap();

    let mut units: GLfloat;
    units = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PolygonOffset(factor, units) };
}

pub fn retrace_glCopyTexImage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(3)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::CopyTexImage1D(target, level, internalformat, x, y, width, border) };
}

pub fn retrace_glCopyTexImage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(3)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(7)).to_i32().unwrap();

    unsafe { gl::CopyTexImage2D(target, level, internalformat, x, y, width, height, border) };
}

pub fn retrace_glCopyTexSubImage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(3)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::CopyTexSubImage1D(target, level, xoffset, x, y, width) };
}

pub fn retrace_glCopyTexSubImage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(4)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(7)).to_i32().unwrap();

    unsafe { gl::CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height) };
}

pub fn retrace_glTexSubImage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexSubImage1D(target, level, xoffset, width, format, _type, pixels) };
}

pub fn retrace_glTexSubImage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexSubImage2D(target, level, xoffset, yoffset, width, height, format, _type, pixels) };
}

pub fn retrace_glBindTexture(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(1)).to_u32().unwrap();
    texture = _texture_map[texture];

    unsafe { gl::BindTexture(target, texture) };
}

pub fn retrace_glDeleteTextures(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let textures: &mut [GLuint];
    textures = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint84_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint84_0) = _a_GLuint84_0 {
        for _jGLuint84 in 0.._a_GLuint84_0.values.len() {
    textures[_jGLuint84] = (*_a_GLuint84_0.values[_jGLuint84]).to_u32().unwrap();
    textures[_jGLuint84] = _texture_map[textures[_jGLuint84]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteTextures(n, textures) };
}

pub fn retrace_glGenTextures(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let textures: &mut [GLuint];
    textures = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenTextures(n, textures) };
    let _aGLuint86 = (call.arg(1)).to_array();
    if (_aGLuint86) {
        for _jGLuint86 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint86.values[_jGLuint86]).to_u32().unwrap();
    _texture_map[_origResult] = textures[_jGLuint86];
        }
    }
}

pub fn retrace_glArrayElement(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut i: GLint;
    i = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::ArrayElement(i) };
}

pub fn retrace_glColorPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(3), true));

    unsafe { gl::ColorPointer(size, _type, stride, pointer) };
}

pub fn retrace_glDisableClientState(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut array: GLenum;
    array = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::DisableClientState(array) };
}

pub fn retrace_glEdgeFlagPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stride: GLsizei;
    stride = (call.arg(0)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(1), true));

    unsafe { gl::EdgeFlagPointer(stride, pointer) };
}

pub fn retrace_glEnableClientState(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut array: GLenum;
    array = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::EnableClientState(array) };
}

pub fn retrace_glIndexPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(2), true));

    unsafe { gl::IndexPointer(_type, stride, pointer) };
}

pub fn retrace_glInterleavedArrays(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut format: GLenum;
    format = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(2), true));

    unsafe { gl::InterleavedArrays(format, stride, pointer) };
}

pub fn retrace_glNormalPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(2), true));

    unsafe { gl::NormalPointer(_type, stride, pointer) };
}

pub fn retrace_glTexCoordPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(3), true));

    unsafe { gl::TexCoordPointer(size, _type, stride, pointer) };
}

pub fn retrace_glVertexPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(3), true));

    unsafe { gl::VertexPointer(size, _type, stride, pointer) };
}

pub fn retrace_glPrioritizeTextures(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let textures: &mut [GLuint];
    textures = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint87_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint87_0) = _a_GLuint87_0 {
        for _jGLuint87 in 0.._a_GLuint87_0.values.len() {
    textures[_jGLuint87] = (*_a_GLuint87_0.values[_jGLuint87]).to_u32().unwrap();
    textures[_jGLuint87] = _texture_map[textures[_jGLuint87]];
        }
    }
    let params = params.as_mut_ptr();

    let priorities: &mut [GLclampf];
    priorities = _allocator.alloc_array::<GLclampf>(&call.arg(2));
    let _a_GLclampf1_0 = (call.arg(2)).to_array();
    if let Some(_a_GLclampf1_0) = _a_GLclampf1_0 {
        for _jGLclampf1 in 0.._a_GLclampf1_0.values.len() {
    priorities[_jGLclampf1] = (*_a_GLclampf1_0.values[_jGLclampf1]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PrioritizeTextures(n, textures, priorities) };
}

pub fn retrace_glIndexub(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut c: GLubyte;
    c = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::Indexub(c) };
}

pub fn retrace_glIndexubv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let c: &mut [GLubyte];
    c = _allocator.alloc_array::<GLubyte>(&call.arg(0));
    let _a_PGLubyte1_0 = (call.arg(0)).to_array().unwrap();
    c[0] = (_a_PGLubyte1_0.values[0]).to_u32().unwrap();

    unsafe { gl::Indexubv(c) };
}

pub fn retrace_glPopClientAttrib(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PopClientAttrib() };
}

pub fn retrace_glPushClientAttrib(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLbitfield;
    mask = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::PushClientAttrib(mask) };
}

pub fn retrace_glBlendColor(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLfloat;
    red = (call.arg(0)).to_f32().unwrap();

    let mut green: GLfloat;
    green = (call.arg(1)).to_f32().unwrap();

    let mut blue: GLfloat;
    blue = (call.arg(2)).to_f32().unwrap();

    let mut alpha: GLfloat;
    alpha = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::BlendColor(red, green, blue, alpha) };
}

pub fn retrace_glBlendEquation(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquation(mode) };
}

pub fn retrace_glDrawRangeElements(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLuint;
    start = (call.arg(1)).to_u32().unwrap();

    let mut end: GLuint;
    end = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::DrawRangeElements(mode, start, end, count, _type, indices) };
}

pub fn retrace_glTexImage3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLint;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexImage3D(target, level, internalformat, width, height, depth, border, format, _type, pixels) };
}

pub fn retrace_glTexSubImage3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, _type, pixels) };
}

pub fn retrace_glCopyTexSubImage3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(5)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(6)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(7)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(8)).to_i32().unwrap();

    unsafe { gl::CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height) };
}

pub fn retrace_glColorTable(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let table: &mut [GLvoid];
    let table = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ColorTable(target, internalformat, width, format, _type, table) };
}

pub fn retrace_glColorTableParameterfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat115_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat115_0) = _a_GLfloat115_0 {
        for _jGLfloat115 in 0.._a_GLfloat115_0.values.len() {
    params[_jGLfloat115] = (*_a_GLfloat115_0.values[_jGLfloat115]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ColorTableParameterfv(target, pname, params) };
}

pub fn retrace_glColorTableParameteriv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint150_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint150_0) = _a_GLint150_0 {
        for _jGLint150 in 0.._a_GLint150_0.values.len() {
    params[_jGLint150] = (*_a_GLint150_0.values[_jGLint150]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ColorTableParameteriv(target, pname, params) };
}

pub fn retrace_glCopyColorTable(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::CopyColorTable(target, internalformat, x, y, width) };
}

pub fn retrace_glColorSubTable(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLsizei;
    start = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ColorSubTable(target, start, count, format, _type, data) };
}

pub fn retrace_glCopyColorSubTable(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLsizei;
    start = (call.arg(1)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::CopyColorSubTable(target, start, x, y, width) };
}

pub fn retrace_glConvolutionFilter1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let image: &mut [GLvoid];
    let image = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ConvolutionFilter1D(target, internalformat, width, format, _type, image) };
}

pub fn retrace_glConvolutionFilter2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let image: &mut [GLvoid];
    let image = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ConvolutionFilter2D(target, internalformat, width, height, format, _type, image) };
}

pub fn retrace_glConvolutionParameterf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut params: GLfloat;
    params = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::ConvolutionParameterf(target, pname, params) };
}

pub fn retrace_glConvolutionParameterfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat116_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat116_0) = _a_GLfloat116_0 {
        for _jGLfloat116 in 0.._a_GLfloat116_0.values.len() {
    params[_jGLfloat116] = (*_a_GLfloat116_0.values[_jGLfloat116]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ConvolutionParameterfv(target, pname, params) };
}

pub fn retrace_glConvolutionParameteri(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut params: GLint;
    params = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ConvolutionParameteri(target, pname, params) };
}

pub fn retrace_glConvolutionParameteriv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint151_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint151_0) = _a_GLint151_0 {
        for _jGLint151 in 0.._a_GLint151_0.values.len() {
    params[_jGLint151] = (*_a_GLint151_0.values[_jGLint151]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ConvolutionParameteriv(target, pname, params) };
}

pub fn retrace_glCopyConvolutionFilter1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::CopyConvolutionFilter1D(target, internalformat, x, y, width) };
}

pub fn retrace_glCopyConvolutionFilter2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::CopyConvolutionFilter2D(target, internalformat, x, y, width, height) };
}

pub fn retrace_glGetConvolutionFilter(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let image: &mut [GLvoid];
    image = (call.arg(3)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetConvolutionFilter(target, format, _type, image) };
}

pub fn retrace_glGetSeparableFilter(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let row: &mut [GLvoid];
    row = (call.arg(3)).to_pointer();

    let column: &mut [GLvoid];
    column = (call.arg(4)).to_pointer();

    let span: &mut [GLvoid];
    span = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetSeparableFilter(target, format, _type, row, column, span) };
}

pub fn retrace_glSeparableFilter2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let row: &mut [GLvoid];
    let row = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    let column: &mut [GLvoid];
    let column = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::SeparableFilter2D(target, internalformat, width, height, format, _type, row, column) };
}

pub fn retrace_glGetHistogram(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut reset: GLboolean;
    reset = (call.arg(1)).to_u32().unwrap() as u8;

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let values: &mut [GLvoid];
    values = (call.arg(4)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetHistogram(target, reset, format, _type, values) };
}

pub fn retrace_glGetMinmax(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut reset: GLboolean;
    reset = (call.arg(1)).to_u32().unwrap() as u8;

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let values: &mut [GLvoid];
    values = (call.arg(4)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetMinmax(target, reset, format, _type, values) };
}

pub fn retrace_glHistogram(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut sink: GLboolean;
    sink = (call.arg(3)).to_u32().unwrap() as u8;

    unsafe { gl::Histogram(target, width, internalformat, sink) };
}

pub fn retrace_glMinmax(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut sink: GLboolean;
    sink = (call.arg(2)).to_u32().unwrap() as u8;

    unsafe { gl::Minmax(target, internalformat, sink) };
}

pub fn retrace_glResetHistogram(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ResetHistogram(target) };
}

pub fn retrace_glResetMinmax(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ResetMinmax(target) };
}

pub fn retrace_glActiveTexture(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ActiveTexture(texture) };
}

pub fn retrace_glSampleCoverage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut value: GLfloat;
    value = (call.arg(0)).to_f32().unwrap();

    let mut invert: GLboolean;
    invert = (call.arg(1)).to_u32().unwrap() as u8;

    unsafe { gl::SampleCoverage(value, invert) };
}

pub fn retrace_glCompressedTexImage3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(7)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data) };
}

pub fn retrace_glCompressedTexImage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(5)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(6)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data) };
}

pub fn retrace_glCompressedTexImage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(4)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(5)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data) };
}

pub fn retrace_glCompressedTexSubImage3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(9)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data) };
}

pub fn retrace_glCompressedTexSubImage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(7)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data) };
}

pub fn retrace_glCompressedTexSubImage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(5)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data) };
}

pub fn retrace_glGetCompressedTexImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let img: &mut [GLvoid];
    img = (call.arg(2)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetCompressedTexImage(target, level, img) };
}

pub fn retrace_glClientActiveTexture(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ClientActiveTexture(texture) };
}

pub fn retrace_glMultiTexCoord1d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLdouble;
    s = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::MultiTexCoord1d(target, s) };
}

pub fn retrace_glMultiTexCoord1dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_PGLdouble4_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLdouble4_0.values[0]).to_f64().unwrap();

    unsafe { gl::MultiTexCoord1dv(target, v) };
}

pub fn retrace_glMultiTexCoord1f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::MultiTexCoord1f(target, s) };
}

pub fn retrace_glMultiTexCoord1fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_PGLfloat14_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLfloat14_0.values[0]).to_f32().unwrap();

    unsafe { gl::MultiTexCoord1fv(target, v) };
}

pub fn retrace_glMultiTexCoord1i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLint;
    s = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord1i(target, s) };
}

pub fn retrace_glMultiTexCoord1iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_PGLint31_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLint31_0.values[0]).to_i32().unwrap();

    unsafe { gl::MultiTexCoord1iv(target, v) };
}

pub fn retrace_glMultiTexCoord1s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLshort;
    s = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord1s(target, s) };
}

pub fn retrace_glMultiTexCoord1sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_PGLshort2_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLshort2_0.values[0]).to_i32().unwrap();

    unsafe { gl::MultiTexCoord1sv(target, v) };
}

pub fn retrace_glMultiTexCoord2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLdouble;
    s = (call.arg(1)).to_f64().unwrap();

    let mut t: GLdouble;
    t = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::MultiTexCoord2d(target, s, t) };
}

pub fn retrace_glMultiTexCoord2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble46_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble46_0) = _a_GLdouble46_0 {
        for _jGLdouble46 in 0.._a_GLdouble46_0.values.len() {
    v[_jGLdouble46] = (*_a_GLdouble46_0.values[_jGLdouble46]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord2dv(target, v) };
}

pub fn retrace_glMultiTexCoord2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::MultiTexCoord2f(target, s, t) };
}

pub fn retrace_glMultiTexCoord2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat117_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat117_0) = _a_GLfloat117_0 {
        for _jGLfloat117 in 0.._a_GLfloat117_0.values.len() {
    v[_jGLfloat117] = (*_a_GLfloat117_0.values[_jGLfloat117]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord2fv(target, v) };
}

pub fn retrace_glMultiTexCoord2i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLint;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLint;
    t = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord2i(target, s, t) };
}

pub fn retrace_glMultiTexCoord2iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint152_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint152_0) = _a_GLint152_0 {
        for _jGLint152 in 0.._a_GLint152_0.values.len() {
    v[_jGLint152] = (*_a_GLint152_0.values[_jGLint152]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord2iv(target, v) };
}

pub fn retrace_glMultiTexCoord2s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLshort;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLshort;
    t = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord2s(target, s, t) };
}

pub fn retrace_glMultiTexCoord2sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort15_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort15_0) = _a_GLshort15_0 {
        for _jGLshort15 in 0.._a_GLshort15_0.values.len() {
    v[_jGLshort15] = (*_a_GLshort15_0.values[_jGLshort15]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord2sv(target, v) };
}

pub fn retrace_glMultiTexCoord3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLdouble;
    s = (call.arg(1)).to_f64().unwrap();

    let mut t: GLdouble;
    t = (call.arg(2)).to_f64().unwrap();

    let mut r: GLdouble;
    r = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::MultiTexCoord3d(target, s, t, r) };
}

pub fn retrace_glMultiTexCoord3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble47_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble47_0) = _a_GLdouble47_0 {
        for _jGLdouble47 in 0.._a_GLdouble47_0.values.len() {
    v[_jGLdouble47] = (*_a_GLdouble47_0.values[_jGLdouble47]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord3dv(target, v) };
}

pub fn retrace_glMultiTexCoord3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(2)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::MultiTexCoord3f(target, s, t, r) };
}

pub fn retrace_glMultiTexCoord3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat118_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat118_0) = _a_GLfloat118_0 {
        for _jGLfloat118 in 0.._a_GLfloat118_0.values.len() {
    v[_jGLfloat118] = (*_a_GLfloat118_0.values[_jGLfloat118]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord3fv(target, v) };
}

pub fn retrace_glMultiTexCoord3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLint;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLint;
    t = (call.arg(2)).to_i32().unwrap();

    let mut r: GLint;
    r = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord3i(target, s, t, r) };
}

pub fn retrace_glMultiTexCoord3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint153_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint153_0) = _a_GLint153_0 {
        for _jGLint153 in 0.._a_GLint153_0.values.len() {
    v[_jGLint153] = (*_a_GLint153_0.values[_jGLint153]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord3iv(target, v) };
}

pub fn retrace_glMultiTexCoord3s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLshort;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLshort;
    t = (call.arg(2)).to_i32().unwrap();

    let mut r: GLshort;
    r = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord3s(target, s, t, r) };
}

pub fn retrace_glMultiTexCoord3sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort16_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort16_0) = _a_GLshort16_0 {
        for _jGLshort16 in 0.._a_GLshort16_0.values.len() {
    v[_jGLshort16] = (*_a_GLshort16_0.values[_jGLshort16]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord3sv(target, v) };
}

pub fn retrace_glMultiTexCoord4d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLdouble;
    s = (call.arg(1)).to_f64().unwrap();

    let mut t: GLdouble;
    t = (call.arg(2)).to_f64().unwrap();

    let mut r: GLdouble;
    r = (call.arg(3)).to_f64().unwrap();

    let mut q: GLdouble;
    q = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::MultiTexCoord4d(target, s, t, r, q) };
}

pub fn retrace_glMultiTexCoord4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble48_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble48_0) = _a_GLdouble48_0 {
        for _jGLdouble48 in 0.._a_GLdouble48_0.values.len() {
    v[_jGLdouble48] = (*_a_GLdouble48_0.values[_jGLdouble48]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord4dv(target, v) };
}

pub fn retrace_glMultiTexCoord4f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(2)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(3)).to_f32().unwrap();

    let mut q: GLfloat;
    q = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::MultiTexCoord4f(target, s, t, r, q) };
}

pub fn retrace_glMultiTexCoord4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat119_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat119_0) = _a_GLfloat119_0 {
        for _jGLfloat119 in 0.._a_GLfloat119_0.values.len() {
    v[_jGLfloat119] = (*_a_GLfloat119_0.values[_jGLfloat119]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord4fv(target, v) };
}

pub fn retrace_glMultiTexCoord4i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLint;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLint;
    t = (call.arg(2)).to_i32().unwrap();

    let mut r: GLint;
    r = (call.arg(3)).to_i32().unwrap();

    let mut q: GLint;
    q = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord4i(target, s, t, r, q) };
}

pub fn retrace_glMultiTexCoord4iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint154_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint154_0) = _a_GLint154_0 {
        for _jGLint154 in 0.._a_GLint154_0.values.len() {
    v[_jGLint154] = (*_a_GLint154_0.values[_jGLint154]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord4iv(target, v) };
}

pub fn retrace_glMultiTexCoord4s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLshort;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLshort;
    t = (call.arg(2)).to_i32().unwrap();

    let mut r: GLshort;
    r = (call.arg(3)).to_i32().unwrap();

    let mut q: GLshort;
    q = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord4s(target, s, t, r, q) };
}

pub fn retrace_glMultiTexCoord4sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort17_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort17_0) = _a_GLshort17_0 {
        for _jGLshort17 in 0.._a_GLshort17_0.values.len() {
    v[_jGLshort17] = (*_a_GLshort17_0.values[_jGLshort17]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord4sv(target, v) };
}

pub fn retrace_glLoadTransposeMatrixf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat120_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat120_0) = _a_GLfloat120_0 {
        for _jGLfloat120 in 0.._a_GLfloat120_0.values.len() {
    m[_jGLfloat120] = (*_a_GLfloat120_0.values[_jGLfloat120]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::LoadTransposeMatrixf(m) };
}

pub fn retrace_glLoadTransposeMatrixd(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLdouble];
    m = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble49_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble49_0) = _a_GLdouble49_0 {
        for _jGLdouble49 in 0.._a_GLdouble49_0.values.len() {
    m[_jGLdouble49] = (*_a_GLdouble49_0.values[_jGLdouble49]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::LoadTransposeMatrixd(m) };
}

pub fn retrace_glMultTransposeMatrixf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat121_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat121_0) = _a_GLfloat121_0 {
        for _jGLfloat121 in 0.._a_GLfloat121_0.values.len() {
    m[_jGLfloat121] = (*_a_GLfloat121_0.values[_jGLfloat121]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultTransposeMatrixf(m) };
}

pub fn retrace_glMultTransposeMatrixd(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLdouble];
    m = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble50_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble50_0) = _a_GLdouble50_0 {
        for _jGLdouble50 in 0.._a_GLdouble50_0.values.len() {
    m[_jGLdouble50] = (*_a_GLdouble50_0.values[_jGLdouble50]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultTransposeMatrixd(m) };
}

pub fn retrace_glBlendFuncSeparate(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sfactorRGB: GLenum;
    sfactorRGB = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dfactorRGB: GLenum;
    dfactorRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut sfactorAlpha: GLenum;
    sfactorAlpha = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut dfactorAlpha: GLenum;
    dfactorAlpha = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha) };
}

pub fn retrace_glMultiDrawArrays(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let first: &mut [GLint];
    first = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint155_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint155_0) = _a_GLint155_0 {
        for _jGLint155 in 0.._a_GLint155_0.values.len() {
    first[_jGLint155] = (*_a_GLint155_0.values[_jGLint155]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let count: &mut [GLsizei];
    count = _allocator.alloc_array::<GLsizei>(&call.arg(2));
    let _a_GLsizei5_0 = (call.arg(2)).to_array();
    if let Some(_a_GLsizei5_0) = _a_GLsizei5_0 {
        for _jGLsizei5 in 0.._a_GLsizei5_0.values.len() {
    count[_jGLsizei5] = (*_a_GLsizei5_0.values[_jGLsizei5]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut drawcount: GLsizei;
    drawcount = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiDrawArrays(mode, first, count, drawcount) };
}

pub fn retrace_glMultiDrawElements(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let count: &mut [GLsizei];
    count = _allocator.alloc_array::<GLsizei>(&call.arg(1));
    let _a_GLsizei6_0 = (call.arg(1)).to_array();
    if let Some(_a_GLsizei6_0) = _a_GLsizei6_0 {
        for _jGLsizei6 in 0.._a_GLsizei6_0.values.len() {
    count[_jGLsizei6] = (*_a_GLsizei6_0.values[_jGLsizei6]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    indices = _allocator.alloc_array::< GLvoid >(&call.arg(3));
    let _a_constGLvoid222_0 = (call.arg(3)).to_array();
    if let Some(_a_constGLvoid222_0) = _a_constGLvoid222_0 {
        for _jconstGLvoid222 in 0.._a_constGLvoid222_0.values.len() {
    let indices[_jconstGLvoid222] = (*_a_constGLvoid222_0.values[_jconstGLvoid222]).to_pointer().unwrap() as *mut c_void;
        }
    }
    let params = params.as_mut_ptr();

    let mut drawcount: GLsizei;
    drawcount = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiDrawElements(mode, count, _type, indices, drawcount) };
}

pub fn retrace_glPointParameterf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PointParameterf(pname, param) };
}

pub fn retrace_glPointParameterfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat122_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat122_0) = _a_GLfloat122_0 {
        for _jGLfloat122 in 0.._a_GLfloat122_0.values.len() {
    params[_jGLfloat122] = (*_a_GLfloat122_0.values[_jGLfloat122]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PointParameterfv(pname, params) };
}

pub fn retrace_glPointParameteri(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PointParameteri(pname, param) };
}

pub fn retrace_glPointParameteriv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint156_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint156_0) = _a_GLint156_0 {
        for _jGLint156 in 0.._a_GLint156_0.values.len() {
    params[_jGLint156] = (*_a_GLint156_0.values[_jGLint156]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PointParameteriv(pname, params) };
}

pub fn retrace_glFogCoordf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLfloat;
    coord = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::FogCoordf(coord) };
}

pub fn retrace_glFogCoordfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let coord: &mut [GLfloat];
    coord = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_PGLfloat15_0 = (call.arg(0)).to_array().unwrap();
    coord[0] = (_a_PGLfloat15_0.values[0]).to_f32().unwrap();

    unsafe { gl::FogCoordfv(coord) };
}

pub fn retrace_glFogCoordd(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLdouble;
    coord = (call.arg(0)).to_f64().unwrap();

    unsafe { gl::FogCoordd(coord) };
}

pub fn retrace_glFogCoorddv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let coord: &mut [GLdouble];
    coord = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_PGLdouble5_0 = (call.arg(0)).to_array().unwrap();
    coord[0] = (_a_PGLdouble5_0.values[0]).to_f64().unwrap();

    unsafe { gl::FogCoorddv(coord) };
}

pub fn retrace_glFogCoordPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(2), true));

    unsafe { gl::FogCoordPointer(_type, stride, pointer) };
}

pub fn retrace_glSecondaryColor3b(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLbyte;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLbyte;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLbyte;
    blue = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::SecondaryColor3b(red, green, blue) };
}

pub fn retrace_glSecondaryColor3bv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(0));
    let _a_GLbyte4_0 = (call.arg(0)).to_array();
    if let Some(_a_GLbyte4_0) = _a_GLbyte4_0 {
        for _jGLbyte4 in 0.._a_GLbyte4_0.values.len() {
    v[_jGLbyte4] = (*_a_GLbyte4_0.values[_jGLbyte4]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3bv(v) };
}

pub fn retrace_glSecondaryColor3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLdouble;
    red = (call.arg(0)).to_f64().unwrap();

    let mut green: GLdouble;
    green = (call.arg(1)).to_f64().unwrap();

    let mut blue: GLdouble;
    blue = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::SecondaryColor3d(red, green, blue) };
}

pub fn retrace_glSecondaryColor3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble51_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble51_0) = _a_GLdouble51_0 {
        for _jGLdouble51 in 0.._a_GLdouble51_0.values.len() {
    v[_jGLdouble51] = (*_a_GLdouble51_0.values[_jGLdouble51]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3dv(v) };
}

pub fn retrace_glSecondaryColor3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLfloat;
    red = (call.arg(0)).to_f32().unwrap();

    let mut green: GLfloat;
    green = (call.arg(1)).to_f32().unwrap();

    let mut blue: GLfloat;
    blue = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::SecondaryColor3f(red, green, blue) };
}

pub fn retrace_glSecondaryColor3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat123_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat123_0) = _a_GLfloat123_0 {
        for _jGLfloat123 in 0.._a_GLfloat123_0.values.len() {
    v[_jGLfloat123] = (*_a_GLfloat123_0.values[_jGLfloat123]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3fv(v) };
}

pub fn retrace_glSecondaryColor3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLint;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLint;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLint;
    blue = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::SecondaryColor3i(red, green, blue) };
}

pub fn retrace_glSecondaryColor3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint157_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint157_0) = _a_GLint157_0 {
        for _jGLint157 in 0.._a_GLint157_0.values.len() {
    v[_jGLint157] = (*_a_GLint157_0.values[_jGLint157]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3iv(v) };
}

pub fn retrace_glSecondaryColor3s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLshort;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLshort;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLshort;
    blue = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::SecondaryColor3s(red, green, blue) };
}

pub fn retrace_glSecondaryColor3sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort18_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort18_0) = _a_GLshort18_0 {
        for _jGLshort18 in 0.._a_GLshort18_0.values.len() {
    v[_jGLshort18] = (*_a_GLshort18_0.values[_jGLshort18]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3sv(v) };
}

pub fn retrace_glSecondaryColor3ub(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLubyte;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLubyte;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLubyte;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::SecondaryColor3ub(red, green, blue) };
}

pub fn retrace_glSecondaryColor3ubv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(0));
    let _a_GLubyte9_0 = (call.arg(0)).to_array();
    if let Some(_a_GLubyte9_0) = _a_GLubyte9_0 {
        for _jGLubyte9 in 0.._a_GLubyte9_0.values.len() {
    v[_jGLubyte9] = (*_a_GLubyte9_0.values[_jGLubyte9]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3ubv(v) };
}

pub fn retrace_glSecondaryColor3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLuint;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLuint;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLuint;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::SecondaryColor3ui(red, green, blue) };
}

pub fn retrace_glSecondaryColor3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_GLuint88_0 = (call.arg(0)).to_array();
    if let Some(_a_GLuint88_0) = _a_GLuint88_0 {
        for _jGLuint88 in 0.._a_GLuint88_0.values.len() {
    v[_jGLuint88] = (*_a_GLuint88_0.values[_jGLuint88]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3uiv(v) };
}

pub fn retrace_glSecondaryColor3us(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLushort;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLushort;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLushort;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::SecondaryColor3us(red, green, blue) };
}

pub fn retrace_glSecondaryColor3usv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLushort];
    v = _allocator.alloc_array::<GLushort>(&call.arg(0));
    let _a_GLushort6_0 = (call.arg(0)).to_array();
    if let Some(_a_GLushort6_0) = _a_GLushort6_0 {
        for _jGLushort6 in 0.._a_GLushort6_0.values.len() {
    v[_jGLushort6] = (*_a_GLushort6_0.values[_jGLushort6]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3usv(v) };
}

pub fn retrace_glSecondaryColorPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(3), true));

    unsafe { gl::SecondaryColorPointer(size, _type, stride, pointer) };
}

pub fn retrace_glWindowPos2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::WindowPos2d(x, y) };
}

pub fn retrace_glWindowPos2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble52_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble52_0) = _a_GLdouble52_0 {
        for _jGLdouble52 in 0.._a_GLdouble52_0.values.len() {
    v[_jGLdouble52] = (*_a_GLdouble52_0.values[_jGLdouble52]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2dv(v) };
}

pub fn retrace_glWindowPos2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::WindowPos2f(x, y) };
}

pub fn retrace_glWindowPos2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat124_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat124_0) = _a_GLfloat124_0 {
        for _jGLfloat124 in 0.._a_GLfloat124_0.values.len() {
    v[_jGLfloat124] = (*_a_GLfloat124_0.values[_jGLfloat124]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2fv(v) };
}

pub fn retrace_glWindowPos2i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::WindowPos2i(x, y) };
}

pub fn retrace_glWindowPos2iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint158_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint158_0) = _a_GLint158_0 {
        for _jGLint158 in 0.._a_GLint158_0.values.len() {
    v[_jGLint158] = (*_a_GLint158_0.values[_jGLint158]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2iv(v) };
}

pub fn retrace_glWindowPos2s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::WindowPos2s(x, y) };
}

pub fn retrace_glWindowPos2sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort19_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort19_0) = _a_GLshort19_0 {
        for _jGLshort19 in 0.._a_GLshort19_0.values.len() {
    v[_jGLshort19] = (*_a_GLshort19_0.values[_jGLshort19]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2sv(v) };
}

pub fn retrace_glWindowPos3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::WindowPos3d(x, y, z) };
}

pub fn retrace_glWindowPos3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble53_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble53_0) = _a_GLdouble53_0 {
        for _jGLdouble53 in 0.._a_GLdouble53_0.values.len() {
    v[_jGLdouble53] = (*_a_GLdouble53_0.values[_jGLdouble53]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3dv(v) };
}

pub fn retrace_glWindowPos3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::WindowPos3f(x, y, z) };
}

pub fn retrace_glWindowPos3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat125_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat125_0) = _a_GLfloat125_0 {
        for _jGLfloat125 in 0.._a_GLfloat125_0.values.len() {
    v[_jGLfloat125] = (*_a_GLfloat125_0.values[_jGLfloat125]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3fv(v) };
}

pub fn retrace_glWindowPos3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::WindowPos3i(x, y, z) };
}

pub fn retrace_glWindowPos3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint159_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint159_0) = _a_GLint159_0 {
        for _jGLint159 in 0.._a_GLint159_0.values.len() {
    v[_jGLint159] = (*_a_GLint159_0.values[_jGLint159]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3iv(v) };
}

pub fn retrace_glWindowPos3s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::WindowPos3s(x, y, z) };
}

pub fn retrace_glWindowPos3sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort20_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort20_0) = _a_GLshort20_0 {
        for _jGLshort20 in 0.._a_GLshort20_0.values.len() {
    v[_jGLshort20] = (*_a_GLshort20_0.values[_jGLshort20]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3sv(v) };
}

pub fn retrace_glGenQueries(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenQueries(n, ids) };
    let _aGLuint90 = (call.arg(1)).to_array();
    if (_aGLuint90) {
        for _jGLuint90 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint90.values[_jGLuint90]).to_u32().unwrap();
    _query_map[_origResult] = ids[_jGLuint90];
        }
    }
}

pub fn retrace_glDeleteQueries(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint91_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint91_0) = _a_GLuint91_0 {
        for _jGLuint91 in 0.._a_GLuint91_0.values.len() {
    ids[_jGLuint91] = (*_a_GLuint91_0.values[_jGLuint91]).to_u32().unwrap();
    ids[_jGLuint91] = _query_map[ids[_jGLuint91]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteQueries(n, ids) };
}

pub fn retrace_glBeginQuery(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _query_map[id];

    unsafe { gl::BeginQuery(target, id) };
}

pub fn retrace_glEndQuery(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::EndQuery(target) };
}

pub fn retrace_glGetQueryObjectiv(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    GLint retval;
    if (_query_buffer)
        params = static_cast<GLint *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectiv(id, pname, params) };
    let _aGLint161 = (call.arg(2)).to_array();
    if (_aGLint161) {
        for _jGLint161 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glGetQueryObjectuiv(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint];
    GLuint retval;
    if (_query_buffer)
        params = static_cast<GLuint *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectuiv(id, pname, params) };
    let _aGLuint93 = (call.arg(2)).to_array();
    if (_aGLuint93) {
        for _jGLuint93 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glBindBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::BindBuffer(target, buffer) };
}

pub fn retrace_glDeleteBuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let buffers: &mut [GLuint];
    buffers = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint94_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint94_0) = _a_GLuint94_0 {
        for _jGLuint94 in 0.._a_GLuint94_0.values.len() {
    buffers[_jGLuint94] = (*_a_GLuint94_0.values[_jGLuint94]).to_u32().unwrap();
    buffers[_jGLuint94] = _buffer_map[buffers[_jGLuint94]];
        }
    }
    let params = params.as_mut_ptr();

    if (currentContext && currentContext->features().ARB_direct_state_access) {
        for (GLsizei i = 0; i < n; ++i) {
            GLuint buffer = buffers[i];
            if (buffer != 0 && glIsBuffer(buffer)) {
                GLvoid *ptr = nullptr;
                glGetNamedBufferPointerv(buffers[i], GL_BUFFER_MAP_POINTER, &ptr);
                if (ptr) {
                    retrace::delRegionByPointer(ptr);
                }
            }
        }
    }
    unsafe { gl::DeleteBuffers(n, buffers) };
}

pub fn retrace_glGenBuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let buffers: &mut [GLuint];
    buffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenBuffers(n, buffers) };
    let _aGLuint96 = (call.arg(1)).to_array();
    if (_aGLuint96) {
        for _jGLuint96 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint96.values[_jGLuint96]).to_u32().unwrap();
    _buffer_map[_origResult] = buffers[_jGLuint96];
        }
    }
}

pub fn retrace_glBufferData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(1)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut usage: GLenum;
    usage = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BufferData(target, size, data, usage) };
}

pub fn retrace_glBufferSubData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(2)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::BufferSubData(target, offset, size, data) };
}

pub fn retrace_glMapBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut access: GLenum;
    access = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::MapBuffer(target, access) };

    let length = 0;
    gl::GetBufferParameteriv(target, gl::BUFFER_SIZE, &length);
    retrace::addRegion(call, (*call.ret).toUIntPtr(), _result, length);
}

pub fn retrace_glUnmapBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

        GLvoid *ptr = NULL;
            glGetBufferPointerv(target, GL_BUFFER_MAP_POINTER, &ptr);
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "failed to get mapped pointer\n";
        }
    let _result = unsafe { gl::UnmapBuffer(target) };

}

pub fn retrace_glBlendEquationSeparate(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut modeRGB: GLenum;
    modeRGB = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut modeAlpha: GLenum;
    modeAlpha = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationSeparate(modeRGB, modeAlpha) };
}

pub fn retrace_glDrawBuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let bufs: &mut [GLenum];
    bufs = _allocator.alloc_array::<GLenum>(&call.arg(1));
    let _a_GLenum14_0 = (call.arg(1)).to_array();
    if let Some(_a_GLenum14_0) = _a_GLenum14_0 {
        for _jGLenum14 in 0.._a_GLenum14_0.values.len() {
    bufs[_jGLenum14] = (*_a_GLenum14_0.values[_jGLenum14]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DrawBuffers(n, bufs) };
}

pub fn retrace_glStencilOpSeparate(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut sfail: GLenum;
    sfail = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dpfail: GLenum;
    dpfail = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut dppass: GLenum;
    dppass = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::StencilOpSeparate(face, sfail, dpfail, dppass) };
}

pub fn retrace_glStencilFuncSeparate(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut func: GLenum;
    func = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _ref: GLint;
    _ref = (call.arg(2)).to_i32().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::StencilFuncSeparate(face, func, _ref, mask) };
}

pub fn retrace_glStencilMaskSeparate(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::StencilMaskSeparate(face, mask) };
}

pub fn retrace_glAttachShader(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut shader: GLuint;
    shader = (call.arg(1)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    unsafe { gl::AttachShader(program, shader) };
}

pub fn retrace_glBindAttribLocation(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(2)).to_string().unwrap());

    unsafe { gl::BindAttribLocation(program, index, name) };
}

pub fn retrace_glCompileShader(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut shader: GLuint;
    shader = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    unsafe { gl::CompileShader(shader) };
        let compile_status = 0;
        gl::GetShaderiv(shader, gl::COMPILE_STATUS, &compile_status);
        if compile_status == 0 {
             println!()"compilation failed");
        }
        let info_log_length = 0;
        gl::GetShaderiv(shader, gl::INFO_LOG_LENGTH, &info_log_length);
        if info_log_length > 1 {
             let infoLog = vec![0i8; info_log_length].as_mut_ptr();
             gl::GetShaderInfoLog(shader, info_log_length, std::ptr::null_mut(), infoLog);
        }
}

pub fn retrace_glCreateProgram(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let _result = unsafe { gl::CreateProgram() };

    let _origResult: GLuint;
    _origResult = (*call.ret).to_u32().unwrap();
if (glretrace::supportsARBShaderObjects) {
    _handleARB_map[_origResult] = _result;
} else {
    _program_map[_origResult] = _result;
}
}

pub fn retrace_glCreateShader(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::CreateShader(_type) };

    let _origResult: GLuint;
    _origResult = (*call.ret).to_u32().unwrap();
if (glretrace::supportsARBShaderObjects) {
    _handleARB_map[_origResult] = _result;
} else {
    _shader_map[_origResult] = _result;
}
}

pub fn retrace_glDeleteProgram(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    unsafe { gl::DeleteProgram(program) };
}

pub fn retrace_glDeleteShader(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut shader: GLuint;
    shader = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    unsafe { gl::DeleteShader(shader) };
}

pub fn retrace_glDetachShader(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut shader: GLuint;
    shader = (call.arg(1)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    if (!retrace::dumpingState) {
    unsafe { gl::DetachShader(program, shader) };
    }
}

pub fn retrace_glDisableVertexAttribArray(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::DisableVertexAttribArray(index) };
}

pub fn retrace_glEnableVertexAttribArray(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::EnableVertexAttribArray(index) };
}

pub fn retrace_glGetAttribLocation(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(1)).to_string().unwrap());

    let _result = unsafe { gl::GetAttribLocation(program, name) };

    let _origResult = call.ret.to_i32().unwrap();
}

pub fn retrace_glGetUniformLocation(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(1)).to_string().unwrap());

    let _result = unsafe { gl::GetUniformLocation(program, name) };

    let _origResult: GLint;
    _origResult = (*call.ret).to_i32().unwrap();
    _location_map[program][_origResult] = _result;
}

pub fn retrace_glLinkProgram(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    unsafe { gl::LinkProgram(program) };
        let link_status = 0;
        gl::GetProgramiv(program, gl::LINK_STATUS, &link_status);
        if link_status == 0 {
             println!("link failed");
        }
        let info_log_length = 0;
        gl::GetProgramiv(program, gl::INFO_LOG_LENGTH, &info_log_length);
        if info_log_length > 1 {
             let infoLog = vec![0i8; info_log_length].as_mut_ptr();
             gl::GetProgramInfoLog(program, info_log_length, std::ptr::null_mut(), infoLog);
        }
}

pub fn retrace_glShaderSource(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut shader: GLuint;
    shader = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let string: &mut [GLchar];
    string = _allocator.alloc_array::< GLchar >(&call.arg(2));
    let _a_constGLchar22_0 = (call.arg(2)).to_array();
    if let Some(_a_constGLchar22_0) = _a_constGLchar22_0 {
        for _jconstGLchar22 in 0.._a_constGLchar22_0.values.len() {
    string[_jconstGLchar22] = (const GLchar *)((*_a_constGLchar22_0.values[_jconstGLchar22]).to_string().unwrap());
        }
    }
    let params = params.as_mut_ptr();

    let length: &mut [GLint];
    length = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint162_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint162_0) = _a_GLint162_0 {
        for _jGLint162 in 0.._a_GLint162_0.values.len() {
    length[_jGLint162] = (*_a_GLint162_0.values[_jGLint162]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ShaderSource(shader, count, string, length) };
}

pub fn retrace_glUseProgram(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    unsafe { gl::UseProgram(program) };
        self.context.currentUserProgram = call.arg(0).to_u32().unwrap();
        self.context.currentProgram = _glGetInteger(GL_CURRENT_PROGRAM);
}

pub fn retrace_glUniform1f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::Uniform1f(location, v0) };
}

pub fn retrace_glUniform2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(1)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Uniform2f(location, v0, v1) };
}

pub fn retrace_glUniform3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(1)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(2)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::Uniform3f(location, v0, v1, v2) };
}

pub fn retrace_glUniform4f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(1)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(2)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(3)).to_f32().unwrap();

    let mut v3: GLfloat;
    v3 = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::Uniform4f(location, v0, v1, v2, v3) };
}

pub fn retrace_glUniform1i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::Uniform1i(location, v0) };
}

pub fn retrace_glUniform2i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(1)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Uniform2i(location, v0, v1) };
}

pub fn retrace_glUniform3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(1)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(2)).to_i32().unwrap();

    let mut v2: GLint;
    v2 = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Uniform3i(location, v0, v1, v2) };
}

pub fn retrace_glUniform4i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(1)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(2)).to_i32().unwrap();

    let mut v2: GLint;
    v2 = (call.arg(3)).to_i32().unwrap();

    let mut v3: GLint;
    v3 = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::Uniform4i(location, v0, v1, v2, v3) };
}

pub fn retrace_glUniform1fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat126_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat126_0) = _a_GLfloat126_0 {
        for _jGLfloat126 in 0.._a_GLfloat126_0.values.len() {
    value[_jGLfloat126] = (*_a_GLfloat126_0.values[_jGLfloat126]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1fv(location, count, value) };
}

pub fn retrace_glUniform2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat127_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat127_0) = _a_GLfloat127_0 {
        for _jGLfloat127 in 0.._a_GLfloat127_0.values.len() {
    value[_jGLfloat127] = (*_a_GLfloat127_0.values[_jGLfloat127]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2fv(location, count, value) };
}

pub fn retrace_glUniform3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat128_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat128_0) = _a_GLfloat128_0 {
        for _jGLfloat128 in 0.._a_GLfloat128_0.values.len() {
    value[_jGLfloat128] = (*_a_GLfloat128_0.values[_jGLfloat128]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3fv(location, count, value) };
}

pub fn retrace_glUniform4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat129_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat129_0) = _a_GLfloat129_0 {
        for _jGLfloat129 in 0.._a_GLfloat129_0.values.len() {
    value[_jGLfloat129] = (*_a_GLfloat129_0.values[_jGLfloat129]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4fv(location, count, value) };
}

pub fn retrace_glUniform1iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint163_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint163_0) = _a_GLint163_0 {
        for _jGLint163 in 0.._a_GLint163_0.values.len() {
    value[_jGLint163] = (*_a_GLint163_0.values[_jGLint163]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1iv(location, count, value) };
}

pub fn retrace_glUniform2iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint164_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint164_0) = _a_GLint164_0 {
        for _jGLint164 in 0.._a_GLint164_0.values.len() {
    value[_jGLint164] = (*_a_GLint164_0.values[_jGLint164]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2iv(location, count, value) };
}

pub fn retrace_glUniform3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint165_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint165_0) = _a_GLint165_0 {
        for _jGLint165 in 0.._a_GLint165_0.values.len() {
    value[_jGLint165] = (*_a_GLint165_0.values[_jGLint165]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3iv(location, count, value) };
}

pub fn retrace_glUniform4iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint166_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint166_0) = _a_GLint166_0 {
        for _jGLint166 in 0.._a_GLint166_0.values.len() {
    value[_jGLint166] = (*_a_GLint166_0.values[_jGLint166]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4iv(location, count, value) };
}

pub fn retrace_glUniformMatrix2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat130_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat130_0) = _a_GLfloat130_0 {
        for _jGLfloat130 in 0.._a_GLfloat130_0.values.len() {
    value[_jGLfloat130] = (*_a_GLfloat130_0.values[_jGLfloat130]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix2fv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat131_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat131_0) = _a_GLfloat131_0 {
        for _jGLfloat131 in 0.._a_GLfloat131_0.values.len() {
    value[_jGLfloat131] = (*_a_GLfloat131_0.values[_jGLfloat131]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix3fv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat132_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat132_0) = _a_GLfloat132_0 {
        for _jGLfloat132 in 0.._a_GLfloat132_0.values.len() {
    value[_jGLfloat132] = (*_a_GLfloat132_0.values[_jGLfloat132]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix4fv(location, count, transpose, value) };
}

pub fn retrace_glValidateProgram(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    unsafe { gl::ValidateProgram(program) };
}

pub fn retrace_glVertexAttrib1d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::VertexAttrib1d(index, x) };
}

pub fn retrace_glVertexAttrib1dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_PGLdouble6_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLdouble6_0.values[0]).to_f64().unwrap();

    unsafe { gl::VertexAttrib1dv(index, v) };
}

pub fn retrace_glVertexAttrib1f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::VertexAttrib1f(index, x) };
}

pub fn retrace_glVertexAttrib1fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_PGLfloat16_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLfloat16_0.values[0]).to_f32().unwrap();

    unsafe { gl::VertexAttrib1fv(index, v) };
}

pub fn retrace_glVertexAttrib1s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::VertexAttrib1s(index, x) };
}

pub fn retrace_glVertexAttrib1sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_PGLshort3_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLshort3_0.values[0]).to_i32().unwrap();

    unsafe { gl::VertexAttrib1sv(index, v) };
}

pub fn retrace_glVertexAttrib2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::VertexAttrib2d(index, x, y) };
}

pub fn retrace_glVertexAttrib2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble54_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble54_0) = _a_GLdouble54_0 {
        for _jGLdouble54 in 0.._a_GLdouble54_0.values.len() {
    v[_jGLdouble54] = (*_a_GLdouble54_0.values[_jGLdouble54]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib2dv(index, v) };
}

pub fn retrace_glVertexAttrib2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::VertexAttrib2f(index, x, y) };
}

pub fn retrace_glVertexAttrib2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat133_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat133_0) = _a_GLfloat133_0 {
        for _jGLfloat133 in 0.._a_GLfloat133_0.values.len() {
    v[_jGLfloat133] = (*_a_GLfloat133_0.values[_jGLfloat133]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib2fv(index, v) };
}

pub fn retrace_glVertexAttrib2s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::VertexAttrib2s(index, x, y) };
}

pub fn retrace_glVertexAttrib2sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort21_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort21_0) = _a_GLshort21_0 {
        for _jGLshort21 in 0.._a_GLshort21_0.values.len() {
    v[_jGLshort21] = (*_a_GLshort21_0.values[_jGLshort21]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib2sv(index, v) };
}

pub fn retrace_glVertexAttrib3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::VertexAttrib3d(index, x, y, z) };
}

pub fn retrace_glVertexAttrib3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble55_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble55_0) = _a_GLdouble55_0 {
        for _jGLdouble55 in 0.._a_GLdouble55_0.values.len() {
    v[_jGLdouble55] = (*_a_GLdouble55_0.values[_jGLdouble55]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib3dv(index, v) };
}

pub fn retrace_glVertexAttrib3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::VertexAttrib3f(index, x, y, z) };
}

pub fn retrace_glVertexAttrib3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat134_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat134_0) = _a_GLfloat134_0 {
        for _jGLfloat134 in 0.._a_GLfloat134_0.values.len() {
    v[_jGLfloat134] = (*_a_GLfloat134_0.values[_jGLfloat134]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib3fv(index, v) };
}

pub fn retrace_glVertexAttrib3s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexAttrib3s(index, x, y, z) };
}

pub fn retrace_glVertexAttrib3sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort22_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort22_0) = _a_GLshort22_0 {
        for _jGLshort22 in 0.._a_GLshort22_0.values.len() {
    v[_jGLshort22] = (*_a_GLshort22_0.values[_jGLshort22]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib3sv(index, v) };
}

pub fn retrace_glVertexAttrib4Nbv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(1));
    let _a_GLbyte5_0 = (call.arg(1)).to_array();
    if let Some(_a_GLbyte5_0) = _a_GLbyte5_0 {
        for _jGLbyte5 in 0.._a_GLbyte5_0.values.len() {
    v[_jGLbyte5] = (*_a_GLbyte5_0.values[_jGLbyte5]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4Nbv(index, v) };
}

pub fn retrace_glVertexAttrib4Niv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint167_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint167_0) = _a_GLint167_0 {
        for _jGLint167 in 0.._a_GLint167_0.values.len() {
    v[_jGLint167] = (*_a_GLint167_0.values[_jGLint167]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4Niv(index, v) };
}

pub fn retrace_glVertexAttrib4Nsv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort23_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort23_0) = _a_GLshort23_0 {
        for _jGLshort23 in 0.._a_GLshort23_0.values.len() {
    v[_jGLshort23] = (*_a_GLshort23_0.values[_jGLshort23]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4Nsv(index, v) };
}

pub fn retrace_glVertexAttrib4Nub(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLubyte;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLubyte;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLubyte;
    z = (call.arg(3)).to_u32().unwrap();

    let mut w: GLubyte;
    w = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexAttrib4Nub(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4Nubv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte10_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte10_0) = _a_GLubyte10_0 {
        for _jGLubyte10 in 0.._a_GLubyte10_0.values.len() {
    v[_jGLubyte10] = (*_a_GLubyte10_0.values[_jGLubyte10]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4Nubv(index, v) };
}

pub fn retrace_glVertexAttrib4Nuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint97_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint97_0) = _a_GLuint97_0 {
        for _jGLuint97 in 0.._a_GLuint97_0.values.len() {
    v[_jGLuint97] = (*_a_GLuint97_0.values[_jGLuint97]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4Nuiv(index, v) };
}

pub fn retrace_glVertexAttrib4Nusv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLushort];
    v = _allocator.alloc_array::<GLushort>(&call.arg(1));
    let _a_GLushort7_0 = (call.arg(1)).to_array();
    if let Some(_a_GLushort7_0) = _a_GLushort7_0 {
        for _jGLushort7 in 0.._a_GLushort7_0.values.len() {
    v[_jGLushort7] = (*_a_GLushort7_0.values[_jGLushort7]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4Nusv(index, v) };
}

pub fn retrace_glVertexAttrib4bv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(1));
    let _a_GLbyte6_0 = (call.arg(1)).to_array();
    if let Some(_a_GLbyte6_0) = _a_GLbyte6_0 {
        for _jGLbyte6 in 0.._a_GLbyte6_0.values.len() {
    v[_jGLbyte6] = (*_a_GLbyte6_0.values[_jGLbyte6]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4bv(index, v) };
}

pub fn retrace_glVertexAttrib4d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::VertexAttrib4d(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble56_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble56_0) = _a_GLdouble56_0 {
        for _jGLdouble56 in 0.._a_GLdouble56_0.values.len() {
    v[_jGLdouble56] = (*_a_GLdouble56_0.values[_jGLdouble56]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4dv(index, v) };
}

pub fn retrace_glVertexAttrib4f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::VertexAttrib4f(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat135_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat135_0) = _a_GLfloat135_0 {
        for _jGLfloat135 in 0.._a_GLfloat135_0.values.len() {
    v[_jGLfloat135] = (*_a_GLfloat135_0.values[_jGLfloat135]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4fv(index, v) };
}

pub fn retrace_glVertexAttrib4iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint168_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint168_0) = _a_GLint168_0 {
        for _jGLint168 in 0.._a_GLint168_0.values.len() {
    v[_jGLint168] = (*_a_GLint168_0.values[_jGLint168]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4iv(index, v) };
}

pub fn retrace_glVertexAttrib4s(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(3)).to_i32().unwrap();

    let mut w: GLshort;
    w = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexAttrib4s(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort24_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort24_0) = _a_GLshort24_0 {
        for _jGLshort24 in 0.._a_GLshort24_0.values.len() {
    v[_jGLshort24] = (*_a_GLshort24_0.values[_jGLshort24]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4sv(index, v) };
}

pub fn retrace_glVertexAttrib4ubv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte11_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte11_0) = _a_GLubyte11_0 {
        for _jGLubyte11 in 0.._a_GLubyte11_0.values.len() {
    v[_jGLubyte11] = (*_a_GLubyte11_0.values[_jGLubyte11]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4ubv(index, v) };
}

pub fn retrace_glVertexAttrib4uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint98_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint98_0) = _a_GLuint98_0 {
        for _jGLuint98 in 0.._a_GLuint98_0.values.len() {
    v[_jGLuint98] = (*_a_GLuint98_0.values[_jGLuint98]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4uiv(index, v) };
}

pub fn retrace_glVertexAttrib4usv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLushort];
    v = _allocator.alloc_array::<GLushort>(&call.arg(1));
    let _a_GLushort8_0 = (call.arg(1)).to_array();
    if let Some(_a_GLushort8_0) = _a_GLushort8_0 {
        for _jGLushort8 in 0.._a_GLushort8_0.values.len() {
    v[_jGLushort8] = (*_a_GLushort8_0.values[_jGLushort8]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4usv(index, v) };
}

pub fn retrace_glVertexAttribPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(3)).to_u32().unwrap() as u8;

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(5), true));

    unsafe { gl::VertexAttribPointer(index, size, _type, normalized, stride, pointer) };
}

pub fn retrace_glUniformMatrix2x3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat136_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat136_0) = _a_GLfloat136_0 {
        for _jGLfloat136 in 0.._a_GLfloat136_0.values.len() {
    value[_jGLfloat136] = (*_a_GLfloat136_0.values[_jGLfloat136]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix2x3fv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix3x2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat137_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat137_0) = _a_GLfloat137_0 {
        for _jGLfloat137 in 0.._a_GLfloat137_0.values.len() {
    value[_jGLfloat137] = (*_a_GLfloat137_0.values[_jGLfloat137]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix3x2fv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix2x4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat138_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat138_0) = _a_GLfloat138_0 {
        for _jGLfloat138 in 0.._a_GLfloat138_0.values.len() {
    value[_jGLfloat138] = (*_a_GLfloat138_0.values[_jGLfloat138]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix2x4fv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix4x2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat139_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat139_0) = _a_GLfloat139_0 {
        for _jGLfloat139 in 0.._a_GLfloat139_0.values.len() {
    value[_jGLfloat139] = (*_a_GLfloat139_0.values[_jGLfloat139]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix4x2fv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix3x4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat140_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat140_0) = _a_GLfloat140_0 {
        for _jGLfloat140 in 0.._a_GLfloat140_0.values.len() {
    value[_jGLfloat140] = (*_a_GLfloat140_0.values[_jGLfloat140]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix3x4fv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix4x3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat141_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat141_0) = _a_GLfloat141_0 {
        for _jGLfloat141 in 0.._a_GLfloat141_0.values.len() {
    value[_jGLfloat141] = (*_a_GLfloat141_0.values[_jGLfloat141]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix4x3fv(location, count, transpose, value) };
}

pub fn retrace_glColorMaski(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut r: GLboolean;
    r = (call.arg(1)).to_u32().unwrap() as u8;

    let mut g: GLboolean;
    g = (call.arg(2)).to_u32().unwrap() as u8;

    let mut b: GLboolean;
    b = (call.arg(3)).to_u32().unwrap() as u8;

    let mut a: GLboolean;
    a = (call.arg(4)).to_u32().unwrap() as u8;

    unsafe { gl::ColorMaski(index, r, g, b, a) };
}

pub fn retrace_glEnablei(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::Enablei(target, index) };
}

pub fn retrace_glDisablei(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::Disablei(target, index) };
}

pub fn retrace_glBeginTransformFeedback(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut primitiveMode: GLenum;
    primitiveMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BeginTransformFeedback(primitiveMode) };
}

pub fn retrace_glEndTransformFeedback(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::EndTransformFeedback() };
}

pub fn retrace_glBindBufferRange(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::BindBufferRange(target, index, buffer, offset, size) };
}

pub fn retrace_glBindBufferBase(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::BindBufferBase(target, index, buffer) };
}

pub fn retrace_glTransformFeedbackVaryings(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let varyings: &mut [GLchar];
    varyings = _allocator.alloc_array::<GLchar >(&call.arg(2));
    let _a_GLchar28_0 = (call.arg(2)).to_array();
    if let Some(_a_GLchar28_0) = _a_GLchar28_0 {
        for _jGLchar28 in 0.._a_GLchar28_0.values.len() {
    varyings[_jGLchar28] = (GLchar *)((*_a_GLchar28_0.values[_jGLchar28]).to_string().unwrap());
        }
    }
    let params = params.as_mut_ptr();

    let mut bufferMode: GLenum;
    bufferMode = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::TransformFeedbackVaryings(program, count, varyings, bufferMode) };
}

pub fn retrace_glClampColor(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut clamp: GLenum;
    clamp = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ClampColor(target, clamp) };
}

pub fn retrace_glBeginConditionalRender(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BeginConditionalRender(id, mode) };
}

pub fn retrace_glEndConditionalRender(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::EndConditionalRender() };
}

pub fn retrace_glVertexAttribIPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(4), true));

    unsafe { gl::VertexAttribIPointer(index, size, _type, stride, pointer) };
}

pub fn retrace_glVertexAttribI1i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::VertexAttribI1i(index, x) };
}

pub fn retrace_glVertexAttribI2i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::VertexAttribI2i(index, x, y) };
}

pub fn retrace_glVertexAttribI3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexAttribI3i(index, x, y, z) };
}

pub fn retrace_glVertexAttribI4i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(3)).to_i32().unwrap();

    let mut w: GLint;
    w = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexAttribI4i(index, x, y, z, w) };
}

pub fn retrace_glVertexAttribI1ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexAttribI1ui(index, x) };
}

pub fn retrace_glVertexAttribI2ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint;
    y = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::VertexAttribI2ui(index, x, y) };
}

pub fn retrace_glVertexAttribI3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLuint;
    z = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::VertexAttribI3ui(index, x, y, z) };
}

pub fn retrace_glVertexAttribI4ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLuint;
    z = (call.arg(3)).to_u32().unwrap();

    let mut w: GLuint;
    w = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexAttribI4ui(index, x, y, z, w) };
}

pub fn retrace_glVertexAttribI1iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_PGLint32_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLint32_0.values[0]).to_i32().unwrap();

    unsafe { gl::VertexAttribI1iv(index, v) };
}

pub fn retrace_glVertexAttribI2iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint169_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint169_0) = _a_GLint169_0 {
        for _jGLint169 in 0.._a_GLint169_0.values.len() {
    v[_jGLint169] = (*_a_GLint169_0.values[_jGLint169]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI2iv(index, v) };
}

pub fn retrace_glVertexAttribI3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint170_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint170_0) = _a_GLint170_0 {
        for _jGLint170 in 0.._a_GLint170_0.values.len() {
    v[_jGLint170] = (*_a_GLint170_0.values[_jGLint170]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI3iv(index, v) };
}

pub fn retrace_glVertexAttribI4iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint171_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint171_0) = _a_GLint171_0 {
        for _jGLint171 in 0.._a_GLint171_0.values.len() {
    v[_jGLint171] = (*_a_GLint171_0.values[_jGLint171]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4iv(index, v) };
}

pub fn retrace_glVertexAttribI1uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint41_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLuint41_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexAttribI1uiv(index, v) };
}

pub fn retrace_glVertexAttribI2uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint99_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint99_0) = _a_GLuint99_0 {
        for _jGLuint99 in 0.._a_GLuint99_0.values.len() {
    v[_jGLuint99] = (*_a_GLuint99_0.values[_jGLuint99]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI2uiv(index, v) };
}

pub fn retrace_glVertexAttribI3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint100_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint100_0) = _a_GLuint100_0 {
        for _jGLuint100 in 0.._a_GLuint100_0.values.len() {
    v[_jGLuint100] = (*_a_GLuint100_0.values[_jGLuint100]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI3uiv(index, v) };
}

pub fn retrace_glVertexAttribI4uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint101_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint101_0) = _a_GLuint101_0 {
        for _jGLuint101 in 0.._a_GLuint101_0.values.len() {
    v[_jGLuint101] = (*_a_GLuint101_0.values[_jGLuint101]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4uiv(index, v) };
}

pub fn retrace_glVertexAttribI4bv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(1));
    let _a_GLbyte7_0 = (call.arg(1)).to_array();
    if let Some(_a_GLbyte7_0) = _a_GLbyte7_0 {
        for _jGLbyte7 in 0.._a_GLbyte7_0.values.len() {
    v[_jGLbyte7] = (*_a_GLbyte7_0.values[_jGLbyte7]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4bv(index, v) };
}

pub fn retrace_glVertexAttribI4sv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort25_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort25_0) = _a_GLshort25_0 {
        for _jGLshort25 in 0.._a_GLshort25_0.values.len() {
    v[_jGLshort25] = (*_a_GLshort25_0.values[_jGLshort25]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4sv(index, v) };
}

pub fn retrace_glVertexAttribI4ubv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte12_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte12_0) = _a_GLubyte12_0 {
        for _jGLubyte12 in 0.._a_GLubyte12_0.values.len() {
    v[_jGLubyte12] = (*_a_GLubyte12_0.values[_jGLubyte12]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4ubv(index, v) };
}

pub fn retrace_glVertexAttribI4usv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLushort];
    v = _allocator.alloc_array::<GLushort>(&call.arg(1));
    let _a_GLushort9_0 = (call.arg(1)).to_array();
    if let Some(_a_GLushort9_0) = _a_GLushort9_0 {
        for _jGLushort9 in 0.._a_GLushort9_0.values.len() {
    v[_jGLushort9] = (*_a_GLushort9_0.values[_jGLushort9]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4usv(index, v) };
}

pub fn retrace_glBindFragDataLocation(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut color: GLuint;
    color = (call.arg(1)).to_u32().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(2)).to_string().unwrap());

    unsafe { gl::BindFragDataLocation(program, color, name) };
}

pub fn retrace_glUniform1ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::Uniform1ui(location, v0) };
}

pub fn retrace_glUniform2ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(1)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::Uniform2ui(location, v0, v1) };
}

pub fn retrace_glUniform3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(1)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(2)).to_u32().unwrap();

    let mut v2: GLuint;
    v2 = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::Uniform3ui(location, v0, v1, v2) };
}

pub fn retrace_glUniform4ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(1)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(2)).to_u32().unwrap();

    let mut v2: GLuint;
    v2 = (call.arg(3)).to_u32().unwrap();

    let mut v3: GLuint;
    v3 = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::Uniform4ui(location, v0, v1, v2, v3) };
}

pub fn retrace_glUniform1uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint102_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint102_0) = _a_GLuint102_0 {
        for _jGLuint102 in 0.._a_GLuint102_0.values.len() {
    value[_jGLuint102] = (*_a_GLuint102_0.values[_jGLuint102]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1uiv(location, count, value) };
}

pub fn retrace_glUniform2uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint103_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint103_0) = _a_GLuint103_0 {
        for _jGLuint103 in 0.._a_GLuint103_0.values.len() {
    value[_jGLuint103] = (*_a_GLuint103_0.values[_jGLuint103]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2uiv(location, count, value) };
}

pub fn retrace_glUniform3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint104_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint104_0) = _a_GLuint104_0 {
        for _jGLuint104 in 0.._a_GLuint104_0.values.len() {
    value[_jGLuint104] = (*_a_GLuint104_0.values[_jGLuint104]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3uiv(location, count, value) };
}

pub fn retrace_glUniform4uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint105_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint105_0) = _a_GLuint105_0 {
        for _jGLuint105 in 0.._a_GLuint105_0.values.len() {
    value[_jGLuint105] = (*_a_GLuint105_0.values[_jGLuint105]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4uiv(location, count, value) };
}

pub fn retrace_glTexParameterIiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint172_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint172_0) = _a_GLint172_0 {
        for _jGLint172 in 0.._a_GLint172_0.values.len() {
    params[_jGLint172] = (*_a_GLint172_0.values[_jGLint172]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexParameterIiv(target, pname, params) };
}

pub fn retrace_glTexParameterIuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint106_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint106_0) = _a_GLuint106_0 {
        for _jGLuint106 in 0.._a_GLuint106_0.values.len() {
    params[_jGLuint106] = (*_a_GLuint106_0.values[_jGLuint106]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexParameterIuiv(target, pname, params) };
}

pub fn retrace_glClearBufferiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLenum;
    buffer = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut drawbuffer: GLint;
    drawbuffer = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint173_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint173_0) = _a_GLint173_0 {
        for _jGLint173 in 0.._a_GLint173_0.values.len() {
    value[_jGLint173] = (*_a_GLint173_0.values[_jGLint173]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClearBufferiv(buffer, drawbuffer, value) };
}

pub fn retrace_glClearBufferuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLenum;
    buffer = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut drawbuffer: GLint;
    drawbuffer = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint107_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint107_0) = _a_GLuint107_0 {
        for _jGLuint107 in 0.._a_GLuint107_0.values.len() {
    value[_jGLuint107] = (*_a_GLuint107_0.values[_jGLuint107]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClearBufferuiv(buffer, drawbuffer, value) };
}

pub fn retrace_glClearBufferfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLenum;
    buffer = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut drawbuffer: GLint;
    drawbuffer = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat142_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat142_0) = _a_GLfloat142_0 {
        for _jGLfloat142 in 0.._a_GLfloat142_0.values.len() {
    value[_jGLfloat142] = (*_a_GLfloat142_0.values[_jGLfloat142]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClearBufferfv(buffer, drawbuffer, value) };
}

pub fn retrace_glClearBufferfi(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLenum;
    buffer = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut drawbuffer: GLint;
    drawbuffer = (call.arg(1)).to_i32().unwrap();

    let mut depth: GLfloat;
    depth = (call.arg(2)).to_f32().unwrap();

    let mut stencil: GLint;
    stencil = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::ClearBufferfi(buffer, drawbuffer, depth, stencil) };
}

pub fn retrace_glDrawArraysInstanced(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLint;
    first = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut instancecount: GLsizei;
    instancecount = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::DrawArraysInstanced(mode, first, count, instancecount) };
}

pub fn retrace_glDrawElementsInstanced(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut instancecount: GLsizei;
    instancecount = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::DrawElementsInstanced(mode, count, _type, indices, instancecount) };
}

pub fn retrace_glTexBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::TexBuffer(target, internalformat, buffer) };
}

pub fn retrace_glPrimitiveRestartIndex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::PrimitiveRestartIndex(index) };
}

pub fn retrace_glFramebufferTexture(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::FramebufferTexture(target, attachment, texture, level) };
}

pub fn retrace_glVertexAttribDivisor(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut divisor: GLuint;
    divisor = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexAttribDivisor(index, divisor) };
}

pub fn retrace_glMinSampleShading(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut value: GLfloat;
    value = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::MinSampleShading(value) };
}

pub fn retrace_glBlendEquationi(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationi(buf, mode) };
}

pub fn retrace_glBlendEquationSeparatei(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut modeRGB: GLenum;
    modeRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut modeAlpha: GLenum;
    modeAlpha = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationSeparatei(buf, modeRGB, modeAlpha) };
}

pub fn retrace_glBlendFunci(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut src: GLenum;
    src = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dst: GLenum;
    dst = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFunci(buf, src, dst) };
}

pub fn retrace_glBlendFuncSeparatei(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut srcRGB: GLenum;
    srcRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dstRGB: GLenum;
    dstRGB = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut srcAlpha: GLenum;
    srcAlpha = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut dstAlpha: GLenum;
    dstAlpha = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha) };
}

pub fn retrace_glGetnCompressedTexImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut lod: GLint;
    lod = (call.arg(1)).to_i32().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(2)).to_i32().unwrap();

    pixels = (call.arg(3)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnCompressedTexImage(target, lod, bufSize, pixels) };
}

pub fn retrace_glGetnTexImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(4)).to_i32().unwrap();

    pixels = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnTexImage(target, level, format, _type, bufSize, pixels) };
}

pub fn retrace_glGetnPixelMapfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(1)).to_i32().unwrap();

    let values: &mut [GLfloat];
    values = (call.arg(2)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnPixelMapfv(map, bufSize, values) };
    let _aGLfloat144 = (call.arg(2)).to_array();
    if (_aGLfloat144) {
        for _jGLfloat144 in 0..length {
        }
    }
}

pub fn retrace_glGetnPixelMapuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(1)).to_i32().unwrap();

    let values: &mut [GLuint];
    values = (call.arg(2)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnPixelMapuiv(map, bufSize, values) };
    let _aGLuint109 = (call.arg(2)).to_array();
    if (_aGLuint109) {
        for _jGLuint109 in 0..length {
        }
    }
}

pub fn retrace_glGetnPixelMapusv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(1)).to_i32().unwrap();

    let values: &mut [GLushort];
    values = (call.arg(2)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnPixelMapusv(map, bufSize, values) };
    let _aGLushort11 = (call.arg(2)).to_array();
    if (_aGLushort11) {
        for _jGLushort11 in 0..length {
        }
    }
}

pub fn retrace_glGetnPolygonStipple(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut bufSize: GLsizei;
    bufSize = (call.arg(0)).to_i32().unwrap();

    let pattern: &mut [GLubyte];
    pattern = (call.arg(1)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnPolygonStipple(bufSize, pattern) };
    let _aGLubyte14 = (call.arg(1)).to_array();
    if (_aGLubyte14) {
        for _jGLubyte14 in 0..length {
        }
    }
}

pub fn retrace_glGetnConvolutionFilter(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(3)).to_i32().unwrap();

    let image: &mut [void];
    image = (call.arg(4)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnConvolutionFilter(target, format, _type, bufSize, image) };
}

pub fn retrace_glGetnSeparableFilter(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut rowBufSize: GLsizei;
    rowBufSize = (call.arg(3)).to_i32().unwrap();

    let row: &mut [void];
    row = (call.arg(4)).to_pointer();

    let mut columnBufSize: GLsizei;
    columnBufSize = (call.arg(5)).to_i32().unwrap();

    let column: &mut [void];
    column = (call.arg(6)).to_pointer();

    let span: &mut [GLvoid];
    span = (call.arg(7)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnSeparableFilter(target, format, _type, rowBufSize, row, columnBufSize, column, span) };
}

pub fn retrace_glGetnHistogram(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut reset: GLboolean;
    reset = (call.arg(1)).to_u32().unwrap() as u8;

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(4)).to_i32().unwrap();

    let values: &mut [void];
    values = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnHistogram(target, reset, format, _type, bufSize, values) };
}

pub fn retrace_glGetnMinmax(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut reset: GLboolean;
    reset = (call.arg(1)).to_u32().unwrap() as u8;

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(4)).to_i32().unwrap();

    let values: &mut [void];
    values = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnMinmax(target, reset, format, _type, bufSize, values) };
}

pub fn retrace_glSpecializeShader(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut shader: GLuint;
    shader = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    let pEntryPoint: &mut [GLchar];
    pEntryPoint = (GLchar *)((call.arg(1)).to_string().unwrap());

    let mut numSpecializationConstants: GLuint;
    numSpecializationConstants = (call.arg(2)).to_u32().unwrap();

    let pConstantIndex: &mut [GLuint];
    pConstantIndex = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint110_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint110_0) = _a_GLuint110_0 {
        for _jGLuint110 in 0.._a_GLuint110_0.values.len() {
    pConstantIndex[_jGLuint110] = (*_a_GLuint110_0.values[_jGLuint110]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let pConstantValue: &mut [GLuint];
    pConstantValue = _allocator.alloc_array::<GLuint>(&call.arg(4));
    let _a_GLuint111_0 = (call.arg(4)).to_array();
    if let Some(_a_GLuint111_0) = _a_GLuint111_0 {
        for _jGLuint111 in 0.._a_GLuint111_0.values.len() {
    pConstantValue[_jGLuint111] = (*_a_GLuint111_0.values[_jGLuint111]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue) };
}

pub fn retrace_glMultiDrawArraysIndirectCount(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    let indirect = (call.arg(1)).to_pointer().unwrap() as *mut c_void;

    let mut drawcount: GLintptr;
    drawcount = (call.arg(2)).to_i32().unwrap();

    let mut maxdrawcount: GLsizei;
    maxdrawcount = (call.arg(3)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiDrawArraysIndirectCount(mode, indirect, drawcount, maxdrawcount, stride) };
}

pub fn retrace_glMultiDrawElementsIndirectCount(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    let indirect = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut drawcount: GLintptr;
    drawcount = (call.arg(3)).to_i32().unwrap();

    let mut maxdrawcount: GLsizei;
    maxdrawcount = (call.arg(4)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::MultiDrawElementsIndirectCount(mode, _type, indirect, drawcount, maxdrawcount, stride) };
}

pub fn retrace_glClipPlanef(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut plane: GLenum;
    plane = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let equation: &mut [GLfloat];
    equation = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat145_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat145_0) = _a_GLfloat145_0 {
        for _jGLfloat145 in 0.._a_GLfloat145_0.values.len() {
    equation[_jGLfloat145] = (*_a_GLfloat145_0.values[_jGLfloat145]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClipPlanef(plane, equation) };
}

pub fn retrace_glFrustumf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut left: GLfloat;
    left = (call.arg(0)).to_f32().unwrap();

    let mut right: GLfloat;
    right = (call.arg(1)).to_f32().unwrap();

    let mut bottom: GLfloat;
    bottom = (call.arg(2)).to_f32().unwrap();

    let mut top: GLfloat;
    top = (call.arg(3)).to_f32().unwrap();

    let mut zNear: GLfloat;
    zNear = (call.arg(4)).to_f32().unwrap();

    let mut zFar: GLfloat;
    zFar = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::Frustumf(left, right, bottom, top, zNear, zFar) };
}

pub fn retrace_glOrthof(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut left: GLfloat;
    left = (call.arg(0)).to_f32().unwrap();

    let mut right: GLfloat;
    right = (call.arg(1)).to_f32().unwrap();

    let mut bottom: GLfloat;
    bottom = (call.arg(2)).to_f32().unwrap();

    let mut top: GLfloat;
    top = (call.arg(3)).to_f32().unwrap();

    let mut zNear: GLfloat;
    zNear = (call.arg(4)).to_f32().unwrap();

    let mut zFar: GLfloat;
    zFar = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::Orthof(left, right, bottom, top, zNear, zFar) };
}

pub fn retrace_glAlphaFuncx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut func: GLenum;
    func = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _ref: GLclampx;
    _ref = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::AlphaFuncx(func, _ref) };
}

pub fn retrace_glClearColorx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLclampx;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLclampx;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLclampx;
    blue = (call.arg(2)).to_i32().unwrap();

    let mut alpha: GLclampx;
    alpha = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::ClearColorx(red, green, blue, alpha) };
}

pub fn retrace_glClearDepthx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut depth: GLclampx;
    depth = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::ClearDepthx(depth) };
}

pub fn retrace_glClipPlanex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut plane: GLenum;
    plane = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let equation: &mut [GLfixed];
    equation = _allocator.alloc_array::<GLfixed>(&call.arg(1));
    let _a_GLfixed9_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfixed9_0) = _a_GLfixed9_0 {
        for _jGLfixed9 in 0.._a_GLfixed9_0.values.len() {
    equation[_jGLfixed9] = (*_a_GLfixed9_0.values[_jGLfixed9]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClipPlanex(plane, equation) };
}

pub fn retrace_glColor4x(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLfixed;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLfixed;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLfixed;
    blue = (call.arg(2)).to_i32().unwrap();

    let mut alpha: GLfixed;
    alpha = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Color4x(red, green, blue, alpha) };
}

pub fn retrace_glDepthRangex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut zNear: GLclampx;
    zNear = (call.arg(0)).to_i32().unwrap();

    let mut zFar: GLclampx;
    zFar = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::DepthRangex(zNear, zFar) };
}

pub fn retrace_glFogx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfixed;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::Fogx(pname, param) };
}

pub fn retrace_glFogxv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfixed];
    params = _allocator.alloc_array::<GLfixed>(&call.arg(1));
    let _a_GLfixed10_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfixed10_0) = _a_GLfixed10_0 {
        for _jGLfixed10 in 0.._a_GLfixed10_0.values.len() {
    params[_jGLfixed10] = (*_a_GLfixed10_0.values[_jGLfixed10]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Fogxv(pname, params) };
}

pub fn retrace_glFrustumx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut left: GLfixed;
    left = (call.arg(0)).to_i32().unwrap();

    let mut right: GLfixed;
    right = (call.arg(1)).to_i32().unwrap();

    let mut bottom: GLfixed;
    bottom = (call.arg(2)).to_i32().unwrap();

    let mut top: GLfixed;
    top = (call.arg(3)).to_i32().unwrap();

    let mut zNear: GLfixed;
    zNear = (call.arg(4)).to_i32().unwrap();

    let mut zFar: GLfixed;
    zFar = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::Frustumx(left, right, bottom, top, zNear, zFar) };
}

pub fn retrace_glLightModelx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfixed;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::LightModelx(pname, param) };
}

pub fn retrace_glLightModelxv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfixed];
    params = _allocator.alloc_array::<GLfixed>(&call.arg(1));
    let _a_GLfixed11_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfixed11_0) = _a_GLfixed11_0 {
        for _jGLfixed11 in 0.._a_GLfixed11_0.values.len() {
    params[_jGLfixed11] = (*_a_GLfixed11_0.values[_jGLfixed11]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::LightModelxv(pname, params) };
}

pub fn retrace_glLightx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfixed;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Lightx(light, pname, param) };
}

pub fn retrace_glLightxv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfixed];
    params = _allocator.alloc_array::<GLfixed>(&call.arg(2));
    let _a_GLfixed12_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfixed12_0) = _a_GLfixed12_0 {
        for _jGLfixed12 in 0.._a_GLfixed12_0.values.len() {
    params[_jGLfixed12] = (*_a_GLfixed12_0.values[_jGLfixed12]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Lightxv(light, pname, params) };
}

pub fn retrace_glLineWidthx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut width: GLfixed;
    width = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::LineWidthx(width) };
}

pub fn retrace_glLoadMatrixx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLfixed];
    m = _allocator.alloc_array::<GLfixed>(&call.arg(0));
    let _a_GLfixed13_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfixed13_0) = _a_GLfixed13_0 {
        for _jGLfixed13 in 0.._a_GLfixed13_0.values.len() {
    m[_jGLfixed13] = (*_a_GLfixed13_0.values[_jGLfixed13]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::LoadMatrixx(m) };
}

pub fn retrace_glMaterialx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfixed;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Materialx(face, pname, param) };
}

pub fn retrace_glMaterialxv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfixed];
    params = _allocator.alloc_array::<GLfixed>(&call.arg(2));
    let _a_GLfixed14_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfixed14_0) = _a_GLfixed14_0 {
        for _jGLfixed14 in 0.._a_GLfixed14_0.values.len() {
    params[_jGLfixed14] = (*_a_GLfixed14_0.values[_jGLfixed14]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Materialxv(face, pname, params) };
}

pub fn retrace_glMultMatrixx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLfixed];
    m = _allocator.alloc_array::<GLfixed>(&call.arg(0));
    let _a_GLfixed15_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfixed15_0) = _a_GLfixed15_0 {
        for _jGLfixed15 in 0.._a_GLfixed15_0.values.len() {
    m[_jGLfixed15] = (*_a_GLfixed15_0.values[_jGLfixed15]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultMatrixx(m) };
}

pub fn retrace_glMultiTexCoord4x(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLfixed;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLfixed;
    t = (call.arg(2)).to_i32().unwrap();

    let mut r: GLfixed;
    r = (call.arg(3)).to_i32().unwrap();

    let mut q: GLfixed;
    q = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord4x(target, s, t, r, q) };
}

pub fn retrace_glNormal3x(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut nx: GLfixed;
    nx = (call.arg(0)).to_i32().unwrap();

    let mut ny: GLfixed;
    ny = (call.arg(1)).to_i32().unwrap();

    let mut nz: GLfixed;
    nz = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Normal3x(nx, ny, nz) };
}

pub fn retrace_glOrthox(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut left: GLfixed;
    left = (call.arg(0)).to_i32().unwrap();

    let mut right: GLfixed;
    right = (call.arg(1)).to_i32().unwrap();

    let mut bottom: GLfixed;
    bottom = (call.arg(2)).to_i32().unwrap();

    let mut top: GLfixed;
    top = (call.arg(3)).to_i32().unwrap();

    let mut zNear: GLfixed;
    zNear = (call.arg(4)).to_i32().unwrap();

    let mut zFar: GLfixed;
    zFar = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::Orthox(left, right, bottom, top, zNear, zFar) };
}

pub fn retrace_glPointParameterx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfixed;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PointParameterx(pname, param) };
}

pub fn retrace_glPointParameterxv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfixed];
    params = _allocator.alloc_array::<GLfixed>(&call.arg(1));
    let _a_GLfixed16_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfixed16_0) = _a_GLfixed16_0 {
        for _jGLfixed16 in 0.._a_GLfixed16_0.values.len() {
    params[_jGLfixed16] = (*_a_GLfixed16_0.values[_jGLfixed16]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PointParameterxv(pname, params) };
}

pub fn retrace_glPointSizex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLfixed;
    size = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::PointSizex(size) };
}

pub fn retrace_glPolygonOffsetx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLfixed;
    factor = (call.arg(0)).to_i32().unwrap();

    let mut units: GLfixed;
    units = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PolygonOffsetx(factor, units) };
}

pub fn retrace_glRotatex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut angle: GLfixed;
    angle = (call.arg(0)).to_i32().unwrap();

    let mut x: GLfixed;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLfixed;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLfixed;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Rotatex(angle, x, y, z) };
}

pub fn retrace_glSampleCoveragex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut value: GLclampx;
    value = (call.arg(0)).to_i32().unwrap();

    let mut invert: GLboolean;
    invert = (call.arg(1)).to_u32().unwrap() as u8;

    unsafe { gl::SampleCoveragex(value, invert) };
}

pub fn retrace_glScalex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfixed;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLfixed;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLfixed;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Scalex(x, y, z) };
}

pub fn retrace_glTexEnvx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfixed;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TexEnvx(target, pname, param) };
}

pub fn retrace_glTexEnvxv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfixed];
    params = _allocator.alloc_array::<GLfixed>(&call.arg(2));
    let _a_GLfixed17_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfixed17_0) = _a_GLfixed17_0 {
        for _jGLfixed17 in 0.._a_GLfixed17_0.values.len() {
    params[_jGLfixed17] = (*_a_GLfixed17_0.values[_jGLfixed17]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexEnvxv(target, pname, params) };
}

pub fn retrace_glTexParameterx(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfixed;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TexParameterx(target, pname, param) };
}

pub fn retrace_glTexParameterxv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfixed];
    params = _allocator.alloc_array::<GLfixed>(&call.arg(2));
    let _a_GLfixed18_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfixed18_0) = _a_GLfixed18_0 {
        for _jGLfixed18 in 0.._a_GLfixed18_0.values.len() {
    params[_jGLfixed18] = (*_a_GLfixed18_0.values[_jGLfixed18]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexParameterxv(target, pname, params) };
}

pub fn retrace_glTranslatex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfixed;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLfixed;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLfixed;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Translatex(x, y, z) };
}

pub fn retrace_glBlendBarrier(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::BlendBarrier() };
}

pub fn retrace_glPrimitiveBoundingBox(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut minX: GLfloat;
    minX = (call.arg(0)).to_f32().unwrap();

    let mut minY: GLfloat;
    minY = (call.arg(1)).to_f32().unwrap();

    let mut minZ: GLfloat;
    minZ = (call.arg(2)).to_f32().unwrap();

    let mut minW: GLfloat;
    minW = (call.arg(3)).to_f32().unwrap();

    let mut maxX: GLfloat;
    maxX = (call.arg(4)).to_f32().unwrap();

    let mut maxY: GLfloat;
    maxY = (call.arg(5)).to_f32().unwrap();

    let mut maxZ: GLfloat;
    maxZ = (call.arg(6)).to_f32().unwrap();

    let mut maxW: GLfloat;
    maxW = (call.arg(7)).to_f32().unwrap();

    unsafe { gl::PrimitiveBoundingBox(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW) };
}

pub fn retrace_glTbufferMask3DFX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLuint;
    mask = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::TbufferMask3DFX(mask) };
}

pub fn retrace_glDebugMessageEnableAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut category: GLenum;
    category = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut severity: GLenum;
    severity = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint112_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint112_0) = _a_GLuint112_0 {
        for _jGLuint112 in 0.._a_GLuint112_0.values.len() {
    ids[_jGLuint112] = (*_a_GLuint112_0.values[_jGLuint112]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut enabled: GLboolean;
    enabled = (call.arg(4)).to_u32().unwrap() as u8;

    unsafe { gl::DebugMessageEnableAMD(category, severity, count, ids, enabled) };
}

pub fn retrace_glDebugMessageInsertAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut category: GLenum;
    category = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut severity: GLenum;
    severity = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(2)).to_u32().unwrap();

    let mut length: GLsizei;
    length = (call.arg(3)).to_i32().unwrap();

    let buf: &mut [GLchar];
    buf = (GLchar *)((call.arg(4)).to_string().unwrap());

    unsafe { gl::DebugMessageInsertAMD(category, severity, id, length, buf) };
}

pub fn retrace_glBlendFuncIndexedAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut src: GLenum;
    src = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dst: GLenum;
    dst = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFuncIndexedAMD(buf, src, dst) };
}

pub fn retrace_glBlendFuncSeparateIndexedAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut srcRGB: GLenum;
    srcRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dstRGB: GLenum;
    dstRGB = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut srcAlpha: GLenum;
    srcAlpha = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut dstAlpha: GLenum;
    dstAlpha = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha) };
}

pub fn retrace_glBlendEquationIndexedAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationIndexedAMD(buf, mode) };
}

pub fn retrace_glBlendEquationSeparateIndexedAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut modeRGB: GLenum;
    modeRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut modeAlpha: GLenum;
    modeAlpha = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha) };
}

pub fn retrace_glVertexAttribParameteriAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::VertexAttribParameteriAMD(index, pname, param) };
}

pub fn retrace_glMultiDrawArraysIndirectAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    indirect = static_cast<GLvoid *>(retrace::toPointer(call.arg(1)));

    let mut drawcount: GLsizei;
    drawcount = (call.arg(2)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiDrawArraysIndirectAMD(mode, indirect, drawcount, stride) };
}

pub fn retrace_glMultiDrawElementsIndirectAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    indirect = static_cast<GLvoid *>(retrace::toPointer(call.arg(2)));

    let mut drawcount: GLsizei;
    drawcount = (call.arg(3)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiDrawElementsIndirectAMD(mode, _type, indirect, drawcount, stride) };
}

pub fn retrace_glGenNamesAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut identifier: GLenum;
    identifier = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut num: GLuint;
    num = (call.arg(1)).to_u32().unwrap();

    let names: &mut [GLuint];
    names = _allocator.alloc_array::<GLuint>(&call.arg(2));

    unsafe { gl::GenNamesAMD(identifier, num, names) };
    let _aGLuint114 = (call.arg(2)).to_array();
    if (_aGLuint114) {
        for _jGLuint114 in 0..length {
        }
    }
}

pub fn retrace_glDeleteNamesAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut identifier: GLenum;
    identifier = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut num: GLuint;
    num = (call.arg(1)).to_u32().unwrap();

    let names: &mut [GLuint];
    names = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint115_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint115_0) = _a_GLuint115_0 {
        for _jGLuint115 in 0.._a_GLuint115_0.values.len() {
    names[_jGLuint115] = (*_a_GLuint115_0.values[_jGLuint115]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteNamesAMD(identifier, num, names) };
}

pub fn retrace_glQueryObjectParameteruiAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLuint;
    param = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::QueryObjectParameteruiAMD(target, id, pname, param) };
}

pub fn retrace_glGenPerfMonitorsAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let monitors: &mut [GLuint];
    monitors = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenPerfMonitorsAMD(n, monitors) };
    let _aGLuint117 = (call.arg(1)).to_array();
    if (_aGLuint117) {
        for _jGLuint117 in 0..length {
        }
    }
}

pub fn retrace_glDeletePerfMonitorsAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let monitors: &mut [GLuint];
    monitors = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint118_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint118_0) = _a_GLuint118_0 {
        for _jGLuint118 in 0.._a_GLuint118_0.values.len() {
    monitors[_jGLuint118] = (*_a_GLuint118_0.values[_jGLuint118]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeletePerfMonitorsAMD(n, monitors) };
}

pub fn retrace_glSelectPerfMonitorCountersAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut monitor: GLuint;
    monitor = (call.arg(0)).to_u32().unwrap();

    let mut enable: GLboolean;
    enable = (call.arg(1)).to_u32().unwrap() as u8;

    let mut group: GLuint;
    group = (call.arg(2)).to_u32().unwrap();

    let mut numCounters: GLint;
    numCounters = (call.arg(3)).to_i32().unwrap();

    let counterList: &mut [GLuint];
    counterList = _allocator.alloc_array::<GLuint>(&call.arg(4));
    let _a_GLuint119_0 = (call.arg(4)).to_array();
    if let Some(_a_GLuint119_0) = _a_GLuint119_0 {
        for _jGLuint119 in 0.._a_GLuint119_0.values.len() {
    counterList[_jGLuint119] = (*_a_GLuint119_0.values[_jGLuint119]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList) };
}

pub fn retrace_glBeginPerfMonitorAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut monitor: GLuint;
    monitor = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::BeginPerfMonitorAMD(monitor) };
}

pub fn retrace_glEndPerfMonitorAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut monitor: GLuint;
    monitor = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::EndPerfMonitorAMD(monitor) };
}

pub fn retrace_glSetMultisamplefvAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let val: &mut [GLfloat];
    val = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat146_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat146_0) = _a_GLfloat146_0 {
        for _jGLfloat146 in 0.._a_GLfloat146_0.values.len() {
    val[_jGLfloat146] = (*_a_GLfloat146_0.values[_jGLfloat146]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SetMultisamplefvAMD(pname, index, val) };
}

pub fn retrace_glTexStorageSparseAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalFormat: GLenum;
    internalFormat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(4)).to_i32().unwrap();

    let mut layers: GLsizei;
    layers = (call.arg(5)).to_i32().unwrap();

    let mut flags: GLbitfield;
    flags = (call.arg(6)).to_u32().unwrap();

    unsafe { gl::TexStorageSparseAMD(target, internalFormat, width, height, depth, layers, flags) };
}

pub fn retrace_glTextureStorageSparseAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut internalFormat: GLenum;
    internalFormat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut layers: GLsizei;
    layers = (call.arg(6)).to_i32().unwrap();

    let mut flags: GLbitfield;
    flags = (call.arg(7)).to_u32().unwrap();

    unsafe { gl::TextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, flags) };
}

pub fn retrace_glStencilOpValueAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLuint;
    value = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::StencilOpValueAMD(face, value) };
}

pub fn retrace_glTessellationFactorAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLfloat;
    factor = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::TessellationFactorAMD(factor) };
}

pub fn retrace_glTessellationModeAMD(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::TessellationModeAMD(mode) };
}

pub fn retrace_glBlitFramebufferANGLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut srcX0: GLint;
    srcX0 = (call.arg(0)).to_i32().unwrap();

    let mut srcY0: GLint;
    srcY0 = (call.arg(1)).to_i32().unwrap();

    let mut srcX1: GLint;
    srcX1 = (call.arg(2)).to_i32().unwrap();

    let mut srcY1: GLint;
    srcY1 = (call.arg(3)).to_i32().unwrap();

    let mut dstX0: GLint;
    dstX0 = (call.arg(4)).to_i32().unwrap();

    let mut dstY0: GLint;
    dstY0 = (call.arg(5)).to_i32().unwrap();

    let mut dstX1: GLint;
    dstX1 = (call.arg(6)).to_i32().unwrap();

    let mut dstY1: GLint;
    dstY1 = (call.arg(7)).to_i32().unwrap();

    let mut mask: GLbitfield;
    mask = (call.arg(8)).to_u32().unwrap();

    let mut filter: GLenum;
    filter = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter) };
}

pub fn retrace_glRenderbufferStorageMultisampleANGLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::RenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height) };
}

pub fn retrace_glDrawArraysInstancedANGLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLint;
    first = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut instancecount: GLsizei;
    instancecount = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::DrawArraysInstancedANGLE(mode, first, count, instancecount) };
}

pub fn retrace_glDrawElementsInstancedANGLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut instancecount: GLsizei;
    instancecount = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::DrawElementsInstancedANGLE(mode, count, _type, indices, instancecount) };
}

pub fn retrace_glVertexAttribDivisorANGLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut divisor: GLuint;
    divisor = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexAttribDivisorANGLE(index, divisor) };
}

pub fn retrace_glGenQueriesANGLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenQueriesANGLE(n, ids) };
    let _aGLuint121 = (call.arg(1)).to_array();
    if (_aGLuint121) {
        for _jGLuint121 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint121.values[_jGLuint121]).to_u32().unwrap();
    _query_map[_origResult] = ids[_jGLuint121];
        }
    }
}

pub fn retrace_glDeleteQueriesANGLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint122_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint122_0) = _a_GLuint122_0 {
        for _jGLuint122 in 0.._a_GLuint122_0.values.len() {
    ids[_jGLuint122] = (*_a_GLuint122_0.values[_jGLuint122]).to_u32().unwrap();
    ids[_jGLuint122] = _query_map[ids[_jGLuint122]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteQueriesANGLE(n, ids) };
}

pub fn retrace_glBeginQueryANGLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _query_map[id];

    unsafe { gl::BeginQueryANGLE(target, id) };
}

pub fn retrace_glEndQueryANGLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::EndQueryANGLE(target) };
}

pub fn retrace_glQueryCounterANGLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::QueryCounterANGLE(id, target) };
}

pub fn retrace_glGetQueryObjectivANGLE(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    GLint retval;
    if (_query_buffer)
        params = static_cast<GLint *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectivANGLE(id, pname, params) };
    let _aGLint175 = (call.arg(2)).to_array();
    if (_aGLint175) {
        for _jGLint175 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glGetQueryObjectuivANGLE(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint];
    GLuint retval;
    if (_query_buffer)
        params = static_cast<GLuint *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectuivANGLE(id, pname, params) };
    let _aGLuint124 = (call.arg(2)).to_array();
    if (_aGLuint124) {
        for _jGLuint124 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glGetQueryObjecti64vANGLE(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint64];
    GLint64 retval;
    if (_query_buffer)
        params = static_cast<GLint64 *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjecti64vANGLE(id, pname, params) };
    let _aGLint6413 = (call.arg(2)).to_array();
    if (_aGLint6413) {
        for _jGLint6413 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glGetQueryObjectui64vANGLE(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint64];
    GLuint64 retval;
    if (_query_buffer)
        params = static_cast<GLuint64 *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectui64vANGLE(id, pname, params) };
    let _aGLuint648 = (call.arg(2)).to_array();
    if (_aGLuint648) {
        for _jGLuint648 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glCopyTextureLevelsAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut destinationTexture: GLuint;
    destinationTexture = (call.arg(0)).to_u32().unwrap();
    destinationTexture = _texture_map[destinationTexture];

    let mut sourceTexture: GLuint;
    sourceTexture = (call.arg(1)).to_u32().unwrap();
    sourceTexture = _texture_map[sourceTexture];

    let mut sourceBaseLevel: GLint;
    sourceBaseLevel = (call.arg(2)).to_i32().unwrap();

    let mut sourceLevelCount: GLsizei;
    sourceLevelCount = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::CopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount) };
}

pub fn retrace_glElementPointerAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let pointer: &mut [GLvoid];
    let pointer = (call.arg(1)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ElementPointerAPPLE(_type, pointer) };
}

pub fn retrace_glDrawElementArrayAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLint;
    first = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::DrawElementArrayAPPLE(mode, first, count) };
}

pub fn retrace_glDrawRangeElementArrayAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLuint;
    start = (call.arg(1)).to_u32().unwrap();

    let mut end: GLuint;
    end = (call.arg(2)).to_u32().unwrap();

    let mut first: GLint;
    first = (call.arg(3)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::DrawRangeElementArrayAPPLE(mode, start, end, first, count) };
}

pub fn retrace_glMultiDrawElementArrayAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let first: &mut [GLint];
    first = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint176_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint176_0) = _a_GLint176_0 {
        for _jGLint176 in 0.._a_GLint176_0.values.len() {
    first[_jGLint176] = (*_a_GLint176_0.values[_jGLint176]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let count: &mut [GLsizei];
    count = _allocator.alloc_array::<GLsizei>(&call.arg(2));
    let _a_GLsizei7_0 = (call.arg(2)).to_array();
    if let Some(_a_GLsizei7_0) = _a_GLsizei7_0 {
        for _jGLsizei7 in 0.._a_GLsizei7_0.values.len() {
    count[_jGLsizei7] = (*_a_GLsizei7_0.values[_jGLsizei7]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut drawcount: GLsizei;
    drawcount = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiDrawElementArrayAPPLE(mode, first, count, drawcount) };
}

pub fn retrace_glMultiDrawRangeElementArrayAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLuint;
    start = (call.arg(1)).to_u32().unwrap();

    let mut end: GLuint;
    end = (call.arg(2)).to_u32().unwrap();

    let first: &mut [GLint];
    first = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint177_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint177_0) = _a_GLint177_0 {
        for _jGLint177 in 0.._a_GLint177_0.values.len() {
    first[_jGLint177] = (*_a_GLint177_0.values[_jGLint177]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let count: &mut [GLsizei];
    count = _allocator.alloc_array::<GLsizei>(&call.arg(4));
    let _a_GLsizei8_0 = (call.arg(4)).to_array();
    if let Some(_a_GLsizei8_0) = _a_GLsizei8_0 {
        for _jGLsizei8 in 0.._a_GLsizei8_0.values.len() {
    count[_jGLsizei8] = (*_a_GLsizei8_0.values[_jGLsizei8]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut drawcount: GLsizei;
    drawcount = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::MultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, drawcount) };
}

pub fn retrace_glGenFencesAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let fences: &mut [GLuint];
    fences = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenFencesAPPLE(n, fences) };
    let _aGLuint126 = (call.arg(1)).to_array();
    if (_aGLuint126) {
        for _jGLuint126 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint126.values[_jGLuint126]).to_u32().unwrap();
    _fence_map[_origResult] = fences[_jGLuint126];
        }
    }
}

pub fn retrace_glDeleteFencesAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let fences: &mut [GLuint];
    fences = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint127_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint127_0) = _a_GLuint127_0 {
        for _jGLuint127 in 0.._a_GLuint127_0.values.len() {
    fences[_jGLuint127] = (*_a_GLuint127_0.values[_jGLuint127]).to_u32().unwrap();
    fences[_jGLuint127] = _fence_map[fences[_jGLuint127]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteFencesAPPLE(n, fences) };
}

pub fn retrace_glSetFenceAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut fence: GLuint;
    fence = (call.arg(0)).to_u32().unwrap();
    fence = _fence_map[fence];

    unsafe { gl::SetFenceAPPLE(fence) };
}

pub fn retrace_glTestFenceAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut fence: GLuint;
    fence = (call.arg(0)).to_u32().unwrap();
    fence = _fence_map[fence];

    let _result = unsafe { gl::TestFenceAPPLE(fence) };

}

pub fn retrace_glFinishFenceAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut fence: GLuint;
    fence = (call.arg(0)).to_u32().unwrap();
    fence = _fence_map[fence];

    unsafe { gl::FinishFenceAPPLE(fence) };
}

pub fn retrace_glTestObjectAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut object: GLenum;
    object = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut name: GLuint;
    name = (call.arg(1)).to_u32().unwrap();

    let _result = unsafe { gl::TestObjectAPPLE(object, name) };

}

pub fn retrace_glFinishObjectAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut object: GLenum;
    object = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut name: GLint;
    name = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::FinishObjectAPPLE(object, name) };
}

pub fn retrace_glBufferParameteriAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::BufferParameteriAPPLE(target, pname, param) };
}

pub fn retrace_glFlushMappedBufferRangeAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::FlushMappedBufferRangeAPPLE(target, offset, size) };
}

pub fn retrace_glFlushRenderAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::FlushRenderAPPLE() };
}

pub fn retrace_glFinishRenderAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::FinishRenderAPPLE() };
}

pub fn retrace_glSwapAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::SwapAPPLE() };
}

pub fn retrace_glRenderbufferStorageMultisampleAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::RenderbufferStorageMultisampleAPPLE(target, samples, internalformat, width, height) };
}

pub fn retrace_glResolveMultisampleFramebufferAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::ResolveMultisampleFramebufferAPPLE() };
}

pub fn retrace_glObjectPurgeableAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut objectType: GLenum;
    objectType = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut name: GLuint;
    name = (call.arg(1)).to_u32().unwrap();

    let mut option: GLenum;
    option = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::ObjectPurgeableAPPLE(objectType, name, option) };

}

pub fn retrace_glObjectUnpurgeableAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut objectType: GLenum;
    objectType = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut name: GLuint;
    name = (call.arg(1)).to_u32().unwrap();

    let mut option: GLenum;
    option = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::ObjectUnpurgeableAPPLE(objectType, name, option) };

}

pub fn retrace_glPointSizePointerAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::PointSizePointerAPPLE(_type, stride, pointer) };
}

pub fn retrace_glVertexPointSizefAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLfloat;
    size = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::VertexPointSizefAPPLE(size) };
}

pub fn retrace_glFenceSyncAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut condition: GLenum;
    condition = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut flags: GLbitfield;
    flags = (call.arg(1)).to_u32().unwrap();

    let _result = unsafe { gl::FenceSyncAPPLE(condition, flags) };

    self.context.needs_flush = true;
    let _origResult: GLsync;
    let _origResult = (*call.ret).to_pointer().unwrap() as *mut c_void;
    _sync_map[_origResult] = _result;
}

pub fn retrace_glDeleteSyncAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sync: GLsync;
    let sync = (call.arg(0)).to_pointer().unwrap() as *mut c_void;
    sync = _sync_map[sync];

    unsafe { gl::DeleteSyncAPPLE(sync) };
}

pub fn retrace_glClientWaitSyncAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sync: GLsync;
    let sync = (call.arg(0)).to_pointer().unwrap() as *mut c_void;
    sync = _sync_map[sync];

    let mut flags: GLbitfield;
    flags = (call.arg(1)).to_u32().unwrap();

    let mut timeout: GLuint64;
    timeout = (call.arg(2)).to_u32().unwrap();

    let _result = unsafe { gl::ClientWaitSyncAPPLE(sync, flags, timeout) };

}

pub fn retrace_glWaitSyncAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sync: GLsync;
    let sync = (call.arg(0)).to_pointer().unwrap() as *mut c_void;
    sync = _sync_map[sync];

    let mut flags: GLbitfield;
    flags = (call.arg(1)).to_u32().unwrap();

    let mut timeout: GLuint64;
    timeout = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::WaitSyncAPPLE(sync, flags, timeout) };
}

pub fn retrace_glTextureRangeAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut length: GLsizei;
    length = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    let pointer = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TextureRangeAPPLE(target, length, pointer) };
}

pub fn retrace_glBindVertexArrayAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut array: GLuint;
    array = (call.arg(0)).to_u32().unwrap();
    array = _arrayAPPLE_map[array];

    unsafe { gl::BindVertexArrayAPPLE(array) };
}

pub fn retrace_glDeleteVertexArraysAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let arrays: &mut [GLuint];
    arrays = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint128_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint128_0) = _a_GLuint128_0 {
        for _jGLuint128 in 0.._a_GLuint128_0.values.len() {
    arrays[_jGLuint128] = (*_a_GLuint128_0.values[_jGLuint128]).to_u32().unwrap();
    arrays[_jGLuint128] = _arrayAPPLE_map[arrays[_jGLuint128]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteVertexArraysAPPLE(n, arrays) };
}

pub fn retrace_glGenVertexArraysAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let arrays: &mut [GLuint];
    arrays = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenVertexArraysAPPLE(n, arrays) };
    let _aGLuint130 = (call.arg(1)).to_array();
    if (_aGLuint130) {
        for _jGLuint130 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint130.values[_jGLuint130]).to_u32().unwrap();
    _arrayAPPLE_map[_origResult] = arrays[_jGLuint130];
        }
    }
}

pub fn retrace_glVertexArrayRangeAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut length: GLsizei;
    length = (call.arg(0)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::VertexArrayRangeAPPLE(length, pointer) };
}

pub fn retrace_glFlushVertexArrayRangeAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut length: GLsizei;
    length = (call.arg(0)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::FlushVertexArrayRangeAPPLE(length, pointer) };
}

pub fn retrace_glVertexArrayParameteriAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::VertexArrayParameteriAPPLE(pname, param) };
}

pub fn retrace_glEnableVertexAttribAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::EnableVertexAttribAPPLE(index, pname) };
}

pub fn retrace_glDisableVertexAttribAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::DisableVertexAttribAPPLE(index, pname) };
}

pub fn retrace_glMapVertexAttrib1dAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLuint;
    size = (call.arg(1)).to_u32().unwrap();

    let mut u1: GLdouble;
    u1 = (call.arg(2)).to_f64().unwrap();

    let mut u2: GLdouble;
    u2 = (call.arg(3)).to_f64().unwrap();

    let mut stride: GLint;
    stride = (call.arg(4)).to_i32().unwrap();

    let mut order: GLint;
    order = (call.arg(5)).to_i32().unwrap();

    let points: &mut [GLdouble];
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    }
    unsafe { gl::MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points) };
}

pub fn retrace_glMapVertexAttrib1fAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLuint;
    size = (call.arg(1)).to_u32().unwrap();

    let mut u1: GLfloat;
    u1 = (call.arg(2)).to_f32().unwrap();

    let mut u2: GLfloat;
    u2 = (call.arg(3)).to_f32().unwrap();

    let mut stride: GLint;
    stride = (call.arg(4)).to_i32().unwrap();

    let mut order: GLint;
    order = (call.arg(5)).to_i32().unwrap();

    let points: &mut [GLfloat];
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    }
    unsafe { gl::MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points) };
}

pub fn retrace_glMapVertexAttrib2dAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLuint;
    size = (call.arg(1)).to_u32().unwrap();

    let mut u1: GLdouble;
    u1 = (call.arg(2)).to_f64().unwrap();

    let mut u2: GLdouble;
    u2 = (call.arg(3)).to_f64().unwrap();

    let mut ustride: GLint;
    ustride = (call.arg(4)).to_i32().unwrap();

    let mut uorder: GLint;
    uorder = (call.arg(5)).to_i32().unwrap();

    let mut v1: GLdouble;
    v1 = (call.arg(6)).to_f64().unwrap();

    let mut v2: GLdouble;
    v2 = (call.arg(7)).to_f64().unwrap();

    let mut vstride: GLint;
    vstride = (call.arg(8)).to_i32().unwrap();

    let mut vorder: GLint;
    vorder = (call.arg(9)).to_i32().unwrap();

    let points: &mut [GLdouble];
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    }
    unsafe { gl::MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) };
}

pub fn retrace_glMapVertexAttrib2fAPPLE(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLuint;
    size = (call.arg(1)).to_u32().unwrap();

    let mut u1: GLfloat;
    u1 = (call.arg(2)).to_f32().unwrap();

    let mut u2: GLfloat;
    u2 = (call.arg(3)).to_f32().unwrap();

    let mut ustride: GLint;
    ustride = (call.arg(4)).to_i32().unwrap();

    let mut uorder: GLint;
    uorder = (call.arg(5)).to_i32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(6)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(7)).to_f32().unwrap();

    let mut vstride: GLint;
    vstride = (call.arg(8)).to_i32().unwrap();

    let mut vorder: GLint;
    vorder = (call.arg(9)).to_i32().unwrap();

    let points: &mut [GLfloat];
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    }
    unsafe { gl::MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) };
}

pub fn retrace_glReleaseShaderCompiler(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::ReleaseShaderCompiler() };
}

pub fn retrace_glShaderBinary(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut count: GLsizei;
    count = (call.arg(0)).to_i32().unwrap();

    let shaders: &mut [GLuint];
    shaders = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint131_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint131_0) = _a_GLuint131_0 {
        for _jGLuint131 in 0.._a_GLuint131_0.values.len() {
    shaders[_jGLuint131] = (*_a_GLuint131_0.values[_jGLuint131]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut binaryformat: GLenum;
    binaryformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let binary: &mut [GLvoid];
    let binary = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut length: GLsizei;
    length = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::ShaderBinary(count, shaders, binaryformat, binary, length) };
}

pub fn retrace_glDepthRangef(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLfloat;
    n = (call.arg(0)).to_f32().unwrap();

    let mut f: GLfloat;
    f = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::DepthRangef(n, f) };
}

pub fn retrace_glClearDepthf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut d: GLfloat;
    d = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::ClearDepthf(d) };
}

pub fn retrace_glMemoryBarrierByRegion(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut barriers: GLbitfield;
    barriers = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::MemoryBarrierByRegion(barriers) };
}

pub fn retrace_glPrimitiveBoundingBoxARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut minX: GLfloat;
    minX = (call.arg(0)).to_f32().unwrap();

    let mut minY: GLfloat;
    minY = (call.arg(1)).to_f32().unwrap();

    let mut minZ: GLfloat;
    minZ = (call.arg(2)).to_f32().unwrap();

    let mut minW: GLfloat;
    minW = (call.arg(3)).to_f32().unwrap();

    let mut maxX: GLfloat;
    maxX = (call.arg(4)).to_f32().unwrap();

    let mut maxY: GLfloat;
    maxY = (call.arg(5)).to_f32().unwrap();

    let mut maxZ: GLfloat;
    maxZ = (call.arg(6)).to_f32().unwrap();

    let mut maxW: GLfloat;
    maxW = (call.arg(7)).to_f32().unwrap();

    unsafe { gl::PrimitiveBoundingBoxARB(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW) };
}

pub fn retrace_glDrawArraysInstancedBaseInstance(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLint;
    first = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut instancecount: GLsizei;
    instancecount = (call.arg(3)).to_i32().unwrap();

    let mut baseinstance: GLuint;
    baseinstance = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::DrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance) };
}

pub fn retrace_glDrawElementsInstancedBaseInstance(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut instancecount: GLsizei;
    instancecount = (call.arg(4)).to_i32().unwrap();

    let mut baseinstance: GLuint;
    baseinstance = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::DrawElementsInstancedBaseInstance(mode, count, _type, indices, instancecount, baseinstance) };
}

pub fn retrace_glDrawElementsInstancedBaseVertexBaseInstance(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut instancecount: GLsizei;
    instancecount = (call.arg(4)).to_i32().unwrap();

    let mut basevertex: GLint;
    basevertex = (call.arg(5)).to_i32().unwrap();

    let mut baseinstance: GLuint;
    baseinstance = (call.arg(6)).to_u32().unwrap();

    unsafe { gl::DrawElementsInstancedBaseVertexBaseInstance(mode, count, _type, indices, instancecount, basevertex, baseinstance) };
}

pub fn retrace_glGetTextureHandleARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let _result = unsafe { gl::GetTextureHandleARB(texture) };

    let _origResult: GLuint64;
    _origResult = (*call.ret).to_u32().unwrap();
    _textureHandle_map[_origResult] = _result;
}

pub fn retrace_glGetTextureSamplerHandleARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut sampler: GLuint;
    sampler = (call.arg(1)).to_u32().unwrap();
    sampler = _sampler_map[sampler];

    let _result = unsafe { gl::GetTextureSamplerHandleARB(texture, sampler) };

    let _origResult: GLuint64;
    _origResult = (*call.ret).to_u32().unwrap();
    _textureHandle_map[_origResult] = _result;
}

pub fn retrace_glMakeTextureHandleResidentARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut handle: GLuint64;
    handle = (call.arg(0)).to_u32().unwrap();
    handle = _textureHandle_map[handle];

    unsafe { gl::MakeTextureHandleResidentARB(handle) };
}

pub fn retrace_glMakeTextureHandleNonResidentARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut handle: GLuint64;
    handle = (call.arg(0)).to_u32().unwrap();
    handle = _textureHandle_map[handle];

    unsafe { gl::MakeTextureHandleNonResidentARB(handle) };
}

pub fn retrace_glGetImageHandleARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut layered: GLboolean;
    layered = (call.arg(2)).to_u32().unwrap() as u8;

    let mut layer: GLint;
    layer = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::GetImageHandleARB(texture, level, layered, layer, format) };

    let _origResult: GLuint64;
    _origResult = (*call.ret).to_u32().unwrap();
    _imageHandle_map[_origResult] = _result;
}

pub fn retrace_glMakeImageHandleResidentARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut handle: GLuint64;
    handle = (call.arg(0)).to_u32().unwrap();
    handle = _imageHandle_map[handle];

    let mut access: GLenum;
    access = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::MakeImageHandleResidentARB(handle, access) };
}

pub fn retrace_glMakeImageHandleNonResidentARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut handle: GLuint64;
    handle = (call.arg(0)).to_u32().unwrap();
    handle = _imageHandle_map[handle];

    unsafe { gl::MakeImageHandleNonResidentARB(handle) };
}

pub fn retrace_glUniformHandleui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut value: GLuint64;
    value = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::UniformHandleui64ARB(location, value) };
}

pub fn retrace_glUniformHandleui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64];
    value = _allocator.alloc_array::<GLuint64>(&call.arg(2));
    let _a_GLuint649_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint649_0) = _a_GLuint649_0 {
        for _jGLuint649 in 0.._a_GLuint649_0.values.len() {
    value[_jGLuint649] = (*_a_GLuint649_0.values[_jGLuint649]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformHandleui64vARB(location, count, value) };
}

pub fn retrace_glProgramUniformHandleui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut value: GLuint64;
    value = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::ProgramUniformHandleui64ARB(program, location, value) };
}

pub fn retrace_glProgramUniformHandleui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let values: &mut [GLuint64];
    values = _allocator.alloc_array::<GLuint64>(&call.arg(3));
    let _a_GLuint6410_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint6410_0) = _a_GLuint6410_0 {
        for _jGLuint6410 in 0.._a_GLuint6410_0.values.len() {
    values[_jGLuint6410] = (*_a_GLuint6410_0.values[_jGLuint6410]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformHandleui64vARB(program, location, count, values) };
}

pub fn retrace_glVertexAttribL1ui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint64;
    x = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexAttribL1ui64ARB(index, x) };
}

pub fn retrace_glVertexAttribL1ui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint64];
    v = _allocator.alloc_array::<GLuint64>(&call.arg(1));
    let _a_PGLuint643_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLuint643_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexAttribL1ui64vARB(index, v) };
}

pub fn retrace_glBindFragDataLocationIndexed(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut colorNumber: GLuint;
    colorNumber = (call.arg(1)).to_u32().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(3)).to_string().unwrap());

    unsafe { gl::BindFragDataLocationIndexed(program, colorNumber, index, name) };
}

pub fn retrace_glBufferStorage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(1)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut flags: GLbitfield;
    flags = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::BufferStorage(target, size, data, flags) };
}

pub fn retrace_glClearBufferData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [void];
    let data = (call.arg(4)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ClearBufferData(target, internalformat, format, _type, data) };
}

pub fn retrace_glClearBufferSubData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(2)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [void];
    let data = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ClearBufferSubData(target, internalformat, offset, size, format, _type, data) };
}

pub fn retrace_glClearTexImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(4)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ClearTexImage(texture, level, format, _type, data) };
}

pub fn retrace_glClearTexSubImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, _type, data) };
}

pub fn retrace_glClipControl(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut origin: GLenum;
    origin = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut depth: GLenum;
    depth = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ClipControl(origin, depth) };
}

pub fn retrace_glClampColorARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut clamp: GLenum;
    clamp = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ClampColorARB(target, clamp) };
}

pub fn retrace_glDispatchCompute(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut num_groups_x: GLuint;
    num_groups_x = (call.arg(0)).to_u32().unwrap();

    let mut num_groups_y: GLuint;
    num_groups_y = (call.arg(1)).to_u32().unwrap();

    let mut num_groups_z: GLuint;
    num_groups_z = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::DispatchCompute(num_groups_x, num_groups_y, num_groups_z) };
}

pub fn retrace_glDispatchComputeIndirect(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut indirect: GLintptr;
    indirect = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::DispatchComputeIndirect(indirect) };
}

pub fn retrace_glDispatchComputeGroupSizeARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut num_groups_x: GLuint;
    num_groups_x = (call.arg(0)).to_u32().unwrap();

    let mut num_groups_y: GLuint;
    num_groups_y = (call.arg(1)).to_u32().unwrap();

    let mut num_groups_z: GLuint;
    num_groups_z = (call.arg(2)).to_u32().unwrap();

    let mut group_size_x: GLuint;
    group_size_x = (call.arg(3)).to_u32().unwrap();

    let mut group_size_y: GLuint;
    group_size_y = (call.arg(4)).to_u32().unwrap();

    let mut group_size_z: GLuint;
    group_size_z = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::DispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z) };
}

pub fn retrace_glCopyBufferSubData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut readTarget: GLenum;
    readTarget = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut writeTarget: GLenum;
    writeTarget = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut readOffset: GLintptr;
    readOffset = (call.arg(2)).to_i32().unwrap();

    let mut writeOffset: GLintptr;
    writeOffset = (call.arg(3)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::CopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size) };
}

pub fn retrace_glCopyImageSubData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut srcName: GLuint;
    srcName = (call.arg(0)).to_u32().unwrap();
    srcName = _texture_map[srcName];

    let mut srcTarget: GLenum;
    srcTarget = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut srcLevel: GLint;
    srcLevel = (call.arg(2)).to_i32().unwrap();

    let mut srcX: GLint;
    srcX = (call.arg(3)).to_i32().unwrap();

    let mut srcY: GLint;
    srcY = (call.arg(4)).to_i32().unwrap();

    let mut srcZ: GLint;
    srcZ = (call.arg(5)).to_i32().unwrap();

    let mut dstName: GLuint;
    dstName = (call.arg(6)).to_u32().unwrap();
    dstName = _texture_map[dstName];

    let mut dstTarget: GLenum;
    dstTarget = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut dstLevel: GLint;
    dstLevel = (call.arg(8)).to_i32().unwrap();

    let mut dstX: GLint;
    dstX = (call.arg(9)).to_i32().unwrap();

    let mut dstY: GLint;
    dstY = (call.arg(10)).to_i32().unwrap();

    let mut dstZ: GLint;
    dstZ = (call.arg(11)).to_i32().unwrap();

    let mut srcWidth: GLsizei;
    srcWidth = (call.arg(12)).to_i32().unwrap();

    let mut srcHeight: GLsizei;
    srcHeight = (call.arg(13)).to_i32().unwrap();

    let mut srcDepth: GLsizei;
    srcDepth = (call.arg(14)).to_i32().unwrap();

    if (srcTarget == GL_RENDERBUFFER || dstTarget == GL_RENDERBUFFER) {
        retrace::warning(call) << " renderbuffer targets unsupported (https://git.io/JOMRC)\n";
    }
    unsafe { gl::CopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth) };
}

pub fn retrace_glDebugMessageControlARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut source: GLenum;
    source = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut severity: GLenum;
    severity = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(4));
    let _a_GLuint132_0 = (call.arg(4)).to_array();
    if let Some(_a_GLuint132_0) = _a_GLuint132_0 {
        for _jGLuint132 in 0.._a_GLuint132_0.values.len() {
    ids[_jGLuint132] = (*_a_GLuint132_0.values[_jGLuint132]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut enabled: GLboolean;
    enabled = (call.arg(5)).to_u32().unwrap() as u8;

    unsafe { gl::DebugMessageControlARB(source, _type, severity, count, ids, enabled) };
}

pub fn retrace_glDebugMessageInsertARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut source: GLenum;
    source = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(2)).to_u32().unwrap();

    let mut severity: GLenum;
    severity = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut length: GLsizei;
    length = (call.arg(4)).to_i32().unwrap();

    let buf: &mut [GLchar];
    buf = (GLchar *)((call.arg(5)).to_string().unwrap());

    unsafe { gl::DebugMessageInsertARB(source, _type, id, severity, length, buf) };
}

pub fn retrace_glCreateTransformFeedbacks(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::CreateTransformFeedbacks(n, ids) };
    let _aGLuint134 = (call.arg(1)).to_array();
    if (_aGLuint134) {
        for _jGLuint134 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint134.values[_jGLuint134]).to_u32().unwrap();
    _feedback_map[_origResult] = ids[_jGLuint134];
        }
    }
}

pub fn retrace_glTransformFeedbackBufferBase(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut xfb: GLuint;
    xfb = (call.arg(0)).to_u32().unwrap();
    xfb = _feedback_map[xfb];

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::TransformFeedbackBufferBase(xfb, index, buffer) };
}

pub fn retrace_glTransformFeedbackBufferRange(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut xfb: GLuint;
    xfb = (call.arg(0)).to_u32().unwrap();
    xfb = _feedback_map[xfb];

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::TransformFeedbackBufferRange(xfb, index, buffer, offset, size) };
}

pub fn retrace_glCreateBuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let buffers: &mut [GLuint];
    buffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::CreateBuffers(n, buffers) };
    let _aGLuint136 = (call.arg(1)).to_array();
    if (_aGLuint136) {
        for _jGLuint136 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint136.values[_jGLuint136]).to_u32().unwrap();
    _buffer_map[_origResult] = buffers[_jGLuint136];
        }
    }
}

pub fn retrace_glNamedBufferStorage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut size: GLsizeiptr;
    size = (call.arg(1)).to_i32().unwrap();

    let data: &mut [void];
    let data = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut flags: GLbitfield;
    flags = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::NamedBufferStorage(buffer, size, data, flags) };
}

pub fn retrace_glNamedBufferData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut size: GLsizeiptr;
    size = (call.arg(1)).to_i32().unwrap();

    let data: &mut [void];
    let data = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut usage: GLenum;
    usage = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::NamedBufferData(buffer, size, data, usage) };
}

pub fn retrace_glNamedBufferSubData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(2)).to_i32().unwrap();

    let data: &mut [void];
    let data = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::NamedBufferSubData(buffer, offset, size, data) };
}

pub fn retrace_glCopyNamedBufferSubData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut readBuffer: GLuint;
    readBuffer = (call.arg(0)).to_u32().unwrap();
    readBuffer = _buffer_map[readBuffer];

    let mut writeBuffer: GLuint;
    writeBuffer = (call.arg(1)).to_u32().unwrap();
    writeBuffer = _buffer_map[writeBuffer];

    let mut readOffset: GLintptr;
    readOffset = (call.arg(2)).to_i32().unwrap();

    let mut writeOffset: GLintptr;
    writeOffset = (call.arg(3)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::CopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size) };
}

pub fn retrace_glClearNamedBufferData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [void];
    let data = (call.arg(4)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ClearNamedBufferData(buffer, internalformat, format, _type, data) };
}

pub fn retrace_glClearNamedBufferSubData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(2)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [void];
    let data = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ClearNamedBufferSubData(buffer, internalformat, offset, size, format, _type, data) };
}

pub fn retrace_glMapNamedBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut access: GLenum;
    access = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::MapNamedBuffer(buffer, access) };

    let length = 0;
    gl::GetNamedBufferParameteriv(buffer, gl::BUFFER_SIZE, &length);
    retrace::addRegion(call, (*call.ret).toUIntPtr(), _result, length);
}

pub fn retrace_glMapNamedBufferRange(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut length: GLsizeiptr;
    length = (call.arg(2)).to_i32().unwrap();

    let mut access: GLbitfield;
    access = (call.arg(3)).to_u32().unwrap();

    let _result = unsafe { gl::MapNamedBufferRange(buffer, offset, length, access) };

    retrace::addRegion(call, (*call.ret).toUIntPtr(), _result, length);
}

pub fn retrace_glUnmapNamedBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

        GLvoid *ptr = NULL;
            glGetNamedBufferPointerv(buffer, GL_BUFFER_MAP_POINTER, &ptr);
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "failed to get mapped pointer\n";
        }
    let _result = unsafe { gl::UnmapNamedBuffer(buffer) };

}

pub fn retrace_glFlushMappedNamedBufferRange(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut length: GLsizeiptr;
    length = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::FlushMappedNamedBufferRange(buffer, offset, length) };
}

pub fn retrace_glCreateFramebuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let framebuffers: &mut [GLuint];
    framebuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::CreateFramebuffers(n, framebuffers) };
    let _aGLuint138 = (call.arg(1)).to_array();
    if (_aGLuint138) {
        for _jGLuint138 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint138.values[_jGLuint138]).to_u32().unwrap();
    _framebuffer_map[_origResult] = framebuffers[_jGLuint138];
        }
    }
}

pub fn retrace_glNamedFramebufferRenderbuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffertarget: GLenum;
    renderbuffertarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(3)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    unsafe { gl::NamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer) };
}

pub fn retrace_glNamedFramebufferParameteri(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::NamedFramebufferParameteri(framebuffer, pname, param) };
}

pub fn retrace_glNamedFramebufferTexture(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::NamedFramebufferTexture(framebuffer, attachment, texture, level) };
}

pub fn retrace_glNamedFramebufferTextureLayer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    let mut layer: GLint;
    layer = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::NamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer) };
}

pub fn retrace_glNamedFramebufferDrawBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut buf: GLenum;
    buf = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::NamedFramebufferDrawBuffer(framebuffer, buf) };
}

pub fn retrace_glNamedFramebufferDrawBuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let bufs: &mut [GLenum];
    bufs = _allocator.alloc_array::<GLenum>(&call.arg(2));
    let _a_GLenum15_0 = (call.arg(2)).to_array();
    if let Some(_a_GLenum15_0) = _a_GLenum15_0 {
        for _jGLenum15 in 0.._a_GLenum15_0.values.len() {
    bufs[_jGLenum15] = (*_a_GLenum15_0.values[_jGLenum15]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NamedFramebufferDrawBuffers(framebuffer, n, bufs) };
}

pub fn retrace_glNamedFramebufferReadBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut src: GLenum;
    src = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::NamedFramebufferReadBuffer(framebuffer, src) };
}

pub fn retrace_glInvalidateNamedFramebufferData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut numAttachments: GLsizei;
    numAttachments = (call.arg(1)).to_i32().unwrap();

    let attachments: &mut [GLenum];
    attachments = _allocator.alloc_array::<GLenum>(&call.arg(2));
    let _a_GLenum16_0 = (call.arg(2)).to_array();
    if let Some(_a_GLenum16_0) = _a_GLenum16_0 {
        for _jGLenum16 in 0.._a_GLenum16_0.values.len() {
    attachments[_jGLenum16] = (*_a_GLenum16_0.values[_jGLenum16]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::InvalidateNamedFramebufferData(framebuffer, numAttachments, attachments) };
}

pub fn retrace_glInvalidateNamedFramebufferSubData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut numAttachments: GLsizei;
    numAttachments = (call.arg(1)).to_i32().unwrap();

    let attachments: &mut [GLenum];
    attachments = _allocator.alloc_array::<GLenum>(&call.arg(2));
    let _a_GLenum17_0 = (call.arg(2)).to_array();
    if let Some(_a_GLenum17_0) = _a_GLenum17_0 {
        for _jGLenum17 in 0.._a_GLenum17_0.values.len() {
    attachments[_jGLenum17] = (*_a_GLenum17_0.values[_jGLenum17]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut x: GLint;
    x = (call.arg(3)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::InvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height) };
}

pub fn retrace_glClearNamedFramebufferiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut buffer: GLenum;
    buffer = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut drawbuffer: GLint;
    drawbuffer = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint178_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint178_0) = _a_GLint178_0 {
        for _jGLint178 in 0.._a_GLint178_0.values.len() {
    value[_jGLint178] = (*_a_GLint178_0.values[_jGLint178]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value) };
}

pub fn retrace_glClearNamedFramebufferuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut buffer: GLenum;
    buffer = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut drawbuffer: GLint;
    drawbuffer = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint139_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint139_0) = _a_GLuint139_0 {
        for _jGLuint139 in 0.._a_GLuint139_0.values.len() {
    value[_jGLuint139] = (*_a_GLuint139_0.values[_jGLuint139]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value) };
}

pub fn retrace_glClearNamedFramebufferfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut buffer: GLenum;
    buffer = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut drawbuffer: GLint;
    drawbuffer = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat147_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat147_0) = _a_GLfloat147_0 {
        for _jGLfloat147 in 0.._a_GLfloat147_0.values.len() {
    value[_jGLfloat147] = (*_a_GLfloat147_0.values[_jGLfloat147]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value) };
}

pub fn retrace_glClearNamedFramebufferfi(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut buffer: GLenum;
    buffer = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut drawbuffer: GLint;
    drawbuffer = (call.arg(2)).to_i32().unwrap();

    let mut depth: GLfloat;
    depth = (call.arg(3)).to_f32().unwrap();

    let mut stencil: GLint;
    stencil = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::ClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil) };
}

pub fn retrace_glBlitNamedFramebuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut readFramebuffer: GLuint;
    readFramebuffer = (call.arg(0)).to_u32().unwrap();
    readFramebuffer = _framebuffer_map[readFramebuffer];

    let mut drawFramebuffer: GLuint;
    drawFramebuffer = (call.arg(1)).to_u32().unwrap();
    drawFramebuffer = _framebuffer_map[drawFramebuffer];

    let mut srcX0: GLint;
    srcX0 = (call.arg(2)).to_i32().unwrap();

    let mut srcY0: GLint;
    srcY0 = (call.arg(3)).to_i32().unwrap();

    let mut srcX1: GLint;
    srcX1 = (call.arg(4)).to_i32().unwrap();

    let mut srcY1: GLint;
    srcY1 = (call.arg(5)).to_i32().unwrap();

    let mut dstX0: GLint;
    dstX0 = (call.arg(6)).to_i32().unwrap();

    let mut dstY0: GLint;
    dstY0 = (call.arg(7)).to_i32().unwrap();

    let mut dstX1: GLint;
    dstX1 = (call.arg(8)).to_i32().unwrap();

    let mut dstY1: GLint;
    dstY1 = (call.arg(9)).to_i32().unwrap();

    let mut mask: GLbitfield;
    mask = (call.arg(10)).to_u32().unwrap();

    let mut filter: GLenum;
    filter = (call.arg(11)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter) };
}

pub fn retrace_glCheckNamedFramebufferStatus(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::CheckNamedFramebufferStatus(framebuffer, target) };

    let _origResult = call.ret.to_i32().unwrap();
}

pub fn retrace_glCreateRenderbuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let renderbuffers: &mut [GLuint];
    renderbuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::CreateRenderbuffers(n, renderbuffers) };
    let _aGLuint141 = (call.arg(1)).to_array();
    if (_aGLuint141) {
        for _jGLuint141 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint141.values[_jGLuint141]).to_u32().unwrap();
    _renderbuffer_map[_origResult] = renderbuffers[_jGLuint141];
        }
    }
}

pub fn retrace_glNamedRenderbufferStorage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(0)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::NamedRenderbufferStorage(renderbuffer, internalformat, width, height) };
}

pub fn retrace_glNamedRenderbufferStorageMultisample(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(0)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::NamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height) };
}

pub fn retrace_glCreateTextures(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let textures: &mut [GLuint];
    textures = _allocator.alloc_array::<GLuint>(&call.arg(2));

    unsafe { gl::CreateTextures(target, n, textures) };
    let _aGLuint143 = (call.arg(2)).to_array();
    if (_aGLuint143) {
        for _jGLuint143 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint143.values[_jGLuint143]).to_u32().unwrap();
    _texture_map[_origResult] = textures[_jGLuint143];
        }
    }
}

pub fn retrace_glTextureBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::TextureBuffer(texture, internalformat, buffer) };
}

pub fn retrace_glTextureBufferRange(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::TextureBufferRange(texture, internalformat, buffer, offset, size) };
}

pub fn retrace_glTextureStorage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::TextureStorage1D(texture, levels, internalformat, width) };
}

pub fn retrace_glTextureStorage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::TextureStorage2D(texture, levels, internalformat, width, height) };
}

pub fn retrace_glTextureStorage3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::TextureStorage3D(texture, levels, internalformat, width, height, depth) };
}

pub fn retrace_glTextureStorage2DMultisample(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut fixedsamplelocations: GLboolean;
    fixedsamplelocations = (call.arg(5)).to_u32().unwrap() as u8;

    unsafe { gl::TextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations) };
}

pub fn retrace_glTextureStorage3DMultisample(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut fixedsamplelocations: GLboolean;
    fixedsamplelocations = (call.arg(6)).to_u32().unwrap() as u8;

    unsafe { gl::TextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations) };
}

pub fn retrace_glTextureSubImage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TextureSubImage1D(texture, level, xoffset, width, format, _type, pixels) };
}

pub fn retrace_glTextureSubImage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, _type, pixels) };
}

pub fn retrace_glTextureSubImage3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, _type, pixels) };
}

pub fn retrace_glCompressedTextureSubImage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(5)).to_i32().unwrap();

    let data: &mut [void];
    let data = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data) };
}

pub fn retrace_glCompressedTextureSubImage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(7)).to_i32().unwrap();

    let data: &mut [void];
    let data = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data) };
}

pub fn retrace_glCompressedTextureSubImage3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(9)).to_i32().unwrap();

    let data: &mut [void];
    let data = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data) };
}

pub fn retrace_glCopyTextureSubImage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(3)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::CopyTextureSubImage1D(texture, level, xoffset, x, y, width) };
}

pub fn retrace_glCopyTextureSubImage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(4)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(7)).to_i32().unwrap();

    unsafe { gl::CopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height) };
}

pub fn retrace_glCopyTextureSubImage3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(5)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(6)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(7)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(8)).to_i32().unwrap();

    unsafe { gl::CopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height) };
}

pub fn retrace_glTextureParameterf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::TextureParameterf(texture, pname, param) };
}

pub fn retrace_glTextureParameterfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat148_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat148_0) = _a_GLfloat148_0 {
        for _jGLfloat148 in 0.._a_GLfloat148_0.values.len() {
    params[_jGLfloat148] = (*_a_GLfloat148_0.values[_jGLfloat148]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TextureParameterfv(texture, pname, params) };
}

pub fn retrace_glTextureParameteri(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TextureParameteri(texture, pname, param) };
}

pub fn retrace_glTextureParameterIiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint179_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint179_0) = _a_GLint179_0 {
        for _jGLint179 in 0.._a_GLint179_0.values.len() {
    params[_jGLint179] = (*_a_GLint179_0.values[_jGLint179]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TextureParameterIiv(texture, pname, params) };
}

pub fn retrace_glTextureParameterIuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint144_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint144_0) = _a_GLuint144_0 {
        for _jGLuint144 in 0.._a_GLuint144_0.values.len() {
    params[_jGLuint144] = (*_a_GLuint144_0.values[_jGLuint144]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TextureParameterIuiv(texture, pname, params) };
}

pub fn retrace_glTextureParameteriv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint180_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint180_0) = _a_GLint180_0 {
        for _jGLint180 in 0.._a_GLint180_0.values.len() {
    params[_jGLint180] = (*_a_GLint180_0.values[_jGLint180]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TextureParameteriv(texture, pname, params) };
}

pub fn retrace_glGenerateTextureMipmap(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    unsafe { gl::GenerateTextureMipmap(texture) };
}

pub fn retrace_glBindTextureUnit(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut unit: GLuint;
    unit = (call.arg(0)).to_u32().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(1)).to_u32().unwrap();
    texture = _texture_map[texture];

    unsafe { gl::BindTextureUnit(unit, texture) };
}

pub fn retrace_glGetTextureImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(4)).to_i32().unwrap();

    pixels = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
     buffer.resize(call.arg(4).to_u32().unwrap());
    }
    pixels = buffer.data();
    unsafe { gl::GetTextureImage(texture, level, format, _type, bufSize, pixels) };
}

pub fn retrace_glGetCompressedTextureImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(2)).to_i32().unwrap();

    pixels = (call.arg(3)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetCompressedTextureImage(texture, level, bufSize, pixels) };
}

pub fn retrace_glCreateVertexArrays(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let arrays: &mut [GLuint];
    arrays = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::CreateVertexArrays(n, arrays) };
    let _aGLuint146 = (call.arg(1)).to_array();
    if (_aGLuint146) {
        for _jGLuint146 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint146.values[_jGLuint146]).to_u32().unwrap();
    _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][_origResult] = arrays[_jGLuint146];
        }
    }
}

pub fn retrace_glDisableVertexArrayAttrib(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::DisableVertexArrayAttrib(vaobj, index) };
}

pub fn retrace_glEnableVertexArrayAttrib(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::EnableVertexArrayAttrib(vaobj, index) };
}

pub fn retrace_glVertexArrayElementBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::VertexArrayElementBuffer(vaobj, buffer) };
}

pub fn retrace_glVertexArrayVertexBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut bindingindex: GLuint;
    bindingindex = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride) };
}

pub fn retrace_glVertexArrayVertexBuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut first: GLuint;
    first = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let buffers: &mut [GLuint];
    buffers = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint147_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint147_0) = _a_GLuint147_0 {
        for _jGLuint147 in 0.._a_GLuint147_0.values.len() {
    buffers[_jGLuint147] = (*_a_GLuint147_0.values[_jGLuint147]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let offsets: &mut [GLintptr];
    offsets = _allocator.alloc_array::<GLintptr>(&call.arg(4));
    let _a_GLintptr1_0 = (call.arg(4)).to_array();
    if let Some(_a_GLintptr1_0) = _a_GLintptr1_0 {
        for _jGLintptr1 in 0.._a_GLintptr1_0.values.len() {
    offsets[_jGLintptr1] = (*_a_GLintptr1_0.values[_jGLintptr1]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let strides: &mut [GLsizei];
    strides = _allocator.alloc_array::<GLsizei>(&call.arg(5));
    let _a_GLsizei9_0 = (call.arg(5)).to_array();
    if let Some(_a_GLsizei9_0) = _a_GLsizei9_0 {
        for _jGLsizei9 in 0.._a_GLsizei9_0.values.len() {
    strides[_jGLsizei9] = (*_a_GLsizei9_0.values[_jGLsizei9]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides) };
}

pub fn retrace_glVertexArrayAttribBinding(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut attribindex: GLuint;
    attribindex = (call.arg(1)).to_u32().unwrap();

    let mut bindingindex: GLuint;
    bindingindex = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::VertexArrayAttribBinding(vaobj, attribindex, bindingindex) };
}

pub fn retrace_glVertexArrayAttribFormat(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut attribindex: GLuint;
    attribindex = (call.arg(1)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(2)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(4)).to_u32().unwrap() as u8;

    let mut relativeoffset: GLuint;
    relativeoffset = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::VertexArrayAttribFormat(vaobj, attribindex, size, _type, normalized, relativeoffset) };
}

pub fn retrace_glVertexArrayAttribIFormat(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut attribindex: GLuint;
    attribindex = (call.arg(1)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(2)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut relativeoffset: GLuint;
    relativeoffset = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexArrayAttribIFormat(vaobj, attribindex, size, _type, relativeoffset) };
}

pub fn retrace_glVertexArrayAttribLFormat(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut attribindex: GLuint;
    attribindex = (call.arg(1)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(2)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut relativeoffset: GLuint;
    relativeoffset = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexArrayAttribLFormat(vaobj, attribindex, size, _type, relativeoffset) };
}

pub fn retrace_glVertexArrayBindingDivisor(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut bindingindex: GLuint;
    bindingindex = (call.arg(1)).to_u32().unwrap();

    let mut divisor: GLuint;
    divisor = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::VertexArrayBindingDivisor(vaobj, bindingindex, divisor) };
}

pub fn retrace_glCreateSamplers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let samplers: &mut [GLuint];
    samplers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::CreateSamplers(n, samplers) };
    let _aGLuint149 = (call.arg(1)).to_array();
    if (_aGLuint149) {
        for _jGLuint149 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint149.values[_jGLuint149]).to_u32().unwrap();
    _sampler_map[_origResult] = samplers[_jGLuint149];
        }
    }
}

pub fn retrace_glCreateProgramPipelines(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let pipelines: &mut [GLuint];
    pipelines = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::CreateProgramPipelines(n, pipelines) };
    let _aGLuint151 = (call.arg(1)).to_array();
    if (_aGLuint151) {
        for _jGLuint151 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint151.values[_jGLuint151]).to_u32().unwrap();
    _pipeline_map[_origResult] = pipelines[_jGLuint151];
        }
    }
}

pub fn retrace_glCreateQueries(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(2));

    unsafe { gl::CreateQueries(target, n, ids) };
    let _aGLuint153 = (call.arg(2)).to_array();
    if (_aGLuint153) {
        for _jGLuint153 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint153.values[_jGLuint153]).to_u32().unwrap();
    _query_map[_origResult] = ids[_jGLuint153];
        }
    }
}

pub fn retrace_glGetQueryBufferObjecti64v(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::GetQueryBufferObjecti64v(id, buffer, pname, offset) };
}

pub fn retrace_glGetQueryBufferObjectiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::GetQueryBufferObjectiv(id, buffer, pname, offset) };
}

pub fn retrace_glGetQueryBufferObjectui64v(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::GetQueryBufferObjectui64v(id, buffer, pname, offset) };
}

pub fn retrace_glGetQueryBufferObjectuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::GetQueryBufferObjectuiv(id, buffer, pname, offset) };
}

pub fn retrace_glDrawBuffersARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let bufs: &mut [GLenum];
    bufs = _allocator.alloc_array::<GLenum>(&call.arg(1));
    let _a_GLenum18_0 = (call.arg(1)).to_array();
    if let Some(_a_GLenum18_0) = _a_GLenum18_0 {
        for _jGLenum18 in 0.._a_GLenum18_0.values.len() {
    bufs[_jGLenum18] = (*_a_GLenum18_0.values[_jGLenum18]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DrawBuffersARB(n, bufs) };
}

pub fn retrace_glBlendEquationiARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationiARB(buf, mode) };
}

pub fn retrace_glBlendEquationSeparateiARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut modeRGB: GLenum;
    modeRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut modeAlpha: GLenum;
    modeAlpha = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationSeparateiARB(buf, modeRGB, modeAlpha) };
}

pub fn retrace_glBlendFunciARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut src: GLenum;
    src = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dst: GLenum;
    dst = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFunciARB(buf, src, dst) };
}

pub fn retrace_glBlendFuncSeparateiARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut srcRGB: GLenum;
    srcRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dstRGB: GLenum;
    dstRGB = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut srcAlpha: GLenum;
    srcAlpha = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut dstAlpha: GLenum;
    dstAlpha = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha) };
}

pub fn retrace_glDrawElementsBaseVertex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut basevertex: GLint;
    basevertex = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::DrawElementsBaseVertex(mode, count, _type, indices, basevertex) };
}

pub fn retrace_glDrawRangeElementsBaseVertex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLuint;
    start = (call.arg(1)).to_u32().unwrap();

    let mut end: GLuint;
    end = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    let mut basevertex: GLint;
    basevertex = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::DrawRangeElementsBaseVertex(mode, start, end, count, _type, indices, basevertex) };
}

pub fn retrace_glDrawElementsInstancedBaseVertex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut instancecount: GLsizei;
    instancecount = (call.arg(4)).to_i32().unwrap();

    let mut basevertex: GLint;
    basevertex = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::DrawElementsInstancedBaseVertex(mode, count, _type, indices, instancecount, basevertex) };
}

pub fn retrace_glMultiDrawElementsBaseVertex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let count: &mut [GLsizei];
    count = _allocator.alloc_array::<GLsizei>(&call.arg(1));
    let _a_GLsizei10_0 = (call.arg(1)).to_array();
    if let Some(_a_GLsizei10_0) = _a_GLsizei10_0 {
        for _jGLsizei10 in 0.._a_GLsizei10_0.values.len() {
    count[_jGLsizei10] = (*_a_GLsizei10_0.values[_jGLsizei10]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    indices = _allocator.alloc_array::< GLvoid >(&call.arg(3));
    let _a_constGLvoid232_0 = (call.arg(3)).to_array();
    if let Some(_a_constGLvoid232_0) = _a_constGLvoid232_0 {
        for _jconstGLvoid232 in 0.._a_constGLvoid232_0.values.len() {
    let indices[_jconstGLvoid232] = (*_a_constGLvoid232_0.values[_jconstGLvoid232]).to_pointer().unwrap() as *mut c_void;
        }
    }
    let params = params.as_mut_ptr();

    let mut drawcount: GLsizei;
    drawcount = (call.arg(4)).to_i32().unwrap();

    let basevertex: &mut [GLint];
    basevertex = _allocator.alloc_array::<GLint>(&call.arg(5));
    let _a_GLint181_0 = (call.arg(5)).to_array();
    if let Some(_a_GLint181_0) = _a_GLint181_0 {
        for _jGLint181 in 0.._a_GLint181_0.values.len() {
    basevertex[_jGLint181] = (*_a_GLint181_0.values[_jGLint181]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiDrawElementsBaseVertex(mode, count, _type, indices, drawcount, basevertex) };
}

pub fn retrace_glDrawArraysIndirect(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    let indirect = (call.arg(1)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::DrawArraysIndirect(mode, indirect) };
}

pub fn retrace_glDrawElementsIndirect(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    let indirect = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::DrawElementsIndirect(mode, _type, indirect) };
}

pub fn retrace_glDrawArraysInstancedARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLint;
    first = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut instancecount: GLsizei;
    instancecount = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::DrawArraysInstancedARB(mode, first, count, instancecount) };
}

pub fn retrace_glDrawElementsInstancedARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut instancecount: GLsizei;
    instancecount = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::DrawElementsInstancedARB(mode, count, _type, indices, instancecount) };
}

pub fn retrace_glFramebufferParameteri(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::FramebufferParameteri(target, pname, param) };
}

pub fn retrace_glBindRenderbuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(1)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    unsafe { gl::BindRenderbuffer(target, renderbuffer) };
}

pub fn retrace_glDeleteRenderbuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let renderbuffers: &mut [GLuint];
    renderbuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint154_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint154_0) = _a_GLuint154_0 {
        for _jGLuint154 in 0.._a_GLuint154_0.values.len() {
    renderbuffers[_jGLuint154] = (*_a_GLuint154_0.values[_jGLuint154]).to_u32().unwrap();
    renderbuffers[_jGLuint154] = _renderbuffer_map[renderbuffers[_jGLuint154]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteRenderbuffers(n, renderbuffers) };
}

pub fn retrace_glGenRenderbuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let renderbuffers: &mut [GLuint];
    renderbuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenRenderbuffers(n, renderbuffers) };
    let _aGLuint156 = (call.arg(1)).to_array();
    if (_aGLuint156) {
        for _jGLuint156 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint156.values[_jGLuint156]).to_u32().unwrap();
    _renderbuffer_map[_origResult] = renderbuffers[_jGLuint156];
        }
    }
}

pub fn retrace_glRenderbufferStorage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::RenderbufferStorage(target, internalformat, width, height) };
}

pub fn retrace_glBindFramebuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut framebuffer: GLuint;
    framebuffer = (call.arg(1)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    unsafe { gl::BindFramebuffer(target, framebuffer) };
}

pub fn retrace_glDeleteFramebuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let framebuffers: &mut [GLuint];
    framebuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint157_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint157_0) = _a_GLuint157_0 {
        for _jGLuint157 in 0.._a_GLuint157_0.values.len() {
    framebuffers[_jGLuint157] = (*_a_GLuint157_0.values[_jGLuint157]).to_u32().unwrap();
    framebuffers[_jGLuint157] = _framebuffer_map[framebuffers[_jGLuint157]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteFramebuffers(n, framebuffers) };
}

pub fn retrace_glGenFramebuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let framebuffers: &mut [GLuint];
    framebuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenFramebuffers(n, framebuffers) };
    let _aGLuint159 = (call.arg(1)).to_array();
    if (_aGLuint159) {
        for _jGLuint159 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint159.values[_jGLuint159]).to_u32().unwrap();
    _framebuffer_map[_origResult] = framebuffers[_jGLuint159];
        }
    }
}

pub fn retrace_glCheckFramebufferStatus(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::CheckFramebufferStatus(target) };

    let _origResult = call.ret.to_i32().unwrap();
}

pub fn retrace_glFramebufferTexture1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::FramebufferTexture1D(target, attachment, textarget, texture, level) };
}

pub fn retrace_glFramebufferTexture2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::FramebufferTexture2D(target, attachment, textarget, texture, level) };
}

pub fn retrace_glFramebufferTexture3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::FramebufferTexture3D(target, attachment, textarget, texture, level, zoffset) };
}

pub fn retrace_glFramebufferRenderbuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffertarget: GLenum;
    renderbuffertarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(3)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    unsafe { gl::FramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) };
}

pub fn retrace_glGenerateMipmap(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::GenerateMipmap(target) };
}

pub fn retrace_glBlitFramebuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut srcX0: GLint;
    srcX0 = (call.arg(0)).to_i32().unwrap();

    let mut srcY0: GLint;
    srcY0 = (call.arg(1)).to_i32().unwrap();

    let mut srcX1: GLint;
    srcX1 = (call.arg(2)).to_i32().unwrap();

    let mut srcY1: GLint;
    srcY1 = (call.arg(3)).to_i32().unwrap();

    let mut dstX0: GLint;
    dstX0 = (call.arg(4)).to_i32().unwrap();

    let mut dstY0: GLint;
    dstY0 = (call.arg(5)).to_i32().unwrap();

    let mut dstX1: GLint;
    dstX1 = (call.arg(6)).to_i32().unwrap();

    let mut dstY1: GLint;
    dstY1 = (call.arg(7)).to_i32().unwrap();

    let mut mask: GLbitfield;
    mask = (call.arg(8)).to_u32().unwrap();

    let mut filter: GLenum;
    filter = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    glretrace::updateDrawable(std::max(dstX0, dstX1), std::max(dstY0, dstY1));
    unsafe { gl::BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter) };
}

pub fn retrace_glRenderbufferStorageMultisample(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::RenderbufferStorageMultisample(target, samples, internalformat, width, height) };
}

pub fn retrace_glFramebufferTextureLayer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    let mut layer: GLint;
    layer = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::FramebufferTextureLayer(target, attachment, texture, level, layer) };
}

pub fn retrace_glProgramParameteriARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLint;
    value = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ProgramParameteriARB(program, pname, value) };
}

pub fn retrace_glFramebufferTextureARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::FramebufferTextureARB(target, attachment, texture, level) };
}

pub fn retrace_glFramebufferTextureLayerARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    let mut layer: GLint;
    layer = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::FramebufferTextureLayerARB(target, attachment, texture, level, layer) };
}

pub fn retrace_glFramebufferTextureFaceARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    let mut face: GLenum;
    face = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::FramebufferTextureFaceARB(target, attachment, texture, level, face) };
}

pub fn retrace_glProgramBinary(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut binaryFormat: GLenum;
    binaryFormat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let binary: &mut [GLvoid];
    let binary = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut length: GLsizei;
    length = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::ProgramBinary(program, binaryFormat, binary, length) };
        let link_status = 0;
        gl::GetProgramiv(program, gl::LINK_STATUS, &link_status);
        if link_status == 0 {
             println!("link failed");
        }
        let info_log_length = 0;
        gl::GetProgramiv(program, gl::INFO_LOG_LENGTH, &info_log_length);
        if info_log_length > 1 {
             let infoLog = vec![0i8; info_log_length].as_mut_ptr();
             gl::GetProgramInfoLog(program, info_log_length, std::ptr::null_mut(), infoLog);
        }
}

pub fn retrace_glProgramParameteri(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLint;
    value = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ProgramParameteri(program, pname, value) };
}

pub fn retrace_glGetTextureSubImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(10)).to_i32().unwrap();

    pixels = (call.arg(11)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, _type, bufSize, pixels) };
}

pub fn retrace_glGetCompressedTextureSubImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(8)).to_i32().unwrap();

    pixels = (call.arg(9)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels) };
}

pub fn retrace_glSpecializeShaderARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut shader: GLuint;
    shader = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    let pEntryPoint: &mut [GLchar];
    pEntryPoint = (GLchar *)((call.arg(1)).to_string().unwrap());

    let mut numSpecializationConstants: GLuint;
    numSpecializationConstants = (call.arg(2)).to_u32().unwrap();

    let pConstantIndex: &mut [GLuint];
    pConstantIndex = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint160_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint160_0) = _a_GLuint160_0 {
        for _jGLuint160 in 0.._a_GLuint160_0.values.len() {
    pConstantIndex[_jGLuint160] = (*_a_GLuint160_0.values[_jGLuint160]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let pConstantValue: &mut [GLuint];
    pConstantValue = _allocator.alloc_array::<GLuint>(&call.arg(4));
    let _a_GLuint161_0 = (call.arg(4)).to_array();
    if let Some(_a_GLuint161_0) = _a_GLuint161_0 {
        for _jGLuint161 in 0.._a_GLuint161_0.values.len() {
    pConstantValue[_jGLuint161] = (*_a_GLuint161_0.values[_jGLuint161]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue) };
}

pub fn retrace_glUniform1d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::Uniform1d(location, x) };
}

pub fn retrace_glUniform2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::Uniform2d(location, x, y) };
}

pub fn retrace_glUniform3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::Uniform3d(location, x, y, z) };
}

pub fn retrace_glUniform4d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::Uniform4d(location, x, y, z, w) };
}

pub fn retrace_glUniform1dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble57_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble57_0) = _a_GLdouble57_0 {
        for _jGLdouble57 in 0.._a_GLdouble57_0.values.len() {
    value[_jGLdouble57] = (*_a_GLdouble57_0.values[_jGLdouble57]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1dv(location, count, value) };
}

pub fn retrace_glUniform2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble58_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble58_0) = _a_GLdouble58_0 {
        for _jGLdouble58 in 0.._a_GLdouble58_0.values.len() {
    value[_jGLdouble58] = (*_a_GLdouble58_0.values[_jGLdouble58]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2dv(location, count, value) };
}

pub fn retrace_glUniform3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble59_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble59_0) = _a_GLdouble59_0 {
        for _jGLdouble59 in 0.._a_GLdouble59_0.values.len() {
    value[_jGLdouble59] = (*_a_GLdouble59_0.values[_jGLdouble59]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3dv(location, count, value) };
}

pub fn retrace_glUniform4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble60_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble60_0) = _a_GLdouble60_0 {
        for _jGLdouble60 in 0.._a_GLdouble60_0.values.len() {
    value[_jGLdouble60] = (*_a_GLdouble60_0.values[_jGLdouble60]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4dv(location, count, value) };
}

pub fn retrace_glUniformMatrix2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble61_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble61_0) = _a_GLdouble61_0 {
        for _jGLdouble61 in 0.._a_GLdouble61_0.values.len() {
    value[_jGLdouble61] = (*_a_GLdouble61_0.values[_jGLdouble61]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix2dv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble62_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble62_0) = _a_GLdouble62_0 {
        for _jGLdouble62 in 0.._a_GLdouble62_0.values.len() {
    value[_jGLdouble62] = (*_a_GLdouble62_0.values[_jGLdouble62]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix3dv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble63_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble63_0) = _a_GLdouble63_0 {
        for _jGLdouble63 in 0.._a_GLdouble63_0.values.len() {
    value[_jGLdouble63] = (*_a_GLdouble63_0.values[_jGLdouble63]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix4dv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix2x3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble64_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble64_0) = _a_GLdouble64_0 {
        for _jGLdouble64 in 0.._a_GLdouble64_0.values.len() {
    value[_jGLdouble64] = (*_a_GLdouble64_0.values[_jGLdouble64]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix2x3dv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix2x4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble65_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble65_0) = _a_GLdouble65_0 {
        for _jGLdouble65 in 0.._a_GLdouble65_0.values.len() {
    value[_jGLdouble65] = (*_a_GLdouble65_0.values[_jGLdouble65]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix2x4dv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix3x2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble66_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble66_0) = _a_GLdouble66_0 {
        for _jGLdouble66 in 0.._a_GLdouble66_0.values.len() {
    value[_jGLdouble66] = (*_a_GLdouble66_0.values[_jGLdouble66]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix3x2dv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix3x4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble67_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble67_0) = _a_GLdouble67_0 {
        for _jGLdouble67 in 0.._a_GLdouble67_0.values.len() {
    value[_jGLdouble67] = (*_a_GLdouble67_0.values[_jGLdouble67]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix3x4dv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix4x2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble68_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble68_0) = _a_GLdouble68_0 {
        for _jGLdouble68 in 0.._a_GLdouble68_0.values.len() {
    value[_jGLdouble68] = (*_a_GLdouble68_0.values[_jGLdouble68]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix4x2dv(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix4x3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble69_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble69_0) = _a_GLdouble69_0 {
        for _jGLdouble69 in 0.._a_GLdouble69_0.values.len() {
    value[_jGLdouble69] = (*_a_GLdouble69_0.values[_jGLdouble69]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix4x3dv(location, count, transpose, value) };
}

pub fn retrace_glUniform1i64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64;
    x = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::Uniform1i64ARB(location, x) };
}

pub fn retrace_glUniform2i64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint64;
    y = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Uniform2i64ARB(location, x, y) };
}

pub fn retrace_glUniform3i64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint64;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint64;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Uniform3i64ARB(location, x, y, z) };
}

pub fn retrace_glUniform4i64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint64;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint64;
    z = (call.arg(3)).to_i32().unwrap();

    let mut w: GLint64;
    w = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::Uniform4i64ARB(location, x, y, z, w) };
}

pub fn retrace_glUniform1i64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint64];
    value = _allocator.alloc_array::<GLint64>(&call.arg(2));
    let _a_GLint6414_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint6414_0) = _a_GLint6414_0 {
        for _jGLint6414 in 0.._a_GLint6414_0.values.len() {
    value[_jGLint6414] = (*_a_GLint6414_0.values[_jGLint6414]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1i64vARB(location, count, value) };
}

pub fn retrace_glUniform2i64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint64];
    value = _allocator.alloc_array::<GLint64>(&call.arg(2));
    let _a_GLint6415_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint6415_0) = _a_GLint6415_0 {
        for _jGLint6415 in 0.._a_GLint6415_0.values.len() {
    value[_jGLint6415] = (*_a_GLint6415_0.values[_jGLint6415]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2i64vARB(location, count, value) };
}

pub fn retrace_glUniform3i64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint64];
    value = _allocator.alloc_array::<GLint64>(&call.arg(2));
    let _a_GLint6416_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint6416_0) = _a_GLint6416_0 {
        for _jGLint6416 in 0.._a_GLint6416_0.values.len() {
    value[_jGLint6416] = (*_a_GLint6416_0.values[_jGLint6416]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3i64vARB(location, count, value) };
}

pub fn retrace_glUniform4i64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint64];
    value = _allocator.alloc_array::<GLint64>(&call.arg(2));
    let _a_GLint6417_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint6417_0) = _a_GLint6417_0 {
        for _jGLint6417 in 0.._a_GLint6417_0.values.len() {
    value[_jGLint6417] = (*_a_GLint6417_0.values[_jGLint6417]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4i64vARB(location, count, value) };
}

pub fn retrace_glUniform1ui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64;
    x = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::Uniform1ui64ARB(location, x) };
}

pub fn retrace_glUniform2ui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint64;
    y = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::Uniform2ui64ARB(location, x, y) };
}

pub fn retrace_glUniform3ui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint64;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLuint64;
    z = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::Uniform3ui64ARB(location, x, y, z) };
}

pub fn retrace_glUniform4ui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint64;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLuint64;
    z = (call.arg(3)).to_u32().unwrap();

    let mut w: GLuint64;
    w = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::Uniform4ui64ARB(location, x, y, z, w) };
}

pub fn retrace_glUniform1ui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64];
    value = _allocator.alloc_array::<GLuint64>(&call.arg(2));
    let _a_GLuint6411_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint6411_0) = _a_GLuint6411_0 {
        for _jGLuint6411 in 0.._a_GLuint6411_0.values.len() {
    value[_jGLuint6411] = (*_a_GLuint6411_0.values[_jGLuint6411]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1ui64vARB(location, count, value) };
}

pub fn retrace_glUniform2ui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64];
    value = _allocator.alloc_array::<GLuint64>(&call.arg(2));
    let _a_GLuint6412_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint6412_0) = _a_GLuint6412_0 {
        for _jGLuint6412 in 0.._a_GLuint6412_0.values.len() {
    value[_jGLuint6412] = (*_a_GLuint6412_0.values[_jGLuint6412]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2ui64vARB(location, count, value) };
}

pub fn retrace_glUniform3ui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64];
    value = _allocator.alloc_array::<GLuint64>(&call.arg(2));
    let _a_GLuint6413_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint6413_0) = _a_GLuint6413_0 {
        for _jGLuint6413 in 0.._a_GLuint6413_0.values.len() {
    value[_jGLuint6413] = (*_a_GLuint6413_0.values[_jGLuint6413]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3ui64vARB(location, count, value) };
}

pub fn retrace_glUniform4ui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64];
    value = _allocator.alloc_array::<GLuint64>(&call.arg(2));
    let _a_GLuint6414_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint6414_0) = _a_GLuint6414_0 {
        for _jGLuint6414 in 0.._a_GLuint6414_0.values.len() {
    value[_jGLuint6414] = (*_a_GLuint6414_0.values[_jGLuint6414]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4ui64vARB(location, count, value) };
}

pub fn retrace_glProgramUniform1i64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64;
    x = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ProgramUniform1i64ARB(program, location, x) };
}

pub fn retrace_glProgramUniform2i64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint64;
    y = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::ProgramUniform2i64ARB(program, location, x, y) };
}

pub fn retrace_glProgramUniform3i64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint64;
    y = (call.arg(3)).to_i32().unwrap();

    let mut z: GLint64;
    z = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::ProgramUniform3i64ARB(program, location, x, y, z) };
}

pub fn retrace_glProgramUniform4i64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint64;
    y = (call.arg(3)).to_i32().unwrap();

    let mut z: GLint64;
    z = (call.arg(4)).to_i32().unwrap();

    let mut w: GLint64;
    w = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::ProgramUniform4i64ARB(program, location, x, y, z, w) };
}

pub fn retrace_glProgramUniform1i64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint64];
    value = _allocator.alloc_array::<GLint64>(&call.arg(3));
    let _a_GLint6418_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint6418_0) = _a_GLint6418_0 {
        for _jGLint6418 in 0.._a_GLint6418_0.values.len() {
    value[_jGLint6418] = (*_a_GLint6418_0.values[_jGLint6418]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1i64vARB(program, location, count, value) };
}

pub fn retrace_glProgramUniform2i64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint64];
    value = _allocator.alloc_array::<GLint64>(&call.arg(3));
    let _a_GLint6419_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint6419_0) = _a_GLint6419_0 {
        for _jGLint6419 in 0.._a_GLint6419_0.values.len() {
    value[_jGLint6419] = (*_a_GLint6419_0.values[_jGLint6419]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2i64vARB(program, location, count, value) };
}

pub fn retrace_glProgramUniform3i64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint64];
    value = _allocator.alloc_array::<GLint64>(&call.arg(3));
    let _a_GLint6420_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint6420_0) = _a_GLint6420_0 {
        for _jGLint6420 in 0.._a_GLint6420_0.values.len() {
    value[_jGLint6420] = (*_a_GLint6420_0.values[_jGLint6420]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3i64vARB(program, location, count, value) };
}

pub fn retrace_glProgramUniform4i64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint64];
    value = _allocator.alloc_array::<GLint64>(&call.arg(3));
    let _a_GLint6421_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint6421_0) = _a_GLint6421_0 {
        for _jGLint6421 in 0.._a_GLint6421_0.values.len() {
    value[_jGLint6421] = (*_a_GLint6421_0.values[_jGLint6421]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4i64vARB(program, location, count, value) };
}

pub fn retrace_glProgramUniform1ui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64;
    x = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::ProgramUniform1ui64ARB(program, location, x) };
}

pub fn retrace_glProgramUniform2ui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64;
    x = (call.arg(2)).to_u32().unwrap();

    let mut y: GLuint64;
    y = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::ProgramUniform2ui64ARB(program, location, x, y) };
}

pub fn retrace_glProgramUniform3ui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64;
    x = (call.arg(2)).to_u32().unwrap();

    let mut y: GLuint64;
    y = (call.arg(3)).to_u32().unwrap();

    let mut z: GLuint64;
    z = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::ProgramUniform3ui64ARB(program, location, x, y, z) };
}

pub fn retrace_glProgramUniform4ui64ARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64;
    x = (call.arg(2)).to_u32().unwrap();

    let mut y: GLuint64;
    y = (call.arg(3)).to_u32().unwrap();

    let mut z: GLuint64;
    z = (call.arg(4)).to_u32().unwrap();

    let mut w: GLuint64;
    w = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::ProgramUniform4ui64ARB(program, location, x, y, z, w) };
}

pub fn retrace_glProgramUniform1ui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint64];
    value = _allocator.alloc_array::<GLuint64>(&call.arg(3));
    let _a_GLuint6415_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint6415_0) = _a_GLuint6415_0 {
        for _jGLuint6415 in 0.._a_GLuint6415_0.values.len() {
    value[_jGLuint6415] = (*_a_GLuint6415_0.values[_jGLuint6415]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1ui64vARB(program, location, count, value) };
}

pub fn retrace_glProgramUniform2ui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint64];
    value = _allocator.alloc_array::<GLuint64>(&call.arg(3));
    let _a_GLuint6416_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint6416_0) = _a_GLuint6416_0 {
        for _jGLuint6416 in 0.._a_GLuint6416_0.values.len() {
    value[_jGLuint6416] = (*_a_GLuint6416_0.values[_jGLuint6416]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2ui64vARB(program, location, count, value) };
}

pub fn retrace_glProgramUniform3ui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint64];
    value = _allocator.alloc_array::<GLuint64>(&call.arg(3));
    let _a_GLuint6417_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint6417_0) = _a_GLuint6417_0 {
        for _jGLuint6417 in 0.._a_GLuint6417_0.values.len() {
    value[_jGLuint6417] = (*_a_GLuint6417_0.values[_jGLuint6417]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3ui64vARB(program, location, count, value) };
}

pub fn retrace_glProgramUniform4ui64vARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint64];
    value = _allocator.alloc_array::<GLuint64>(&call.arg(3));
    let _a_GLuint6418_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint6418_0) = _a_GLuint6418_0 {
        for _jGLuint6418 in 0.._a_GLuint6418_0.values.len() {
    value[_jGLuint6418] = (*_a_GLuint6418_0.values[_jGLuint6418]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4ui64vARB(program, location, count, value) };
}

pub fn retrace_glMultiDrawArraysIndirectCountARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    let indirect = (call.arg(1)).to_pointer().unwrap() as *mut c_void;

    let mut drawcount: GLintptr;
    drawcount = (call.arg(2)).to_i32().unwrap();

    let mut maxdrawcount: GLsizei;
    maxdrawcount = (call.arg(3)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiDrawArraysIndirectCountARB(mode, indirect, drawcount, maxdrawcount, stride) };
}

pub fn retrace_glMultiDrawElementsIndirectCountARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    let indirect = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut drawcount: GLintptr;
    drawcount = (call.arg(3)).to_i32().unwrap();

    let mut maxdrawcount: GLsizei;
    maxdrawcount = (call.arg(4)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::MultiDrawElementsIndirectCountARB(mode, _type, indirect, drawcount, maxdrawcount, stride) };
}

pub fn retrace_glVertexAttribDivisorARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut divisor: GLuint;
    divisor = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexAttribDivisorARB(index, divisor) };
}

pub fn retrace_glInvalidateTexSubImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    unsafe { gl::InvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth) };
}

pub fn retrace_glInvalidateTexImage(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::InvalidateTexImage(texture, level) };
}

pub fn retrace_glInvalidateBufferSubData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut length: GLsizeiptr;
    length = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::InvalidateBufferSubData(buffer, offset, length) };
}

pub fn retrace_glInvalidateBufferData(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::InvalidateBufferData(buffer) };
}

pub fn retrace_glInvalidateFramebuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut numAttachments: GLsizei;
    numAttachments = (call.arg(1)).to_i32().unwrap();

    let attachments: &mut [GLenum];
    attachments = _allocator.alloc_array::<GLenum>(&call.arg(2));
    let _a_GLenum19_0 = (call.arg(2)).to_array();
    if let Some(_a_GLenum19_0) = _a_GLenum19_0 {
        for _jGLenum19 in 0.._a_GLenum19_0.values.len() {
    attachments[_jGLenum19] = (*_a_GLenum19_0.values[_jGLenum19]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::InvalidateFramebuffer(target, numAttachments, attachments) };
}

pub fn retrace_glInvalidateSubFramebuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut numAttachments: GLsizei;
    numAttachments = (call.arg(1)).to_i32().unwrap();

    let attachments: &mut [GLenum];
    attachments = _allocator.alloc_array::<GLenum>(&call.arg(2));
    let _a_GLenum20_0 = (call.arg(2)).to_array();
    if let Some(_a_GLenum20_0) = _a_GLenum20_0 {
        for _jGLenum20 in 0.._a_GLenum20_0.values.len() {
    attachments[_jGLenum20] = (*_a_GLenum20_0.values[_jGLenum20]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut x: GLint;
    x = (call.arg(3)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::InvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height) };
}

pub fn retrace_glMapBufferRange(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut length: GLsizeiptr;
    length = (call.arg(2)).to_i32().unwrap();

    let mut access: GLbitfield;
    access = (call.arg(3)).to_u32().unwrap();

    let _result = unsafe { gl::MapBufferRange(target, offset, length, access) };

    retrace::addRegion(call, (*call.ret).toUIntPtr(), _result, length);
}

pub fn retrace_glFlushMappedBufferRange(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut length: GLsizeiptr;
    length = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::FlushMappedBufferRange(target, offset, length) };
}

pub fn retrace_glCurrentPaletteMatrixARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLint;
    index = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::CurrentPaletteMatrixARB(index) };
}

pub fn retrace_glMatrixIndexubvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let indices: &mut [GLubyte];
    indices = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte15_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte15_0) = _a_GLubyte15_0 {
        for _jGLubyte15 in 0.._a_GLubyte15_0.values.len() {
    indices[_jGLubyte15] = (*_a_GLubyte15_0.values[_jGLubyte15]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixIndexubvARB(size, indices) };
}

pub fn retrace_glMatrixIndexusvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let indices: &mut [GLushort];
    indices = _allocator.alloc_array::<GLushort>(&call.arg(1));
    let _a_GLushort12_0 = (call.arg(1)).to_array();
    if let Some(_a_GLushort12_0) = _a_GLushort12_0 {
        for _jGLushort12 in 0.._a_GLushort12_0.values.len() {
    indices[_jGLushort12] = (*_a_GLushort12_0.values[_jGLushort12]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixIndexusvARB(size, indices) };
}

pub fn retrace_glMatrixIndexuivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let indices: &mut [GLuint];
    indices = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint162_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint162_0) = _a_GLuint162_0 {
        for _jGLuint162 in 0.._a_GLuint162_0.values.len() {
    indices[_jGLuint162] = (*_a_GLuint162_0.values[_jGLuint162]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixIndexuivARB(size, indices) };
}

pub fn retrace_glMatrixIndexPointerARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::MatrixIndexPointerARB(size, _type, stride, pointer) };
}

pub fn retrace_glBindBuffersBase(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLuint;
    first = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let buffers: &mut [GLuint];
    buffers = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint163_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint163_0) = _a_GLuint163_0 {
        for _jGLuint163 in 0.._a_GLuint163_0.values.len() {
    buffers[_jGLuint163] = (*_a_GLuint163_0.values[_jGLuint163]).to_u32().unwrap();
    buffers[_jGLuint163] = _buffer_map[buffers[_jGLuint163]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::BindBuffersBase(target, first, count, buffers) };
}

pub fn retrace_glBindBuffersRange(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLuint;
    first = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let buffers: &mut [GLuint];
    buffers = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint164_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint164_0) = _a_GLuint164_0 {
        for _jGLuint164 in 0.._a_GLuint164_0.values.len() {
    buffers[_jGLuint164] = (*_a_GLuint164_0.values[_jGLuint164]).to_u32().unwrap();
    buffers[_jGLuint164] = _buffer_map[buffers[_jGLuint164]];
        }
    }
    let params = params.as_mut_ptr();

    let offsets: &mut [GLintptr];
    offsets = _allocator.alloc_array::<GLintptr>(&call.arg(4));
    let _a_GLintptr2_0 = (call.arg(4)).to_array();
    if let Some(_a_GLintptr2_0) = _a_GLintptr2_0 {
        for _jGLintptr2 in 0.._a_GLintptr2_0.values.len() {
    offsets[_jGLintptr2] = (*_a_GLintptr2_0.values[_jGLintptr2]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let sizes: &mut [GLsizeiptr];
    sizes = _allocator.alloc_array::<GLsizeiptr>(&call.arg(5));
    let _a_GLsizeiptr1_0 = (call.arg(5)).to_array();
    if let Some(_a_GLsizeiptr1_0) = _a_GLsizeiptr1_0 {
        for _jGLsizeiptr1 in 0.._a_GLsizeiptr1_0.values.len() {
    sizes[_jGLsizeiptr1] = (*_a_GLsizeiptr1_0.values[_jGLsizeiptr1]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::BindBuffersRange(target, first, count, buffers, offsets, sizes) };
}

pub fn retrace_glBindTextures(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLuint;
    first = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let textures: &mut [GLuint];
    textures = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint165_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint165_0) = _a_GLuint165_0 {
        for _jGLuint165 in 0.._a_GLuint165_0.values.len() {
    textures[_jGLuint165] = (*_a_GLuint165_0.values[_jGLuint165]).to_u32().unwrap();
    textures[_jGLuint165] = _texture_map[textures[_jGLuint165]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::BindTextures(first, count, textures) };
}

pub fn retrace_glBindSamplers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLuint;
    first = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let samplers: &mut [GLuint];
    samplers = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint166_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint166_0) = _a_GLuint166_0 {
        for _jGLuint166 in 0.._a_GLuint166_0.values.len() {
    samplers[_jGLuint166] = (*_a_GLuint166_0.values[_jGLuint166]).to_u32().unwrap();
    samplers[_jGLuint166] = _sampler_map[samplers[_jGLuint166]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::BindSamplers(first, count, samplers) };
}

pub fn retrace_glBindImageTextures(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLuint;
    first = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let textures: &mut [GLuint];
    textures = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint167_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint167_0) = _a_GLuint167_0 {
        for _jGLuint167 in 0.._a_GLuint167_0.values.len() {
    textures[_jGLuint167] = (*_a_GLuint167_0.values[_jGLuint167]).to_u32().unwrap();
    textures[_jGLuint167] = _texture_map[textures[_jGLuint167]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::BindImageTextures(first, count, textures) };
}

pub fn retrace_glBindVertexBuffers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLuint;
    first = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let buffers: &mut [GLuint];
    buffers = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint168_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint168_0) = _a_GLuint168_0 {
        for _jGLuint168 in 0.._a_GLuint168_0.values.len() {
    buffers[_jGLuint168] = (*_a_GLuint168_0.values[_jGLuint168]).to_u32().unwrap();
    buffers[_jGLuint168] = _buffer_map[buffers[_jGLuint168]];
        }
    }
    let params = params.as_mut_ptr();

    let offsets: &mut [GLintptr];
    offsets = _allocator.alloc_array::<GLintptr>(&call.arg(3));
    let _a_GLintptr3_0 = (call.arg(3)).to_array();
    if let Some(_a_GLintptr3_0) = _a_GLintptr3_0 {
        for _jGLintptr3 in 0.._a_GLintptr3_0.values.len() {
    offsets[_jGLintptr3] = (*_a_GLintptr3_0.values[_jGLintptr3]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let strides: &mut [GLsizei];
    strides = _allocator.alloc_array::<GLsizei>(&call.arg(4));
    let _a_GLsizei11_0 = (call.arg(4)).to_array();
    if let Some(_a_GLsizei11_0) = _a_GLsizei11_0 {
        for _jGLsizei11 in 0.._a_GLsizei11_0.values.len() {
    strides[_jGLsizei11] = (*_a_GLsizei11_0.values[_jGLsizei11]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::BindVertexBuffers(first, count, buffers, offsets, strides) };
}

pub fn retrace_glMultiDrawArraysIndirect(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    let indirect = (call.arg(1)).to_pointer().unwrap() as *mut c_void;

    let mut drawcount: GLsizei;
    drawcount = (call.arg(2)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiDrawArraysIndirect(mode, indirect, drawcount, stride) };
}

pub fn retrace_glMultiDrawElementsIndirect(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    let indirect = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut drawcount: GLsizei;
    drawcount = (call.arg(3)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiDrawElementsIndirect(mode, _type, indirect, drawcount, stride) };
}

pub fn retrace_glSampleCoverageARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut value: GLfloat;
    value = (call.arg(0)).to_f32().unwrap();

    let mut invert: GLboolean;
    invert = (call.arg(1)).to_u32().unwrap() as u8;

    unsafe { gl::SampleCoverageARB(value, invert) };
}

pub fn retrace_glActiveTextureARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ActiveTextureARB(texture) };
}

pub fn retrace_glClientActiveTextureARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ClientActiveTextureARB(texture) };
}

pub fn retrace_glMultiTexCoord1dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLdouble;
    s = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::MultiTexCoord1dARB(target, s) };
}

pub fn retrace_glMultiTexCoord1dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_PGLdouble7_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLdouble7_0.values[0]).to_f64().unwrap();

    unsafe { gl::MultiTexCoord1dvARB(target, v) };
}

pub fn retrace_glMultiTexCoord1fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::MultiTexCoord1fARB(target, s) };
}

pub fn retrace_glMultiTexCoord1fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_PGLfloat17_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLfloat17_0.values[0]).to_f32().unwrap();

    unsafe { gl::MultiTexCoord1fvARB(target, v) };
}

pub fn retrace_glMultiTexCoord1iARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLint;
    s = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord1iARB(target, s) };
}

pub fn retrace_glMultiTexCoord1ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_PGLint33_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLint33_0.values[0]).to_i32().unwrap();

    unsafe { gl::MultiTexCoord1ivARB(target, v) };
}

pub fn retrace_glMultiTexCoord1sARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLshort;
    s = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord1sARB(target, s) };
}

pub fn retrace_glMultiTexCoord1svARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_PGLshort4_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLshort4_0.values[0]).to_i32().unwrap();

    unsafe { gl::MultiTexCoord1svARB(target, v) };
}

pub fn retrace_glMultiTexCoord2dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLdouble;
    s = (call.arg(1)).to_f64().unwrap();

    let mut t: GLdouble;
    t = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::MultiTexCoord2dARB(target, s, t) };
}

pub fn retrace_glMultiTexCoord2dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble70_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble70_0) = _a_GLdouble70_0 {
        for _jGLdouble70 in 0.._a_GLdouble70_0.values.len() {
    v[_jGLdouble70] = (*_a_GLdouble70_0.values[_jGLdouble70]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord2dvARB(target, v) };
}

pub fn retrace_glMultiTexCoord2fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::MultiTexCoord2fARB(target, s, t) };
}

pub fn retrace_glMultiTexCoord2fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat149_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat149_0) = _a_GLfloat149_0 {
        for _jGLfloat149 in 0.._a_GLfloat149_0.values.len() {
    v[_jGLfloat149] = (*_a_GLfloat149_0.values[_jGLfloat149]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord2fvARB(target, v) };
}

pub fn retrace_glMultiTexCoord2iARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLint;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLint;
    t = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord2iARB(target, s, t) };
}

pub fn retrace_glMultiTexCoord2ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint182_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint182_0) = _a_GLint182_0 {
        for _jGLint182 in 0.._a_GLint182_0.values.len() {
    v[_jGLint182] = (*_a_GLint182_0.values[_jGLint182]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord2ivARB(target, v) };
}

pub fn retrace_glMultiTexCoord2sARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLshort;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLshort;
    t = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord2sARB(target, s, t) };
}

pub fn retrace_glMultiTexCoord2svARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort26_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort26_0) = _a_GLshort26_0 {
        for _jGLshort26 in 0.._a_GLshort26_0.values.len() {
    v[_jGLshort26] = (*_a_GLshort26_0.values[_jGLshort26]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord2svARB(target, v) };
}

pub fn retrace_glMultiTexCoord3dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLdouble;
    s = (call.arg(1)).to_f64().unwrap();

    let mut t: GLdouble;
    t = (call.arg(2)).to_f64().unwrap();

    let mut r: GLdouble;
    r = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::MultiTexCoord3dARB(target, s, t, r) };
}

pub fn retrace_glMultiTexCoord3dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble71_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble71_0) = _a_GLdouble71_0 {
        for _jGLdouble71 in 0.._a_GLdouble71_0.values.len() {
    v[_jGLdouble71] = (*_a_GLdouble71_0.values[_jGLdouble71]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord3dvARB(target, v) };
}

pub fn retrace_glMultiTexCoord3fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(2)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::MultiTexCoord3fARB(target, s, t, r) };
}

pub fn retrace_glMultiTexCoord3fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat150_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat150_0) = _a_GLfloat150_0 {
        for _jGLfloat150 in 0.._a_GLfloat150_0.values.len() {
    v[_jGLfloat150] = (*_a_GLfloat150_0.values[_jGLfloat150]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord3fvARB(target, v) };
}

pub fn retrace_glMultiTexCoord3iARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLint;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLint;
    t = (call.arg(2)).to_i32().unwrap();

    let mut r: GLint;
    r = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord3iARB(target, s, t, r) };
}

pub fn retrace_glMultiTexCoord3ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint183_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint183_0) = _a_GLint183_0 {
        for _jGLint183 in 0.._a_GLint183_0.values.len() {
    v[_jGLint183] = (*_a_GLint183_0.values[_jGLint183]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord3ivARB(target, v) };
}

pub fn retrace_glMultiTexCoord3sARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLshort;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLshort;
    t = (call.arg(2)).to_i32().unwrap();

    let mut r: GLshort;
    r = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord3sARB(target, s, t, r) };
}

pub fn retrace_glMultiTexCoord3svARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort27_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort27_0) = _a_GLshort27_0 {
        for _jGLshort27 in 0.._a_GLshort27_0.values.len() {
    v[_jGLshort27] = (*_a_GLshort27_0.values[_jGLshort27]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord3svARB(target, v) };
}

pub fn retrace_glMultiTexCoord4dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLdouble;
    s = (call.arg(1)).to_f64().unwrap();

    let mut t: GLdouble;
    t = (call.arg(2)).to_f64().unwrap();

    let mut r: GLdouble;
    r = (call.arg(3)).to_f64().unwrap();

    let mut q: GLdouble;
    q = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::MultiTexCoord4dARB(target, s, t, r, q) };
}

pub fn retrace_glMultiTexCoord4dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble72_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble72_0) = _a_GLdouble72_0 {
        for _jGLdouble72 in 0.._a_GLdouble72_0.values.len() {
    v[_jGLdouble72] = (*_a_GLdouble72_0.values[_jGLdouble72]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord4dvARB(target, v) };
}

pub fn retrace_glMultiTexCoord4fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(2)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(3)).to_f32().unwrap();

    let mut q: GLfloat;
    q = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::MultiTexCoord4fARB(target, s, t, r, q) };
}

pub fn retrace_glMultiTexCoord4fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat151_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat151_0) = _a_GLfloat151_0 {
        for _jGLfloat151 in 0.._a_GLfloat151_0.values.len() {
    v[_jGLfloat151] = (*_a_GLfloat151_0.values[_jGLfloat151]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord4fvARB(target, v) };
}

pub fn retrace_glMultiTexCoord4iARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLint;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLint;
    t = (call.arg(2)).to_i32().unwrap();

    let mut r: GLint;
    r = (call.arg(3)).to_i32().unwrap();

    let mut q: GLint;
    q = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord4iARB(target, s, t, r, q) };
}

pub fn retrace_glMultiTexCoord4ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint184_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint184_0) = _a_GLint184_0 {
        for _jGLint184 in 0.._a_GLint184_0.values.len() {
    v[_jGLint184] = (*_a_GLint184_0.values[_jGLint184]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord4ivARB(target, v) };
}

pub fn retrace_glMultiTexCoord4sARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLshort;
    s = (call.arg(1)).to_i32().unwrap();

    let mut t: GLshort;
    t = (call.arg(2)).to_i32().unwrap();

    let mut r: GLshort;
    r = (call.arg(3)).to_i32().unwrap();

    let mut q: GLshort;
    q = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiTexCoord4sARB(target, s, t, r, q) };
}

pub fn retrace_glMultiTexCoord4svARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort28_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort28_0) = _a_GLshort28_0 {
        for _jGLshort28 in 0.._a_GLshort28_0.values.len() {
    v[_jGLshort28] = (*_a_GLshort28_0.values[_jGLshort28]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord4svARB(target, v) };
}

pub fn retrace_glGenQueriesARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenQueriesARB(n, ids) };
    let _aGLuint170 = (call.arg(1)).to_array();
    if (_aGLuint170) {
        for _jGLuint170 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint170.values[_jGLuint170]).to_u32().unwrap();
    _query_map[_origResult] = ids[_jGLuint170];
        }
    }
}

pub fn retrace_glDeleteQueriesARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint171_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint171_0) = _a_GLuint171_0 {
        for _jGLuint171 in 0.._a_GLuint171_0.values.len() {
    ids[_jGLuint171] = (*_a_GLuint171_0.values[_jGLuint171]).to_u32().unwrap();
    ids[_jGLuint171] = _query_map[ids[_jGLuint171]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteQueriesARB(n, ids) };
}

pub fn retrace_glBeginQueryARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _query_map[id];

    unsafe { gl::BeginQueryARB(target, id) };
}

pub fn retrace_glEndQueryARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::EndQueryARB(target) };
}

pub fn retrace_glGetQueryObjectivARB(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    GLint retval;
    if (_query_buffer)
        params = static_cast<GLint *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectivARB(id, pname, params) };
    let _aGLint186 = (call.arg(2)).to_array();
    if (_aGLint186) {
        for _jGLint186 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glGetQueryObjectuivARB(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint];
    GLuint retval;
    if (_query_buffer)
        params = static_cast<GLuint *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectuivARB(id, pname, params) };
    let _aGLuint173 = (call.arg(2)).to_array();
    if (_aGLuint173) {
        for _jGLuint173 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glMaxShaderCompilerThreadsARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut count: GLuint;
    count = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::MaxShaderCompilerThreadsARB(count) };
}

pub fn retrace_glPointParameterfARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PointParameterfARB(pname, param) };
}

pub fn retrace_glPointParameterfvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat152_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat152_0) = _a_GLfloat152_0 {
        for _jGLfloat152 in 0.._a_GLfloat152_0.values.len() {
    params[_jGLfloat152] = (*_a_GLfloat152_0.values[_jGLfloat152]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PointParameterfvARB(pname, params) };
}

pub fn retrace_glGetProgramResourceName(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut programInterface: GLenum;
    programInterface = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(3)).to_i32().unwrap();

    let length: &mut [GLsizei];
    length = _allocator.alloc_array::<GLsizei>(&call.arg(4));

    let name: &mut [GLchar];

    std::vector<GLchar> name_buf(bufSize);
    name = name_buf.data();
    const auto traced_name = (const GLchar *)((call.arg(5)).toString());
    glretrace::trackResourceName(program, programInterface, index, traced_name);
    unsafe { gl::GetProgramResourceName(program, programInterface, index, bufSize, length, name) };
    let _aPGLsizei13 = (call.arg(4)).to_array();
    if (_aPGLsizei13) {
    }
}

pub fn retrace_glGetProgramResourceiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut programInterface: GLenum;
    programInterface = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut propCount: GLsizei;
    propCount = (call.arg(3)).to_i32().unwrap();

    let props: &mut [GLenum];
    props = _allocator.alloc_array::<GLenum>(&call.arg(4));
    let _a_GLenum21_0 = (call.arg(4)).to_array();
    if let Some(_a_GLenum21_0) = _a_GLenum21_0 {
        for _jGLenum21 in 0.._a_GLenum21_0.values.len() {
    props[_jGLenum21] = (*_a_GLenum21_0.values[_jGLenum21]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(5)).to_i32().unwrap();

    let length: &mut [GLsizei];
    length = _allocator.alloc_array::<GLsizei>(&call.arg(6));

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(7));

    glretrace::mapResourceLocation(program, programInterface, index, call.arg(4).toArray(), call.arg(7).toArray(), _location_map);
    unsafe { gl::GetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, params) };
    let _aPGLsizei14 = (call.arg(6)).to_array();
    if (_aPGLsizei14) {
    }
    let _aGLint188 = (call.arg(7)).to_array();
    if (_aGLint188) {
        for _jGLint188 in 0..length {
        }
    }
}

pub fn retrace_glGetProgramResourceLocation(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut programInterface: GLenum;
    programInterface = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(2)).to_string().unwrap());

    let _result = unsafe { gl::GetProgramResourceLocation(program, programInterface, name) };

    let _origResult: GLint;
    _origResult = (*call.ret).to_i32().unwrap();
    _location_map[program][_origResult] = _result;
}

pub fn retrace_glProvokingVertex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ProvokingVertex(mode) };
}

pub fn retrace_glGetnPixelMapfvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(1)).to_i32().unwrap();

    let values: &mut [GLfloat];
    values = (call.arg(2)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnPixelMapfvARB(map, bufSize, values) };
    let _aGLfloat154 = (call.arg(2)).to_array();
    if (_aGLfloat154) {
        for _jGLfloat154 in 0..length {
        }
    }
}

pub fn retrace_glGetnPixelMapuivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(1)).to_i32().unwrap();

    let values: &mut [GLuint];
    values = (call.arg(2)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnPixelMapuivARB(map, bufSize, values) };
    let _aGLuint175 = (call.arg(2)).to_array();
    if (_aGLuint175) {
        for _jGLuint175 in 0..length {
        }
    }
}

pub fn retrace_glGetnPixelMapusvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut map: GLenum;
    map = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(1)).to_i32().unwrap();

    let values: &mut [GLushort];
    values = (call.arg(2)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnPixelMapusvARB(map, bufSize, values) };
    let _aGLushort14 = (call.arg(2)).to_array();
    if (_aGLushort14) {
        for _jGLushort14 in 0..length {
        }
    }
}

pub fn retrace_glGetnPolygonStippleARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut bufSize: GLsizei;
    bufSize = (call.arg(0)).to_i32().unwrap();

    let pattern: &mut [GLubyte];
    pattern = (call.arg(1)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnPolygonStippleARB(bufSize, pattern) };
}

pub fn retrace_glGetnConvolutionFilterARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(3)).to_i32().unwrap();

    let image: &mut [GLvoid];
    image = (call.arg(4)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnConvolutionFilterARB(target, format, _type, bufSize, image) };
}

pub fn retrace_glGetnSeparableFilterARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut rowBufSize: GLsizei;
    rowBufSize = (call.arg(3)).to_i32().unwrap();

    let row: &mut [GLvoid];
    row = (call.arg(4)).to_pointer();

    let mut columnBufSize: GLsizei;
    columnBufSize = (call.arg(5)).to_i32().unwrap();

    let column: &mut [GLvoid];
    column = (call.arg(6)).to_pointer();

    let span: &mut [GLvoid];
    span = (call.arg(7)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnSeparableFilterARB(target, format, _type, rowBufSize, row, columnBufSize, column, span) };
}

pub fn retrace_glGetnHistogramARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut reset: GLboolean;
    reset = (call.arg(1)).to_u32().unwrap() as u8;

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(4)).to_i32().unwrap();

    let values: &mut [GLvoid];
    values = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnHistogramARB(target, reset, format, _type, bufSize, values) };
}

pub fn retrace_glGetnMinmaxARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut reset: GLboolean;
    reset = (call.arg(1)).to_u32().unwrap() as u8;

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(4)).to_i32().unwrap();

    let values: &mut [GLvoid];
    values = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnMinmaxARB(target, reset, format, _type, bufSize, values) };
}

pub fn retrace_glGetnTexImageARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(4)).to_i32().unwrap();

    let img: &mut [GLvoid];
    img = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnTexImageARB(target, level, format, _type, bufSize, img) };
}

pub fn retrace_glReadnPixelsARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(6)).to_i32().unwrap();

    let data: &mut [GLvoid];
    data = (call.arg(7)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::ReadnPixelsARB(x, y, width, height, format, _type, bufSize, data) };
}

pub fn retrace_glGetnCompressedTexImageARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut lod: GLint;
    lod = (call.arg(1)).to_i32().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(2)).to_i32().unwrap();

    let img: &mut [GLvoid];
    img = (call.arg(3)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetnCompressedTexImageARB(target, lod, bufSize, img) };
}

pub fn retrace_glFramebufferSampleLocationsfvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLuint;
    start = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat155_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat155_0) = _a_GLfloat155_0 {
        for _jGLfloat155 in 0.._a_GLfloat155_0.values.len() {
    v[_jGLfloat155] = (*_a_GLfloat155_0.values[_jGLfloat155]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::FramebufferSampleLocationsfvARB(target, start, count, v) };
}

pub fn retrace_glNamedFramebufferSampleLocationsfvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut start: GLuint;
    start = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat156_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat156_0) = _a_GLfloat156_0 {
        for _jGLfloat156 in 0.._a_GLfloat156_0.values.len() {
    v[_jGLfloat156] = (*_a_GLfloat156_0.values[_jGLfloat156]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v) };
}

pub fn retrace_glEvaluateDepthValuesARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::EvaluateDepthValuesARB() };
}

pub fn retrace_glMinSampleShadingARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut value: GLfloat;
    value = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::MinSampleShadingARB(value) };
}

pub fn retrace_glGenSamplers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut count: GLsizei;
    count = (call.arg(0)).to_i32().unwrap();

    let samplers: &mut [GLuint];
    samplers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenSamplers(count, samplers) };
    let _aGLuint177 = (call.arg(1)).to_array();
    if (_aGLuint177) {
        for _jGLuint177 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint177.values[_jGLuint177]).to_u32().unwrap();
    _sampler_map[_origResult] = samplers[_jGLuint177];
        }
    }
}

pub fn retrace_glDeleteSamplers(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut count: GLsizei;
    count = (call.arg(0)).to_i32().unwrap();

    let samplers: &mut [GLuint];
    samplers = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint178_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint178_0) = _a_GLuint178_0 {
        for _jGLuint178 in 0.._a_GLuint178_0.values.len() {
    samplers[_jGLuint178] = (*_a_GLuint178_0.values[_jGLuint178]).to_u32().unwrap();
    samplers[_jGLuint178] = _sampler_map[samplers[_jGLuint178]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteSamplers(count, samplers) };
}

pub fn retrace_glBindSampler(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut unit: GLuint;
    unit = (call.arg(0)).to_u32().unwrap();

    let mut sampler: GLuint;
    sampler = (call.arg(1)).to_u32().unwrap();
    sampler = _sampler_map[sampler];

    unsafe { gl::BindSampler(unit, sampler) };
}

pub fn retrace_glSamplerParameteri(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sampler: GLuint;
    sampler = (call.arg(0)).to_u32().unwrap();
    sampler = _sampler_map[sampler];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::SamplerParameteri(sampler, pname, param) };
}

pub fn retrace_glSamplerParameteriv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sampler: GLuint;
    sampler = (call.arg(0)).to_u32().unwrap();
    sampler = _sampler_map[sampler];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let param: &mut [GLint];
    param = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint189_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint189_0) = _a_GLint189_0 {
        for _jGLint189 in 0.._a_GLint189_0.values.len() {
    param[_jGLint189] = (*_a_GLint189_0.values[_jGLint189]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SamplerParameteriv(sampler, pname, param) };
}

pub fn retrace_glSamplerParameterf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sampler: GLuint;
    sampler = (call.arg(0)).to_u32().unwrap();
    sampler = _sampler_map[sampler];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::SamplerParameterf(sampler, pname, param) };
}

pub fn retrace_glSamplerParameterfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sampler: GLuint;
    sampler = (call.arg(0)).to_u32().unwrap();
    sampler = _sampler_map[sampler];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let param: &mut [GLfloat];
    param = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat157_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat157_0) = _a_GLfloat157_0 {
        for _jGLfloat157 in 0.._a_GLfloat157_0.values.len() {
    param[_jGLfloat157] = (*_a_GLfloat157_0.values[_jGLfloat157]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SamplerParameterfv(sampler, pname, param) };
}

pub fn retrace_glSamplerParameterIiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sampler: GLuint;
    sampler = (call.arg(0)).to_u32().unwrap();
    sampler = _sampler_map[sampler];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let param: &mut [GLint];
    param = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint190_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint190_0) = _a_GLint190_0 {
        for _jGLint190 in 0.._a_GLint190_0.values.len() {
    param[_jGLint190] = (*_a_GLint190_0.values[_jGLint190]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SamplerParameterIiv(sampler, pname, param) };
}

pub fn retrace_glSamplerParameterIuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sampler: GLuint;
    sampler = (call.arg(0)).to_u32().unwrap();
    sampler = _sampler_map[sampler];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let param: &mut [GLuint];
    param = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint179_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint179_0) = _a_GLuint179_0 {
        for _jGLuint179 in 0.._a_GLuint179_0.values.len() {
    param[_jGLuint179] = (*_a_GLuint179_0.values[_jGLuint179]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SamplerParameterIuiv(sampler, pname, param) };
}

pub fn retrace_glUseProgramStages(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pipeline: GLuint;
    pipeline = (call.arg(0)).to_u32().unwrap();
    pipeline = _pipeline_map[pipeline];

    let mut stages: GLbitfield;
    stages = (call.arg(1)).to_u32().unwrap();

    let mut program: GLuint;
    program = (call.arg(2)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    unsafe { gl::UseProgramStages(pipeline, stages, program) };
}

pub fn retrace_glActiveShaderProgram(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pipeline: GLuint;
    pipeline = (call.arg(0)).to_u32().unwrap();
    pipeline = _pipeline_map[pipeline];

    let mut program: GLuint;
    program = (call.arg(1)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    unsafe { gl::ActiveShaderProgram(pipeline, program) };
}

pub fn retrace_glCreateShaderProgramv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let strings: &mut [GLchar];
    strings = _allocator.alloc_array::<GLchar >(&call.arg(2));
    let _a_GLchar29_0 = (call.arg(2)).to_array();
    if let Some(_a_GLchar29_0) = _a_GLchar29_0 {
        for _jGLchar29 in 0.._a_GLchar29_0.values.len() {
    strings[_jGLchar29] = (GLchar *)((*_a_GLchar29_0.values[_jGLchar29]).to_string().unwrap());
        }
    }
    let params = params.as_mut_ptr();

    if (retrace::dumpingState) {
        GLuint _shader = glCreateShader(type);
        if (_shader) {
            glShaderSource(_shader, count, strings, NULL);
            glCompileShader(_shader);
            const GLuint _program = glCreateProgram();
            if (_program) {
                GLint compiled = GL_FALSE;
                glGetShaderiv(_shader, GL_COMPILE_STATUS, &compiled);
                glProgramParameteri(_program, GL_PROGRAM_SEPARABLE, GL_TRUE);
                if (compiled) {
                    glAttachShader(_program, _shader);
                    glLinkProgram(_program);
                    if (false) glDetachShader(_program, _shader);
                }
                // TODO: append shader info log to program info log
            }
            glDeleteShader(_shader);
            _result = _program;
        } else {
            _result = 0;
        }
    } else {
    let _result = unsafe { gl::CreateShaderProgramv(_type, count, strings) };

    }
        let program = _result;
        let link_status = 0;
        gl::GetProgramiv(program, gl::LINK_STATUS, &link_status);
        if link_status == 0 {
             println!("link failed");
        }
        let info_log_length = 0;
        gl::GetProgramiv(program, gl::INFO_LOG_LENGTH, &info_log_length);
        if info_log_length > 1 {
             let infoLog = vec![0i8; info_log_length].as_mut_ptr();
             gl::GetProgramInfoLog(program, info_log_length, std::ptr::null_mut(), infoLog);
        }
    let _origResult: GLuint;
    _origResult = (*call.ret).to_u32().unwrap();
if (glretrace::supportsARBShaderObjects) {
    _handleARB_map[_origResult] = _result;
} else {
    _program_map[_origResult] = _result;
}
}

pub fn retrace_glBindProgramPipeline(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pipeline: GLuint;
    pipeline = (call.arg(0)).to_u32().unwrap();
    pipeline = _pipeline_map[pipeline];

    unsafe { gl::BindProgramPipeline(pipeline) };
    if (currentContext) {
        self.context.currentPipeline = pipeline;
    }
}

pub fn retrace_glDeleteProgramPipelines(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let pipelines: &mut [GLuint];
    pipelines = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint180_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint180_0) = _a_GLuint180_0 {
        for _jGLuint180 in 0.._a_GLuint180_0.values.len() {
    pipelines[_jGLuint180] = (*_a_GLuint180_0.values[_jGLuint180]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteProgramPipelines(n, pipelines) };
}

pub fn retrace_glGenProgramPipelines(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let pipelines: &mut [GLuint];
    pipelines = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenProgramPipelines(n, pipelines) };
    let _aGLuint182 = (call.arg(1)).to_array();
    if (_aGLuint182) {
        for _jGLuint182 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint182.values[_jGLuint182]).to_u32().unwrap();
    _pipeline_map[_origResult] = pipelines[_jGLuint182];
        }
    }
}

pub fn retrace_glProgramUniform1i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ProgramUniform1i(program, location, v0) };
}

pub fn retrace_glProgramUniform1iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint191_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint191_0) = _a_GLint191_0 {
        for _jGLint191 in 0.._a_GLint191_0.values.len() {
    value[_jGLint191] = (*_a_GLint191_0.values[_jGLint191]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1iv(program, location, count, value) };
}

pub fn retrace_glProgramUniform1f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::ProgramUniform1f(program, location, v0) };
}

pub fn retrace_glProgramUniform1fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat158_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat158_0) = _a_GLfloat158_0 {
        for _jGLfloat158 in 0.._a_GLfloat158_0.values.len() {
    value[_jGLfloat158] = (*_a_GLfloat158_0.values[_jGLfloat158]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1fv(program, location, count, value) };
}

pub fn retrace_glProgramUniform1d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLdouble;
    v0 = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::ProgramUniform1d(program, location, v0) };
}

pub fn retrace_glProgramUniform1dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble73_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble73_0) = _a_GLdouble73_0 {
        for _jGLdouble73 in 0.._a_GLdouble73_0.values.len() {
    value[_jGLdouble73] = (*_a_GLdouble73_0.values[_jGLdouble73]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1dv(program, location, count, value) };
}

pub fn retrace_glProgramUniform1ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::ProgramUniform1ui(program, location, v0) };
}

pub fn retrace_glProgramUniform1uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint183_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint183_0) = _a_GLuint183_0 {
        for _jGLuint183 in 0.._a_GLuint183_0.values.len() {
    value[_jGLuint183] = (*_a_GLuint183_0.values[_jGLuint183]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1uiv(program, location, count, value) };
}

pub fn retrace_glProgramUniform2i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(2)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::ProgramUniform2i(program, location, v0, v1) };
}

pub fn retrace_glProgramUniform2iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint192_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint192_0) = _a_GLint192_0 {
        for _jGLint192 in 0.._a_GLint192_0.values.len() {
    value[_jGLint192] = (*_a_GLint192_0.values[_jGLint192]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2iv(program, location, count, value) };
}

pub fn retrace_glProgramUniform2f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(2)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::ProgramUniform2f(program, location, v0, v1) };
}

pub fn retrace_glProgramUniform2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat159_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat159_0) = _a_GLfloat159_0 {
        for _jGLfloat159 in 0.._a_GLfloat159_0.values.len() {
    value[_jGLfloat159] = (*_a_GLfloat159_0.values[_jGLfloat159]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2fv(program, location, count, value) };
}

pub fn retrace_glProgramUniform2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLdouble;
    v0 = (call.arg(2)).to_f64().unwrap();

    let mut v1: GLdouble;
    v1 = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::ProgramUniform2d(program, location, v0, v1) };
}

pub fn retrace_glProgramUniform2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble74_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble74_0) = _a_GLdouble74_0 {
        for _jGLdouble74 in 0.._a_GLdouble74_0.values.len() {
    value[_jGLdouble74] = (*_a_GLdouble74_0.values[_jGLdouble74]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2dv(program, location, count, value) };
}

pub fn retrace_glProgramUniform2ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(2)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::ProgramUniform2ui(program, location, v0, v1) };
}

pub fn retrace_glProgramUniform2uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint184_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint184_0) = _a_GLuint184_0 {
        for _jGLuint184 in 0.._a_GLuint184_0.values.len() {
    value[_jGLuint184] = (*_a_GLuint184_0.values[_jGLuint184]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2uiv(program, location, count, value) };
}

pub fn retrace_glProgramUniform3i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(2)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(3)).to_i32().unwrap();

    let mut v2: GLint;
    v2 = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::ProgramUniform3i(program, location, v0, v1, v2) };
}

pub fn retrace_glProgramUniform3iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint193_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint193_0) = _a_GLint193_0 {
        for _jGLint193 in 0.._a_GLint193_0.values.len() {
    value[_jGLint193] = (*_a_GLint193_0.values[_jGLint193]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3iv(program, location, count, value) };
}

pub fn retrace_glProgramUniform3f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(2)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(3)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::ProgramUniform3f(program, location, v0, v1, v2) };
}

pub fn retrace_glProgramUniform3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat160_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat160_0) = _a_GLfloat160_0 {
        for _jGLfloat160 in 0.._a_GLfloat160_0.values.len() {
    value[_jGLfloat160] = (*_a_GLfloat160_0.values[_jGLfloat160]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3fv(program, location, count, value) };
}

pub fn retrace_glProgramUniform3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLdouble;
    v0 = (call.arg(2)).to_f64().unwrap();

    let mut v1: GLdouble;
    v1 = (call.arg(3)).to_f64().unwrap();

    let mut v2: GLdouble;
    v2 = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::ProgramUniform3d(program, location, v0, v1, v2) };
}

pub fn retrace_glProgramUniform3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble75_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble75_0) = _a_GLdouble75_0 {
        for _jGLdouble75 in 0.._a_GLdouble75_0.values.len() {
    value[_jGLdouble75] = (*_a_GLdouble75_0.values[_jGLdouble75]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3dv(program, location, count, value) };
}

pub fn retrace_glProgramUniform3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(2)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(3)).to_u32().unwrap();

    let mut v2: GLuint;
    v2 = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::ProgramUniform3ui(program, location, v0, v1, v2) };
}

pub fn retrace_glProgramUniform3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint185_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint185_0) = _a_GLuint185_0 {
        for _jGLuint185 in 0.._a_GLuint185_0.values.len() {
    value[_jGLuint185] = (*_a_GLuint185_0.values[_jGLuint185]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3uiv(program, location, count, value) };
}

pub fn retrace_glProgramUniform4i(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(2)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(3)).to_i32().unwrap();

    let mut v2: GLint;
    v2 = (call.arg(4)).to_i32().unwrap();

    let mut v3: GLint;
    v3 = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::ProgramUniform4i(program, location, v0, v1, v2, v3) };
}

pub fn retrace_glProgramUniform4iv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint194_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint194_0) = _a_GLint194_0 {
        for _jGLint194 in 0.._a_GLint194_0.values.len() {
    value[_jGLint194] = (*_a_GLint194_0.values[_jGLint194]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4iv(program, location, count, value) };
}

pub fn retrace_glProgramUniform4f(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(2)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(3)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(4)).to_f32().unwrap();

    let mut v3: GLfloat;
    v3 = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::ProgramUniform4f(program, location, v0, v1, v2, v3) };
}

pub fn retrace_glProgramUniform4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat161_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat161_0) = _a_GLfloat161_0 {
        for _jGLfloat161 in 0.._a_GLfloat161_0.values.len() {
    value[_jGLfloat161] = (*_a_GLfloat161_0.values[_jGLfloat161]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4fv(program, location, count, value) };
}

pub fn retrace_glProgramUniform4d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLdouble;
    v0 = (call.arg(2)).to_f64().unwrap();

    let mut v1: GLdouble;
    v1 = (call.arg(3)).to_f64().unwrap();

    let mut v2: GLdouble;
    v2 = (call.arg(4)).to_f64().unwrap();

    let mut v3: GLdouble;
    v3 = (call.arg(5)).to_f64().unwrap();

    unsafe { gl::ProgramUniform4d(program, location, v0, v1, v2, v3) };
}

pub fn retrace_glProgramUniform4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble76_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble76_0) = _a_GLdouble76_0 {
        for _jGLdouble76 in 0.._a_GLdouble76_0.values.len() {
    value[_jGLdouble76] = (*_a_GLdouble76_0.values[_jGLdouble76]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4dv(program, location, count, value) };
}

pub fn retrace_glProgramUniform4ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(2)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(3)).to_u32().unwrap();

    let mut v2: GLuint;
    v2 = (call.arg(4)).to_u32().unwrap();

    let mut v3: GLuint;
    v3 = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::ProgramUniform4ui(program, location, v0, v1, v2, v3) };
}

pub fn retrace_glProgramUniform4uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint186_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint186_0) = _a_GLuint186_0 {
        for _jGLuint186 in 0.._a_GLuint186_0.values.len() {
    value[_jGLuint186] = (*_a_GLuint186_0.values[_jGLuint186]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4uiv(program, location, count, value) };
}

pub fn retrace_glProgramUniformMatrix2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat162_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat162_0) = _a_GLfloat162_0 {
        for _jGLfloat162 in 0.._a_GLfloat162_0.values.len() {
    value[_jGLfloat162] = (*_a_GLfloat162_0.values[_jGLfloat162]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2fv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat163_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat163_0) = _a_GLfloat163_0 {
        for _jGLfloat163 in 0.._a_GLfloat163_0.values.len() {
    value[_jGLfloat163] = (*_a_GLfloat163_0.values[_jGLfloat163]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3fv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat164_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat164_0) = _a_GLfloat164_0 {
        for _jGLfloat164 in 0.._a_GLfloat164_0.values.len() {
    value[_jGLfloat164] = (*_a_GLfloat164_0.values[_jGLfloat164]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4fv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble77_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble77_0) = _a_GLdouble77_0 {
        for _jGLdouble77 in 0.._a_GLdouble77_0.values.len() {
    value[_jGLdouble77] = (*_a_GLdouble77_0.values[_jGLdouble77]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2dv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble78_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble78_0) = _a_GLdouble78_0 {
        for _jGLdouble78 in 0.._a_GLdouble78_0.values.len() {
    value[_jGLdouble78] = (*_a_GLdouble78_0.values[_jGLdouble78]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3dv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble79_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble79_0) = _a_GLdouble79_0 {
        for _jGLdouble79 in 0.._a_GLdouble79_0.values.len() {
    value[_jGLdouble79] = (*_a_GLdouble79_0.values[_jGLdouble79]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4dv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix2x3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat165_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat165_0) = _a_GLfloat165_0 {
        for _jGLfloat165 in 0.._a_GLfloat165_0.values.len() {
    value[_jGLfloat165] = (*_a_GLfloat165_0.values[_jGLfloat165]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2x3fv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3x2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat166_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat166_0) = _a_GLfloat166_0 {
        for _jGLfloat166 in 0.._a_GLfloat166_0.values.len() {
    value[_jGLfloat166] = (*_a_GLfloat166_0.values[_jGLfloat166]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3x2fv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix2x4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat167_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat167_0) = _a_GLfloat167_0 {
        for _jGLfloat167 in 0.._a_GLfloat167_0.values.len() {
    value[_jGLfloat167] = (*_a_GLfloat167_0.values[_jGLfloat167]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2x4fv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4x2fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat168_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat168_0) = _a_GLfloat168_0 {
        for _jGLfloat168 in 0.._a_GLfloat168_0.values.len() {
    value[_jGLfloat168] = (*_a_GLfloat168_0.values[_jGLfloat168]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4x2fv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3x4fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat169_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat169_0) = _a_GLfloat169_0 {
        for _jGLfloat169 in 0.._a_GLfloat169_0.values.len() {
    value[_jGLfloat169] = (*_a_GLfloat169_0.values[_jGLfloat169]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3x4fv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4x3fv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat170_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat170_0) = _a_GLfloat170_0 {
        for _jGLfloat170 in 0.._a_GLfloat170_0.values.len() {
    value[_jGLfloat170] = (*_a_GLfloat170_0.values[_jGLfloat170]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4x3fv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix2x3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble80_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble80_0) = _a_GLdouble80_0 {
        for _jGLdouble80 in 0.._a_GLdouble80_0.values.len() {
    value[_jGLdouble80] = (*_a_GLdouble80_0.values[_jGLdouble80]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2x3dv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3x2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble81_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble81_0) = _a_GLdouble81_0 {
        for _jGLdouble81 in 0.._a_GLdouble81_0.values.len() {
    value[_jGLdouble81] = (*_a_GLdouble81_0.values[_jGLdouble81]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3x2dv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix2x4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble82_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble82_0) = _a_GLdouble82_0 {
        for _jGLdouble82 in 0.._a_GLdouble82_0.values.len() {
    value[_jGLdouble82] = (*_a_GLdouble82_0.values[_jGLdouble82]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2x4dv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4x2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble83_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble83_0) = _a_GLdouble83_0 {
        for _jGLdouble83 in 0.._a_GLdouble83_0.values.len() {
    value[_jGLdouble83] = (*_a_GLdouble83_0.values[_jGLdouble83]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4x2dv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3x4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble84_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble84_0) = _a_GLdouble84_0 {
        for _jGLdouble84 in 0.._a_GLdouble84_0.values.len() {
    value[_jGLdouble84] = (*_a_GLdouble84_0.values[_jGLdouble84]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3x4dv(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4x3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble85_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble85_0) = _a_GLdouble85_0 {
        for _jGLdouble85 in 0.._a_GLdouble85_0.values.len() {
    value[_jGLdouble85] = (*_a_GLdouble85_0.values[_jGLdouble85]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4x3dv(program, location, count, transpose, value) };
}

pub fn retrace_glValidateProgramPipeline(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pipeline: GLuint;
    pipeline = (call.arg(0)).to_u32().unwrap();
    pipeline = _pipeline_map[pipeline];

    unsafe { gl::ValidateProgramPipeline(pipeline) };
}

pub fn retrace_glBindImageTexture(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut unit: GLuint;
    unit = (call.arg(0)).to_u32().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(1)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut layered: GLboolean;
    layered = (call.arg(3)).to_u32().unwrap() as u8;

    let mut layer: GLint;
    layer = (call.arg(4)).to_i32().unwrap();

    let mut access: GLenum;
    access = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BindImageTexture(unit, texture, level, layered, layer, access, format) };
}

pub fn retrace_glMemoryBarrier(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut barriers: GLbitfield;
    barriers = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::MemoryBarrier(barriers) };
}

pub fn retrace_glDeleteObjectARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut obj: GLhandleARB;
    obj = (call.arg(0)).to_u32().unwrap();
    obj = _handleARB_map[obj];

    unsafe { gl::DeleteObjectARB(obj) };
}

pub fn retrace_glDetachObjectARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut containerObj: GLhandleARB;
    containerObj = (call.arg(0)).to_u32().unwrap();
    containerObj = _handleARB_map[containerObj];

    let mut attachedObj: GLhandleARB;
    attachedObj = (call.arg(1)).to_u32().unwrap();
    attachedObj = _handleARB_map[attachedObj];

    if (!retrace::dumpingState) {
    unsafe { gl::DetachObjectARB(containerObj, attachedObj) };
    }
}

pub fn retrace_glCreateShaderObjectARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut shaderType: GLenum;
    shaderType = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::CreateShaderObjectARB(shaderType) };

    let _origResult: GLhandleARB;
    _origResult = (*call.ret).to_u32().unwrap();
    _handleARB_map[_origResult] = _result;
}

pub fn retrace_glShaderSourceARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut shaderObj: GLhandleARB;
    shaderObj = (call.arg(0)).to_u32().unwrap();
    shaderObj = _handleARB_map[shaderObj];

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let string: &mut [GLcharARB];
    string = _allocator.alloc_array::< GLcharARB >(&call.arg(2));
    let _a_constGLcharARB2_0 = (call.arg(2)).to_array();
    if let Some(_a_constGLcharARB2_0) = _a_constGLcharARB2_0 {
        for _jconstGLcharARB2 in 0.._a_constGLcharARB2_0.values.len() {
    string[_jconstGLcharARB2] = (const GLcharARB *)((*_a_constGLcharARB2_0.values[_jconstGLcharARB2]).to_string().unwrap());
        }
    }
    let params = params.as_mut_ptr();

    let length: &mut [GLint];
    length = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint195_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint195_0) = _a_GLint195_0 {
        for _jGLint195 in 0.._a_GLint195_0.values.len() {
    length[_jGLint195] = (*_a_GLint195_0.values[_jGLint195]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ShaderSourceARB(shaderObj, count, string, length) };
}

pub fn retrace_glCompileShaderARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut shaderObj: GLhandleARB;
    shaderObj = (call.arg(0)).to_u32().unwrap();
    shaderObj = _handleARB_map[shaderObj];

    unsafe { gl::CompileShaderARB(shaderObj) };
        let compile_status = 0;
        gl::GetObjectParameterivARB(shaderObj, gl::OBJECT_COMPILE_STATUS_ARB, &compile_status);
        if (!compile_status) {
             retrace::warning(call) << "compilation failed\n";
        }
        let info_log_length = 0;
        gl::GetObjectParameterivARB(shaderObj, gl::OBJECT_INFO_LOG_LENGTH_ARB, &info_log_length);
        if info_log_length > 1 {
             let infoLog = vec![0i8; info_log_length].as_mut_ptr();
             gl::GetInfoLogARB(shaderObj, info_log_length, std::ptr::null_mut(), infoLog);
        }
}

pub fn retrace_glCreateProgramObjectARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let _result = unsafe { gl::CreateProgramObjectARB() };

    let _origResult: GLhandleARB;
    _origResult = (*call.ret).to_u32().unwrap();
    _handleARB_map[_origResult] = _result;
}

pub fn retrace_glAttachObjectARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut containerObj: GLhandleARB;
    containerObj = (call.arg(0)).to_u32().unwrap();
    containerObj = _handleARB_map[containerObj];

    let mut obj: GLhandleARB;
    obj = (call.arg(1)).to_u32().unwrap();
    obj = _handleARB_map[obj];

    unsafe { gl::AttachObjectARB(containerObj, obj) };
}

pub fn retrace_glLinkProgramARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut programObj: GLhandleARB;
    programObj = (call.arg(0)).to_u32().unwrap();
    programObj = _handleARB_map[programObj];

    unsafe { gl::LinkProgramARB(programObj) };
        let link_status = 0;
        gl::GetObjectParameterivARB(programObj, gl::OBJECT_LINK_STATUS_ARB, &link_status);
        if link_status == 0 {
             println!("link failed");
        }
        let info_log_length = 0;
        gl::GetObjectParameterivARB(programObj, gl::OBJECT_INFO_LOG_LENGTH_ARB, &info_log_length);
        if info_log_length > 1 {
             let infoLog = vec![0i8; info_log_length].as_mut_ptr();
             gl::GetInfoLogARB(programObj, info_log_length, std::ptr::null_mut(), infoLog);
        }
}

pub fn retrace_glUseProgramObjectARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut programObj: GLhandleARB;
    programObj = (call.arg(0)).to_u32().unwrap();
    programObj = _handleARB_map[programObj];

    unsafe { gl::UseProgramObjectARB(programObj) };
        self.context.currentUserProgram = call.arg(0).to_u32().unwrap();
        self.context.currentProgram = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
}

pub fn retrace_glValidateProgramARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut programObj: GLhandleARB;
    programObj = (call.arg(0)).to_u32().unwrap();
    programObj = _handleARB_map[programObj];

    unsafe { gl::ValidateProgramARB(programObj) };
}

pub fn retrace_glUniform1fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::Uniform1fARB(location, v0) };
}

pub fn retrace_glUniform2fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(1)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Uniform2fARB(location, v0, v1) };
}

pub fn retrace_glUniform3fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(1)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(2)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::Uniform3fARB(location, v0, v1, v2) };
}

pub fn retrace_glUniform4fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(1)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(2)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(3)).to_f32().unwrap();

    let mut v3: GLfloat;
    v3 = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::Uniform4fARB(location, v0, v1, v2, v3) };
}

pub fn retrace_glUniform1iARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::Uniform1iARB(location, v0) };
}

pub fn retrace_glUniform2iARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(1)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Uniform2iARB(location, v0, v1) };
}

pub fn retrace_glUniform3iARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(1)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(2)).to_i32().unwrap();

    let mut v2: GLint;
    v2 = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Uniform3iARB(location, v0, v1, v2) };
}

pub fn retrace_glUniform4iARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(1)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(2)).to_i32().unwrap();

    let mut v2: GLint;
    v2 = (call.arg(3)).to_i32().unwrap();

    let mut v3: GLint;
    v3 = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::Uniform4iARB(location, v0, v1, v2, v3) };
}

pub fn retrace_glUniform1fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat171_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat171_0) = _a_GLfloat171_0 {
        for _jGLfloat171 in 0.._a_GLfloat171_0.values.len() {
    value[_jGLfloat171] = (*_a_GLfloat171_0.values[_jGLfloat171]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1fvARB(location, count, value) };
}

pub fn retrace_glUniform2fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat172_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat172_0) = _a_GLfloat172_0 {
        for _jGLfloat172 in 0.._a_GLfloat172_0.values.len() {
    value[_jGLfloat172] = (*_a_GLfloat172_0.values[_jGLfloat172]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2fvARB(location, count, value) };
}

pub fn retrace_glUniform3fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat173_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat173_0) = _a_GLfloat173_0 {
        for _jGLfloat173 in 0.._a_GLfloat173_0.values.len() {
    value[_jGLfloat173] = (*_a_GLfloat173_0.values[_jGLfloat173]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3fvARB(location, count, value) };
}

pub fn retrace_glUniform4fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat174_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat174_0) = _a_GLfloat174_0 {
        for _jGLfloat174 in 0.._a_GLfloat174_0.values.len() {
    value[_jGLfloat174] = (*_a_GLfloat174_0.values[_jGLfloat174]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4fvARB(location, count, value) };
}

pub fn retrace_glUniform1ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint196_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint196_0) = _a_GLint196_0 {
        for _jGLint196 in 0.._a_GLint196_0.values.len() {
    value[_jGLint196] = (*_a_GLint196_0.values[_jGLint196]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1ivARB(location, count, value) };
}

pub fn retrace_glUniform2ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint197_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint197_0) = _a_GLint197_0 {
        for _jGLint197 in 0.._a_GLint197_0.values.len() {
    value[_jGLint197] = (*_a_GLint197_0.values[_jGLint197]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2ivARB(location, count, value) };
}

pub fn retrace_glUniform3ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint198_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint198_0) = _a_GLint198_0 {
        for _jGLint198 in 0.._a_GLint198_0.values.len() {
    value[_jGLint198] = (*_a_GLint198_0.values[_jGLint198]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3ivARB(location, count, value) };
}

pub fn retrace_glUniform4ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint199_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint199_0) = _a_GLint199_0 {
        for _jGLint199 in 0.._a_GLint199_0.values.len() {
    value[_jGLint199] = (*_a_GLint199_0.values[_jGLint199]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4ivARB(location, count, value) };
}

pub fn retrace_glUniformMatrix2fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat175_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat175_0) = _a_GLfloat175_0 {
        for _jGLfloat175 in 0.._a_GLfloat175_0.values.len() {
    value[_jGLfloat175] = (*_a_GLfloat175_0.values[_jGLfloat175]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix2fvARB(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix3fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat176_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat176_0) = _a_GLfloat176_0 {
        for _jGLfloat176 in 0.._a_GLfloat176_0.values.len() {
    value[_jGLfloat176] = (*_a_GLfloat176_0.values[_jGLfloat176]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix3fvARB(location, count, transpose, value) };
}

pub fn retrace_glUniformMatrix4fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[programObj].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat177_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat177_0) = _a_GLfloat177_0 {
        for _jGLfloat177 in 0.._a_GLfloat177_0.values.len() {
    value[_jGLfloat177] = (*_a_GLfloat177_0.values[_jGLfloat177]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformMatrix4fvARB(location, count, transpose, value) };
}

pub fn retrace_glGetUniformLocationARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut programObj: GLhandleARB;
    programObj = (call.arg(0)).to_u32().unwrap();
    programObj = _handleARB_map[programObj];

    let name: &mut [GLcharARB];
    name = (GLcharARB *)((call.arg(1)).to_string().unwrap());

    let _result = unsafe { gl::GetUniformLocationARB(programObj, name) };

    let _origResult: GLint;
    _origResult = (*call.ret).to_i32().unwrap();
    _location_map[programObj][_origResult] = _result;
}

pub fn retrace_glShaderStorageBlockBinding(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut storageBlockIndex: GLuint;
    storageBlockIndex = (call.arg(1)).to_u32().unwrap();

    let mut storageBlockBinding: GLuint;
    storageBlockBinding = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::ShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding) };
}

pub fn retrace_glGetSubroutineUniformLocation(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut shadertype: GLenum;
    shadertype = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(2)).to_string().unwrap());

    let _result = unsafe { gl::GetSubroutineUniformLocation(program, shadertype, name) };

    let _origResult: GLint;
    _origResult = (*call.ret).to_i32().unwrap();
    _location_map[program][_origResult] = _result;
}

pub fn retrace_glGetSubroutineIndex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut shadertype: GLenum;
    shadertype = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(2)).to_string().unwrap());

    let _result = unsafe { gl::GetSubroutineIndex(program, shadertype, name) };

    let _origResult: GLuint;
    _origResult = (*call.ret).to_u32().unwrap();
    _subroutine_map[program][_origResult] = _result;
}

pub fn retrace_glUniformSubroutinesuiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut shadertype: GLenum;
    shadertype = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let indices: &mut [GLuint];
    GLint program = _getActiveProgram();
    indices = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint187_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint187_0) = _a_GLuint187_0 {
        for _jGLuint187 in 0.._a_GLuint187_0.values.len() {
    indices[_jGLuint187] = (*_a_GLuint187_0.values[_jGLuint187]).to_u32().unwrap();
    indices[_jGLuint187] = _subroutine_map[program][indices[_jGLuint187]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformSubroutinesuiv(shadertype, count, indices) };
}

pub fn retrace_glNamedStringARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut namelen: GLint;
    namelen = (call.arg(1)).to_i32().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(2)).to_string().unwrap());

    let mut stringlen: GLint;
    stringlen = (call.arg(3)).to_i32().unwrap();

    let string: &mut [GLchar];
    string = (GLchar *)((call.arg(4)).to_string().unwrap());

    unsafe { gl::NamedStringARB(_type, namelen, name, stringlen, string) };
}

pub fn retrace_glDeleteNamedStringARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut namelen: GLint;
    namelen = (call.arg(0)).to_i32().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(1)).to_string().unwrap());

    unsafe { gl::DeleteNamedStringARB(namelen, name) };
}

pub fn retrace_glCompileShaderIncludeARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut shader: GLuint;
    shader = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let path: &mut [GLchar];
    path = _allocator.alloc_array::< GLchar >(&call.arg(2));
    let _a_constGLchar23_0 = (call.arg(2)).to_array();
    if let Some(_a_constGLchar23_0) = _a_constGLchar23_0 {
        for _jconstGLchar23 in 0.._a_constGLchar23_0.values.len() {
    path[_jconstGLchar23] = (const GLchar *)((*_a_constGLchar23_0.values[_jconstGLchar23]).to_string().unwrap());
        }
    }
    let params = params.as_mut_ptr();

    let length: &mut [GLint];
    length = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint200_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint200_0) = _a_GLint200_0 {
        for _jGLint200 in 0.._a_GLint200_0.values.len() {
    length[_jGLint200] = (*_a_GLint200_0.values[_jGLint200]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::CompileShaderIncludeARB(shader, count, path, length) };
}

pub fn retrace_glBufferPageCommitmentARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(2)).to_i32().unwrap();

    let mut commit: GLboolean;
    commit = (call.arg(3)).to_u32().unwrap() as u8;

    unsafe { gl::BufferPageCommitmentARB(target, offset, size, commit) };
}

pub fn retrace_glNamedBufferPageCommitmentEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(2)).to_i32().unwrap();

    let mut commit: GLboolean;
    commit = (call.arg(3)).to_u32().unwrap() as u8;

    unsafe { gl::NamedBufferPageCommitmentEXT(buffer, offset, size, commit) };
}

pub fn retrace_glNamedBufferPageCommitmentARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(2)).to_i32().unwrap();

    let mut commit: GLboolean;
    commit = (call.arg(3)).to_u32().unwrap() as u8;

    unsafe { gl::NamedBufferPageCommitmentARB(buffer, offset, size, commit) };
}

pub fn retrace_glTexPageCommitmentARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut resident: GLboolean;
    resident = (call.arg(8)).to_u32().unwrap() as u8;

    unsafe { gl::TexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, resident) };
}

pub fn retrace_glFenceSync(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut condition: GLenum;
    condition = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut flags: GLbitfield;
    flags = (call.arg(1)).to_u32().unwrap();

    let _result = unsafe { gl::FenceSync(condition, flags) };

    self.context.needs_flush = true;
    let _origResult: GLsync;
    let _origResult = (*call.ret).to_pointer().unwrap() as *mut c_void;
    _sync_map[_origResult] = _result;
}

pub fn retrace_glDeleteSync(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sync: GLsync;
    let sync = (call.arg(0)).to_pointer().unwrap() as *mut c_void;
    sync = _sync_map[sync];

    unsafe { gl::DeleteSync(sync) };
}

pub fn retrace_glClientWaitSync(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sync: GLsync;
    let sync = (call.arg(0)).to_pointer().unwrap() as *mut c_void;
    sync = _sync_map[sync];

    let mut flags: GLbitfield;
    flags = (call.arg(1)).to_u32().unwrap();

    let mut timeout: GLuint64;
    timeout = (call.arg(2)).to_u32().unwrap();

    _result = glretrace::clientWaitSync(call, sync, flags, timeout);

}

pub fn retrace_glWaitSync(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sync: GLsync;
    let sync = (call.arg(0)).to_pointer().unwrap() as *mut c_void;
    sync = _sync_map[sync];

    let mut flags: GLbitfield;
    flags = (call.arg(1)).to_u32().unwrap();

    let mut timeout: GLuint64;
    timeout = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::WaitSync(sync, flags, timeout) };
}

pub fn retrace_glGetSynciv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sync: GLsync;
    let sync = (call.arg(0)).to_pointer().unwrap() as *mut c_void;
    sync = _sync_map[sync];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(2)).to_i32().unwrap();

    let length: &mut [GLsizei];
    length = _allocator.alloc_array::<GLsizei>(&call.arg(3));

    let values: &mut [GLint];
    values = _allocator.alloc_array::<GLint>(&call.arg(4));

    if (pname == GL_SYNC_STATUS &&
        bufSize >= 1 &&
        values != NULL &&
        call.arg(4)[0].toSInt() == GL_SIGNALED) {
        // Fence was signalled, so ensure it happened here
        glretrace::blockOnFence(call, sync, GL_SYNC_FLUSH_COMMANDS_BIT);
        (void)length;
    }
    let _aPGLsizei22 = (call.arg(3)).to_array();
    if (_aPGLsizei22) {
    }
    let _aGLint202 = (call.arg(4)).to_array();
    if (_aGLint202) {
        for _jGLint202 in 0..length {
        }
    }
}

pub fn retrace_glPatchParameteri(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLint;
    value = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PatchParameteri(pname, value) };
}

pub fn retrace_glPatchParameterfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let values: &mut [GLfloat];
    values = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat178_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat178_0) = _a_GLfloat178_0 {
        for _jGLfloat178 in 0.._a_GLfloat178_0.values.len() {
    values[_jGLfloat178] = (*_a_GLfloat178_0.values[_jGLfloat178]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PatchParameterfv(pname, values) };
}

pub fn retrace_glTextureBarrier(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::TextureBarrier() };
}

pub fn retrace_glTexBufferARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::TexBufferARB(target, internalformat, buffer) };
}

pub fn retrace_glTexBufferRange(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::TexBufferRange(target, internalformat, buffer, offset, size) };
}

pub fn retrace_glCompressedTexImage3DARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(7)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data) };
}

pub fn retrace_glCompressedTexImage2DARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(5)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(6)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data) };
}

pub fn retrace_glCompressedTexImage1DARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(4)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(5)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data) };
}

pub fn retrace_glCompressedTexSubImage3DARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(9)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data) };
}

pub fn retrace_glCompressedTexSubImage2DARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(7)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data) };
}

pub fn retrace_glCompressedTexSubImage1DARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(5)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data) };
}

pub fn retrace_glGetCompressedTexImageARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let img: &mut [GLvoid];
    img = (call.arg(2)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetCompressedTexImageARB(target, level, img) };
}

pub fn retrace_glTexImage2DMultisample(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut fixedsamplelocations: GLboolean;
    fixedsamplelocations = (call.arg(5)).to_u32().unwrap() as u8;

    unsafe { gl::TexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations) };
}

pub fn retrace_glTexImage3DMultisample(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut fixedsamplelocations: GLboolean;
    fixedsamplelocations = (call.arg(6)).to_u32().unwrap() as u8;

    unsafe { gl::TexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations) };
}

pub fn retrace_glSampleMaski(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut mask: GLbitfield;
    mask = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::SampleMaski(index, mask) };
}

pub fn retrace_glTexStorage1D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::TexStorage1D(target, levels, internalformat, width) };
}

pub fn retrace_glTexStorage2D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::TexStorage2D(target, levels, internalformat, width, height) };
}

pub fn retrace_glTexStorage3D(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::TexStorage3D(target, levels, internalformat, width, height, depth) };
}

pub fn retrace_glTexStorageAttribs2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let attrib_list: &mut [GLint];
    attrib_list = _allocator.alloc_array::<GLint>(&call.arg(5));
    let _a_GLint203_0 = (call.arg(5)).to_array().unwrap();
    if (_a_GLint203_0) {
        for _jGLint203 in _jGLint203.._a_GLint203_0.values.len() {
    attrib_list[_jGLint203] = (_a_GLint203_0.values[_jGLint203]).to_u32().unwrap().try_into().unwrap();
        }
    }

    unsafe { gl::TexStorageAttribs2DEXT(target, levels, internalformat, width, height, attrib_list) };
}

pub fn retrace_glTexStorageAttribs3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let attrib_list: &mut [GLint];
    attrib_list = _allocator.alloc_array::<GLint>(&call.arg(6));
    let _a_GLint204_0 = (call.arg(6)).to_array().unwrap();
    if (_a_GLint204_0) {
        for _jGLint204 in _jGLint204.._a_GLint204_0.values.len() {
    attrib_list[_jGLint204] = (_a_GLint204_0.values[_jGLint204]).to_u32().unwrap().try_into().unwrap();
        }
    }

    unsafe { gl::TexStorageAttribs3DEXT(target, levels, internalformat, width, height, depth, attrib_list) };
}

pub fn retrace_glTexStorage2DMultisample(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut fixedsamplelocations: GLboolean;
    fixedsamplelocations = (call.arg(5)).to_u32().unwrap() as u8;

    unsafe { gl::TexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations) };
}

pub fn retrace_glTexStorage3DMultisample(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut fixedsamplelocations: GLboolean;
    fixedsamplelocations = (call.arg(6)).to_u32().unwrap() as u8;

    unsafe { gl::TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations) };
}

pub fn retrace_glEGLImageTargetTexStorageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut image: GLeglImageOES;
    let image = (call.arg(1)).to_pointer().unwrap() as *mut c_void;
    image = _eglImageOES_map[image];

    let attrib_list: &mut [GLint];
    attrib_list = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint205_0 = (call.arg(2)).to_array().unwrap();
    if (_a_GLint205_0) {
        for _jGLint205 in _jGLint205.._a_GLint205_0.values.len() {
    attrib_list[_jGLint205] = (_a_GLint205_0.values[_jGLint205]).to_u32().unwrap().try_into().unwrap();
        }
    }

    unsafe { gl::EGLImageTargetTexStorageEXT(target, image, attrib_list) };
}

pub fn retrace_glEGLImageTargetTextureStorageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut image: GLeglImageOES;
    let image = (call.arg(1)).to_pointer().unwrap() as *mut c_void;
    image = _eglImageOES_map[image];

    let attrib_list: &mut [GLint];
    attrib_list = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint206_0 = (call.arg(2)).to_array().unwrap();
    if (_a_GLint206_0) {
        for _jGLint206 in _jGLint206.._a_GLint206_0.values.len() {
    attrib_list[_jGLint206] = (_a_GLint206_0.values[_jGLint206]).to_u32().unwrap().try_into().unwrap();
        }
    }

    unsafe { gl::EGLImageTargetTextureStorageEXT(texture, image, attrib_list) };
}

pub fn retrace_glTextureView(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut origtexture: GLuint;
    origtexture = (call.arg(2)).to_u32().unwrap();
    origtexture = _texture_map[origtexture];

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut minlevel: GLuint;
    minlevel = (call.arg(4)).to_u32().unwrap();

    let mut numlevels: GLuint;
    numlevels = (call.arg(5)).to_u32().unwrap();

    let mut minlayer: GLuint;
    minlayer = (call.arg(6)).to_u32().unwrap();

    let mut numlayers: GLuint;
    numlayers = (call.arg(7)).to_u32().unwrap();

    unsafe { gl::TextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers) };
}

pub fn retrace_glQueryCounter(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::QueryCounter(id, target) };
}

pub fn retrace_glGetQueryObjecti64v(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint64];
    GLint64 retval;
    if (_query_buffer)
        params = static_cast<GLint64 *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjecti64v(id, pname, params) };
    let _aGLint6423 = (call.arg(2)).to_array();
    if (_aGLint6423) {
        for _jGLint6423 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glGetQueryObjectui64v(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint64];
    GLuint64 retval;
    if (_query_buffer)
        params = static_cast<GLuint64 *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectui64v(id, pname, params) };
    let _aGLuint6420 = (call.arg(2)).to_array();
    if (_aGLuint6420) {
        for _jGLuint6420 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glBindTransformFeedback(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _feedback_map[id];

    unsafe { gl::BindTransformFeedback(target, id) };
}

pub fn retrace_glDeleteTransformFeedbacks(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint188_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint188_0) = _a_GLuint188_0 {
        for _jGLuint188 in 0.._a_GLuint188_0.values.len() {
    ids[_jGLuint188] = (*_a_GLuint188_0.values[_jGLuint188]).to_u32().unwrap();
    ids[_jGLuint188] = _feedback_map[ids[_jGLuint188]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteTransformFeedbacks(n, ids) };
}

pub fn retrace_glGenTransformFeedbacks(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenTransformFeedbacks(n, ids) };
    let _aGLuint190 = (call.arg(1)).to_array();
    if (_aGLuint190) {
        for _jGLuint190 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint190.values[_jGLuint190]).to_u32().unwrap();
    _feedback_map[_origResult] = ids[_jGLuint190];
        }
    }
}

pub fn retrace_glPauseTransformFeedback(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PauseTransformFeedback() };
}

pub fn retrace_glResumeTransformFeedback(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::ResumeTransformFeedback() };
}

pub fn retrace_glDrawTransformFeedback(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _feedback_map[id];

    unsafe { gl::DrawTransformFeedback(mode, id) };
}

pub fn retrace_glDrawTransformFeedbackStream(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _feedback_map[id];

    let mut stream: GLuint;
    stream = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::DrawTransformFeedbackStream(mode, id, stream) };
}

pub fn retrace_glBeginQueryIndexed(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut id: GLuint;
    id = (call.arg(2)).to_u32().unwrap();
    id = _feedback_map[id];

    unsafe { gl::BeginQueryIndexed(target, index, id) };
}

pub fn retrace_glEndQueryIndexed(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::EndQueryIndexed(target, index) };
}

pub fn retrace_glDrawTransformFeedbackInstanced(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _feedback_map[id];

    let mut instancecount: GLsizei;
    instancecount = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::DrawTransformFeedbackInstanced(mode, id, instancecount) };
}

pub fn retrace_glDrawTransformFeedbackStreamInstanced(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _feedback_map[id];

    let mut stream: GLuint;
    stream = (call.arg(2)).to_u32().unwrap();

    let mut instancecount: GLsizei;
    instancecount = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::DrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount) };
}

pub fn retrace_glLoadTransposeMatrixfARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat179_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat179_0) = _a_GLfloat179_0 {
        for _jGLfloat179 in 0.._a_GLfloat179_0.values.len() {
    m[_jGLfloat179] = (*_a_GLfloat179_0.values[_jGLfloat179]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::LoadTransposeMatrixfARB(m) };
}

pub fn retrace_glLoadTransposeMatrixdARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLdouble];
    m = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble86_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble86_0) = _a_GLdouble86_0 {
        for _jGLdouble86 in 0.._a_GLdouble86_0.values.len() {
    m[_jGLdouble86] = (*_a_GLdouble86_0.values[_jGLdouble86]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::LoadTransposeMatrixdARB(m) };
}

pub fn retrace_glMultTransposeMatrixfARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat180_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat180_0) = _a_GLfloat180_0 {
        for _jGLfloat180 in 0.._a_GLfloat180_0.values.len() {
    m[_jGLfloat180] = (*_a_GLfloat180_0.values[_jGLfloat180]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultTransposeMatrixfARB(m) };
}

pub fn retrace_glMultTransposeMatrixdARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let m: &mut [GLdouble];
    m = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble87_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble87_0) = _a_GLdouble87_0 {
        for _jGLdouble87 in 0.._a_GLdouble87_0.values.len() {
    m[_jGLdouble87] = (*_a_GLdouble87_0.values[_jGLdouble87]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultTransposeMatrixdARB(m) };
}

pub fn retrace_glGetUniformBlockIndex(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let uniformBlockName: &mut [GLchar];
    uniformBlockName = (GLchar *)((call.arg(1)).to_string().unwrap());

    let _result = unsafe { gl::GetUniformBlockIndex(program, uniformBlockName) };

    let _origResult: GLuint;
    _origResult = (*call.ret).to_u32().unwrap();
    _uniformBlock_map[program][_origResult] = _result;
}

pub fn retrace_glGetActiveUniformBlockName(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut uniformBlockIndex: GLuint;
    uniformBlockIndex = (call.arg(1)).to_u32().unwrap();
    uniformBlockIndex = _uniformBlock_map[program][uniformBlockIndex];

    let mut bufSize: GLsizei;
    bufSize = (call.arg(2)).to_i32().unwrap();

    let length: &mut [GLsizei];
    length = _allocator.alloc_array::<GLsizei>(&call.arg(3));

    let uniformBlockName: &mut [GLchar];

    std::vector<GLchar> name_buf(bufSize);
    uniformBlockName = name_buf.data();
    const auto traced_name = (const GLchar *)((call.arg(4)).toString());
    glretrace::mapUniformBlockName(program, (call.arg(1)).toSInt(), traced_name, _uniformBlock_map);
    unsafe { gl::GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName) };
    let _aPGLsizei24 = (call.arg(3)).to_array();
    if (_aPGLsizei24) {
    }
}

pub fn retrace_glUniformBlockBinding(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut uniformBlockIndex: GLuint;
    uniformBlockIndex = (call.arg(1)).to_u32().unwrap();
    uniformBlockIndex = _uniformBlock_map[program][uniformBlockIndex];

    let mut uniformBlockBinding: GLuint;
    uniformBlockBinding = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::UniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding) };
}

pub fn retrace_glBindVertexArray(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut array: GLuint;
    array = (call.arg(0)).to_u32().unwrap();
    array = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][array];

    unsafe { gl::BindVertexArray(array) };
}

pub fn retrace_glDeleteVertexArrays(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let arrays: &mut [GLuint];
    arrays = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint191_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint191_0) = _a_GLuint191_0 {
        for _jGLuint191 in 0.._a_GLuint191_0.values.len() {
    arrays[_jGLuint191] = (*_a_GLuint191_0.values[_jGLuint191]).to_u32().unwrap();
    arrays[_jGLuint191] = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][arrays[_jGLuint191]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteVertexArrays(n, arrays) };
}

pub fn retrace_glGenVertexArrays(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let arrays: &mut [GLuint];
    arrays = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenVertexArrays(n, arrays) };
    let _aGLuint193 = (call.arg(1)).to_array();
    if (_aGLuint193) {
        for _jGLuint193 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint193.values[_jGLuint193]).to_u32().unwrap();
    _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][_origResult] = arrays[_jGLuint193];
        }
    }
}

pub fn retrace_glVertexAttribL1d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::VertexAttribL1d(index, x) };
}

pub fn retrace_glVertexAttribL2d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::VertexAttribL2d(index, x, y) };
}

pub fn retrace_glVertexAttribL3d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::VertexAttribL3d(index, x, y, z) };
}

pub fn retrace_glVertexAttribL4d(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::VertexAttribL4d(index, x, y, z, w) };
}

pub fn retrace_glVertexAttribL1dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_PGLdouble8_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLdouble8_0.values[0]).to_f64().unwrap();

    unsafe { gl::VertexAttribL1dv(index, v) };
}

pub fn retrace_glVertexAttribL2dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble88_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble88_0) = _a_GLdouble88_0 {
        for _jGLdouble88 in 0.._a_GLdouble88_0.values.len() {
    v[_jGLdouble88] = (*_a_GLdouble88_0.values[_jGLdouble88]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL2dv(index, v) };
}

pub fn retrace_glVertexAttribL3dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble89_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble89_0) = _a_GLdouble89_0 {
        for _jGLdouble89 in 0.._a_GLdouble89_0.values.len() {
    v[_jGLdouble89] = (*_a_GLdouble89_0.values[_jGLdouble89]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL3dv(index, v) };
}

pub fn retrace_glVertexAttribL4dv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble90_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble90_0) = _a_GLdouble90_0 {
        for _jGLdouble90 in 0.._a_GLdouble90_0.values.len() {
    v[_jGLdouble90] = (*_a_GLdouble90_0.values[_jGLdouble90]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL4dv(index, v) };
}

pub fn retrace_glVertexAttribLPointer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(4), true));

    unsafe { gl::VertexAttribLPointer(index, size, _type, stride, pointer) };
}

pub fn retrace_glBindVertexBuffer(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut bindingindex: GLuint;
    bindingindex = (call.arg(0)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(2)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::BindVertexBuffer(bindingindex, buffer, offset, stride) };
}

pub fn retrace_glVertexAttribFormat(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut attribindex: GLuint;
    attribindex = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(3)).to_u32().unwrap() as u8;

    let mut relativeoffset: GLuint;
    relativeoffset = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexAttribFormat(attribindex, size, _type, normalized, relativeoffset) };
}

pub fn retrace_glVertexAttribIFormat(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut attribindex: GLuint;
    attribindex = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut relativeoffset: GLuint;
    relativeoffset = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::VertexAttribIFormat(attribindex, size, _type, relativeoffset) };
}

pub fn retrace_glVertexAttribLFormat(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut attribindex: GLuint;
    attribindex = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut relativeoffset: GLuint;
    relativeoffset = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::VertexAttribLFormat(attribindex, size, _type, relativeoffset) };
}

pub fn retrace_glVertexAttribBinding(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut attribindex: GLuint;
    attribindex = (call.arg(0)).to_u32().unwrap();

    let mut bindingindex: GLuint;
    bindingindex = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexAttribBinding(attribindex, bindingindex) };
}

pub fn retrace_glVertexBindingDivisor(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut bindingindex: GLuint;
    bindingindex = (call.arg(0)).to_u32().unwrap();

    let mut divisor: GLuint;
    divisor = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexBindingDivisor(bindingindex, divisor) };
}

pub fn retrace_glWeightbvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let weights: &mut [GLbyte];
    weights = _allocator.alloc_array::<GLbyte>(&call.arg(1));
    let _a_GLbyte8_0 = (call.arg(1)).to_array();
    if let Some(_a_GLbyte8_0) = _a_GLbyte8_0 {
        for _jGLbyte8 in 0.._a_GLbyte8_0.values.len() {
    weights[_jGLbyte8] = (*_a_GLbyte8_0.values[_jGLbyte8]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WeightbvARB(size, weights) };
}

pub fn retrace_glWeightsvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let weights: &mut [GLshort];
    weights = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort29_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort29_0) = _a_GLshort29_0 {
        for _jGLshort29 in 0.._a_GLshort29_0.values.len() {
    weights[_jGLshort29] = (*_a_GLshort29_0.values[_jGLshort29]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WeightsvARB(size, weights) };
}

pub fn retrace_glWeightivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let weights: &mut [GLint];
    weights = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint207_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint207_0) = _a_GLint207_0 {
        for _jGLint207 in 0.._a_GLint207_0.values.len() {
    weights[_jGLint207] = (*_a_GLint207_0.values[_jGLint207]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WeightivARB(size, weights) };
}

pub fn retrace_glWeightfvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let weights: &mut [GLfloat];
    weights = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat181_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat181_0) = _a_GLfloat181_0 {
        for _jGLfloat181 in 0.._a_GLfloat181_0.values.len() {
    weights[_jGLfloat181] = (*_a_GLfloat181_0.values[_jGLfloat181]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WeightfvARB(size, weights) };
}

pub fn retrace_glWeightdvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let weights: &mut [GLdouble];
    weights = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble91_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble91_0) = _a_GLdouble91_0 {
        for _jGLdouble91 in 0.._a_GLdouble91_0.values.len() {
    weights[_jGLdouble91] = (*_a_GLdouble91_0.values[_jGLdouble91]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WeightdvARB(size, weights) };
}

pub fn retrace_glWeightubvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let weights: &mut [GLubyte];
    weights = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte16_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte16_0) = _a_GLubyte16_0 {
        for _jGLubyte16 in 0.._a_GLubyte16_0.values.len() {
    weights[_jGLubyte16] = (*_a_GLubyte16_0.values[_jGLubyte16]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WeightubvARB(size, weights) };
}

pub fn retrace_glWeightusvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let weights: &mut [GLushort];
    weights = _allocator.alloc_array::<GLushort>(&call.arg(1));
    let _a_GLushort15_0 = (call.arg(1)).to_array();
    if let Some(_a_GLushort15_0) = _a_GLushort15_0 {
        for _jGLushort15 in 0.._a_GLushort15_0.values.len() {
    weights[_jGLushort15] = (*_a_GLushort15_0.values[_jGLushort15]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WeightusvARB(size, weights) };
}

pub fn retrace_glWeightuivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let weights: &mut [GLuint];
    weights = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint194_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint194_0) = _a_GLuint194_0 {
        for _jGLuint194 in 0.._a_GLuint194_0.values.len() {
    weights[_jGLuint194] = (*_a_GLuint194_0.values[_jGLuint194]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WeightuivARB(size, weights) };
}

pub fn retrace_glWeightPointerARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::WeightPointerARB(size, _type, stride, pointer) };
}

pub fn retrace_glVertexBlendARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut count: GLint;
    count = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::VertexBlendARB(count) };
}

pub fn retrace_glBindBufferARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::BindBufferARB(target, buffer) };
}

pub fn retrace_glDeleteBuffersARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let buffers: &mut [GLuint];
    buffers = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint195_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint195_0) = _a_GLuint195_0 {
        for _jGLuint195 in 0.._a_GLuint195_0.values.len() {
    buffers[_jGLuint195] = (*_a_GLuint195_0.values[_jGLuint195]).to_u32().unwrap();
    buffers[_jGLuint195] = _buffer_map[buffers[_jGLuint195]];
        }
    }
    let params = params.as_mut_ptr();

    if (currentContext && currentContext->features().ARB_direct_state_access) {
        for (GLsizei i = 0; i < n; ++i) {
            GLuint buffer = buffers[i];
            if (buffer != 0 && glIsBuffer(buffer)) {
                GLvoid *ptr = nullptr;
                glGetNamedBufferPointerv(buffers[i], GL_BUFFER_MAP_POINTER, &ptr);
                if (ptr) {
                    retrace::delRegionByPointer(ptr);
                }
            }
        }
    }
    unsafe { gl::DeleteBuffersARB(n, buffers) };
}

pub fn retrace_glGenBuffersARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let buffers: &mut [GLuint];
    buffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenBuffersARB(n, buffers) };
    let _aGLuint197 = (call.arg(1)).to_array();
    if (_aGLuint197) {
        for _jGLuint197 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint197.values[_jGLuint197]).to_u32().unwrap();
    _buffer_map[_origResult] = buffers[_jGLuint197];
        }
    }
}

pub fn retrace_glBufferDataARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut size: GLsizeiptrARB;
    size = (call.arg(1)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut usage: GLenum;
    usage = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BufferDataARB(target, size, data, usage) };
}

pub fn retrace_glBufferSubDataARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptrARB;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut size: GLsizeiptrARB;
    size = (call.arg(2)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::BufferSubDataARB(target, offset, size, data) };
}

pub fn retrace_glMapBufferARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut access: GLenum;
    access = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::MapBufferARB(target, access) };

    let length = 0;
    gl::GetBufferParameterivARB(target, gl::BUFFER_SIZE_ARB, &length);
    retrace::addRegion(call, (*call.ret).toUIntPtr(), _result, length);
}

pub fn retrace_glUnmapBufferARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

        GLvoid *ptr = NULL;
            glGetBufferPointervARB(target, GL_BUFFER_MAP_POINTER_ARB, &ptr);
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "failed to get mapped pointer\n";
        }
    let _result = unsafe { gl::UnmapBufferARB(target) };

}

pub fn retrace_glVertexAttrib1dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::VertexAttrib1dARB(index, x) };
}

pub fn retrace_glVertexAttrib1dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_PGLdouble9_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLdouble9_0.values[0]).to_f64().unwrap();

    unsafe { gl::VertexAttrib1dvARB(index, v) };
}

pub fn retrace_glVertexAttrib1fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::VertexAttrib1fARB(index, x) };
}

pub fn retrace_glVertexAttrib1fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_PGLfloat18_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLfloat18_0.values[0]).to_f32().unwrap();

    unsafe { gl::VertexAttrib1fvARB(index, v) };
}

pub fn retrace_glVertexAttrib1sARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::VertexAttrib1sARB(index, x) };
}

pub fn retrace_glVertexAttrib1svARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_PGLshort5_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLshort5_0.values[0]).to_i32().unwrap();

    unsafe { gl::VertexAttrib1svARB(index, v) };
}

pub fn retrace_glVertexAttrib2dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::VertexAttrib2dARB(index, x, y) };
}

pub fn retrace_glVertexAttrib2dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble92_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble92_0) = _a_GLdouble92_0 {
        for _jGLdouble92 in 0.._a_GLdouble92_0.values.len() {
    v[_jGLdouble92] = (*_a_GLdouble92_0.values[_jGLdouble92]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib2dvARB(index, v) };
}

pub fn retrace_glVertexAttrib2fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::VertexAttrib2fARB(index, x, y) };
}

pub fn retrace_glVertexAttrib2fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat182_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat182_0) = _a_GLfloat182_0 {
        for _jGLfloat182 in 0.._a_GLfloat182_0.values.len() {
    v[_jGLfloat182] = (*_a_GLfloat182_0.values[_jGLfloat182]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib2fvARB(index, v) };
}

pub fn retrace_glVertexAttrib2sARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::VertexAttrib2sARB(index, x, y) };
}

pub fn retrace_glVertexAttrib2svARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort30_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort30_0) = _a_GLshort30_0 {
        for _jGLshort30 in 0.._a_GLshort30_0.values.len() {
    v[_jGLshort30] = (*_a_GLshort30_0.values[_jGLshort30]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib2svARB(index, v) };
}

pub fn retrace_glVertexAttrib3dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::VertexAttrib3dARB(index, x, y, z) };
}

pub fn retrace_glVertexAttrib3dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble93_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble93_0) = _a_GLdouble93_0 {
        for _jGLdouble93 in 0.._a_GLdouble93_0.values.len() {
    v[_jGLdouble93] = (*_a_GLdouble93_0.values[_jGLdouble93]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib3dvARB(index, v) };
}

pub fn retrace_glVertexAttrib3fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::VertexAttrib3fARB(index, x, y, z) };
}

pub fn retrace_glVertexAttrib3fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat183_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat183_0) = _a_GLfloat183_0 {
        for _jGLfloat183 in 0.._a_GLfloat183_0.values.len() {
    v[_jGLfloat183] = (*_a_GLfloat183_0.values[_jGLfloat183]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib3fvARB(index, v) };
}

pub fn retrace_glVertexAttrib3sARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexAttrib3sARB(index, x, y, z) };
}

pub fn retrace_glVertexAttrib3svARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort31_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort31_0) = _a_GLshort31_0 {
        for _jGLshort31 in 0.._a_GLshort31_0.values.len() {
    v[_jGLshort31] = (*_a_GLshort31_0.values[_jGLshort31]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib3svARB(index, v) };
}

pub fn retrace_glVertexAttrib4NbvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(1));
    let _a_GLbyte9_0 = (call.arg(1)).to_array();
    if let Some(_a_GLbyte9_0) = _a_GLbyte9_0 {
        for _jGLbyte9 in 0.._a_GLbyte9_0.values.len() {
    v[_jGLbyte9] = (*_a_GLbyte9_0.values[_jGLbyte9]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4NbvARB(index, v) };
}

pub fn retrace_glVertexAttrib4NivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint208_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint208_0) = _a_GLint208_0 {
        for _jGLint208 in 0.._a_GLint208_0.values.len() {
    v[_jGLint208] = (*_a_GLint208_0.values[_jGLint208]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4NivARB(index, v) };
}

pub fn retrace_glVertexAttrib4NsvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort32_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort32_0) = _a_GLshort32_0 {
        for _jGLshort32 in 0.._a_GLshort32_0.values.len() {
    v[_jGLshort32] = (*_a_GLshort32_0.values[_jGLshort32]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4NsvARB(index, v) };
}

pub fn retrace_glVertexAttrib4NubARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLubyte;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLubyte;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLubyte;
    z = (call.arg(3)).to_u32().unwrap();

    let mut w: GLubyte;
    w = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexAttrib4NubARB(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4NubvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte17_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte17_0) = _a_GLubyte17_0 {
        for _jGLubyte17 in 0.._a_GLubyte17_0.values.len() {
    v[_jGLubyte17] = (*_a_GLubyte17_0.values[_jGLubyte17]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4NubvARB(index, v) };
}

pub fn retrace_glVertexAttrib4NuivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint198_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint198_0) = _a_GLuint198_0 {
        for _jGLuint198 in 0.._a_GLuint198_0.values.len() {
    v[_jGLuint198] = (*_a_GLuint198_0.values[_jGLuint198]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4NuivARB(index, v) };
}

pub fn retrace_glVertexAttrib4NusvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLushort];
    v = _allocator.alloc_array::<GLushort>(&call.arg(1));
    let _a_GLushort16_0 = (call.arg(1)).to_array();
    if let Some(_a_GLushort16_0) = _a_GLushort16_0 {
        for _jGLushort16 in 0.._a_GLushort16_0.values.len() {
    v[_jGLushort16] = (*_a_GLushort16_0.values[_jGLushort16]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4NusvARB(index, v) };
}

pub fn retrace_glVertexAttrib4bvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(1));
    let _a_GLbyte10_0 = (call.arg(1)).to_array();
    if let Some(_a_GLbyte10_0) = _a_GLbyte10_0 {
        for _jGLbyte10 in 0.._a_GLbyte10_0.values.len() {
    v[_jGLbyte10] = (*_a_GLbyte10_0.values[_jGLbyte10]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4bvARB(index, v) };
}

pub fn retrace_glVertexAttrib4dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::VertexAttrib4dARB(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble94_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble94_0) = _a_GLdouble94_0 {
        for _jGLdouble94 in 0.._a_GLdouble94_0.values.len() {
    v[_jGLdouble94] = (*_a_GLdouble94_0.values[_jGLdouble94]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4dvARB(index, v) };
}

pub fn retrace_glVertexAttrib4fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::VertexAttrib4fARB(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat184_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat184_0) = _a_GLfloat184_0 {
        for _jGLfloat184 in 0.._a_GLfloat184_0.values.len() {
    v[_jGLfloat184] = (*_a_GLfloat184_0.values[_jGLfloat184]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4fvARB(index, v) };
}

pub fn retrace_glVertexAttrib4ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint209_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint209_0) = _a_GLint209_0 {
        for _jGLint209 in 0.._a_GLint209_0.values.len() {
    v[_jGLint209] = (*_a_GLint209_0.values[_jGLint209]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4ivARB(index, v) };
}

pub fn retrace_glVertexAttrib4sARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(3)).to_i32().unwrap();

    let mut w: GLshort;
    w = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexAttrib4sARB(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4svARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort33_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort33_0) = _a_GLshort33_0 {
        for _jGLshort33 in 0.._a_GLshort33_0.values.len() {
    v[_jGLshort33] = (*_a_GLshort33_0.values[_jGLshort33]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4svARB(index, v) };
}

pub fn retrace_glVertexAttrib4ubvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte18_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte18_0) = _a_GLubyte18_0 {
        for _jGLubyte18 in 0.._a_GLubyte18_0.values.len() {
    v[_jGLubyte18] = (*_a_GLubyte18_0.values[_jGLubyte18]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4ubvARB(index, v) };
}

pub fn retrace_glVertexAttrib4uivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint199_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint199_0) = _a_GLuint199_0 {
        for _jGLuint199 in 0.._a_GLuint199_0.values.len() {
    v[_jGLuint199] = (*_a_GLuint199_0.values[_jGLuint199]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4uivARB(index, v) };
}

pub fn retrace_glVertexAttrib4usvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLushort];
    v = _allocator.alloc_array::<GLushort>(&call.arg(1));
    let _a_GLushort17_0 = (call.arg(1)).to_array();
    if let Some(_a_GLushort17_0) = _a_GLushort17_0 {
        for _jGLushort17 in 0.._a_GLushort17_0.values.len() {
    v[_jGLushort17] = (*_a_GLushort17_0.values[_jGLushort17]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4usvARB(index, v) };
}

pub fn retrace_glVertexAttribPointerARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(3)).to_u32().unwrap() as u8;

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(5), true));

    unsafe { gl::VertexAttribPointerARB(index, size, _type, normalized, stride, pointer) };
}

pub fn retrace_glEnableVertexAttribArrayARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::EnableVertexAttribArrayARB(index) };
}

pub fn retrace_glDisableVertexAttribArrayARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::DisableVertexAttribArrayARB(index) };
}

pub fn retrace_glProgramStringARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut len: GLsizei;
    len = (call.arg(2)).to_i32().unwrap();

    let string: &mut [void];
    string = (void *)((call.arg(3)).to_string().unwrap());

    unsafe { gl::ProgramStringARB(target, format, len, string) };
        let error_position: GLint = -1;
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &error_position);
        if error_position != -1 {
            let error_string = gl::GetString(gl::PROGRAM_ERROR_STRING_ARB);
            println!("error in position {}: {}", error_position, error_string);
        }
}

pub fn retrace_glBindProgramARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut program: GLuint;
    program = (call.arg(1)).to_u32().unwrap();
    program = _programARB_map[program];

    unsafe { gl::BindProgramARB(target, program) };
}

pub fn retrace_glDeleteProgramsARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let programs: &mut [GLuint];
    programs = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint200_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint200_0) = _a_GLuint200_0 {
        for _jGLuint200 in 0.._a_GLuint200_0.values.len() {
    programs[_jGLuint200] = (*_a_GLuint200_0.values[_jGLuint200]).to_u32().unwrap();
    programs[_jGLuint200] = _programARB_map[programs[_jGLuint200]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteProgramsARB(n, programs) };
}

pub fn retrace_glGenProgramsARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let programs: &mut [GLuint];
    programs = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenProgramsARB(n, programs) };
    let _aGLuint202 = (call.arg(1)).to_array();
    if (_aGLuint202) {
        for _jGLuint202 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint202.values[_jGLuint202]).to_u32().unwrap();
    _programARB_map[_origResult] = programs[_jGLuint202];
        }
    }
}

pub fn retrace_glProgramEnvParameter4dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(2)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(3)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(4)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(5)).to_f64().unwrap();

    unsafe { gl::ProgramEnvParameter4dARB(target, index, x, y, z, w) };
}

pub fn retrace_glProgramEnvParameter4dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let params: &mut [GLdouble];
    params = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble95_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble95_0) = _a_GLdouble95_0 {
        for _jGLdouble95 in 0.._a_GLdouble95_0.values.len() {
    params[_jGLdouble95] = (*_a_GLdouble95_0.values[_jGLdouble95]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramEnvParameter4dvARB(target, index, params) };
}

pub fn retrace_glProgramEnvParameter4fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(2)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(3)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(4)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::ProgramEnvParameter4fARB(target, index, x, y, z, w) };
}

pub fn retrace_glProgramEnvParameter4fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat185_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat185_0) = _a_GLfloat185_0 {
        for _jGLfloat185 in 0.._a_GLfloat185_0.values.len() {
    params[_jGLfloat185] = (*_a_GLfloat185_0.values[_jGLfloat185]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramEnvParameter4fvARB(target, index, params) };
}

pub fn retrace_glProgramLocalParameter4dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(2)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(3)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(4)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(5)).to_f64().unwrap();

    unsafe { gl::ProgramLocalParameter4dARB(target, index, x, y, z, w) };
}

pub fn retrace_glProgramLocalParameter4dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let params: &mut [GLdouble];
    params = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble96_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble96_0) = _a_GLdouble96_0 {
        for _jGLdouble96 in 0.._a_GLdouble96_0.values.len() {
    params[_jGLdouble96] = (*_a_GLdouble96_0.values[_jGLdouble96]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramLocalParameter4dvARB(target, index, params) };
}

pub fn retrace_glProgramLocalParameter4fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(2)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(3)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(4)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::ProgramLocalParameter4fARB(target, index, x, y, z, w) };
}

pub fn retrace_glProgramLocalParameter4fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat186_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat186_0) = _a_GLfloat186_0 {
        for _jGLfloat186 in 0.._a_GLfloat186_0.values.len() {
    params[_jGLfloat186] = (*_a_GLfloat186_0.values[_jGLfloat186]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramLocalParameter4fvARB(target, index, params) };
}

pub fn retrace_glBindAttribLocationARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut programObj: GLhandleARB;
    programObj = (call.arg(0)).to_u32().unwrap();
    programObj = _handleARB_map[programObj];

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let name: &mut [GLcharARB];
    name = (GLcharARB *)((call.arg(2)).to_string().unwrap());

    unsafe { gl::BindAttribLocationARB(programObj, index, name) };
}

pub fn retrace_glGetAttribLocationARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut programObj: GLhandleARB;
    programObj = (call.arg(0)).to_u32().unwrap();
    programObj = _handleARB_map[programObj];

    let name: &mut [GLcharARB];
    name = (GLcharARB *)((call.arg(1)).to_string().unwrap());

    let _result = unsafe { gl::GetAttribLocationARB(programObj, name) };

    let _origResult = call.ret.to_i32().unwrap();
}

pub fn retrace_glVertexAttribP1ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(2)).to_u32().unwrap() as u8;

    let mut value: GLuint;
    value = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::VertexAttribP1ui(index, _type, normalized, value) };
}

pub fn retrace_glVertexAttribP1uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_PGLuint42_0 = (call.arg(3)).to_array().unwrap();
    value[0] = (_a_PGLuint42_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexAttribP1uiv(index, _type, normalized, value) };
}

pub fn retrace_glVertexAttribP2ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(2)).to_u32().unwrap() as u8;

    let mut value: GLuint;
    value = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::VertexAttribP2ui(index, _type, normalized, value) };
}

pub fn retrace_glVertexAttribP2uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_PGLuint43_0 = (call.arg(3)).to_array().unwrap();
    value[0] = (_a_PGLuint43_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexAttribP2uiv(index, _type, normalized, value) };
}

pub fn retrace_glVertexAttribP3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(2)).to_u32().unwrap() as u8;

    let mut value: GLuint;
    value = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::VertexAttribP3ui(index, _type, normalized, value) };
}

pub fn retrace_glVertexAttribP3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_PGLuint44_0 = (call.arg(3)).to_array().unwrap();
    value[0] = (_a_PGLuint44_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexAttribP3uiv(index, _type, normalized, value) };
}

pub fn retrace_glVertexAttribP4ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(2)).to_u32().unwrap() as u8;

    let mut value: GLuint;
    value = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::VertexAttribP4ui(index, _type, normalized, value) };
}

pub fn retrace_glVertexAttribP4uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(2)).to_u32().unwrap() as u8;

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_PGLuint45_0 = (call.arg(3)).to_array().unwrap();
    value[0] = (_a_PGLuint45_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexAttribP4uiv(index, _type, normalized, value) };
}

pub fn retrace_glVertexP2ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLuint;
    value = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexP2ui(_type, value) };
}

pub fn retrace_glVertexP2uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint46_0 = (call.arg(1)).to_array().unwrap();
    value[0] = (_a_PGLuint46_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexP2uiv(_type, value) };
}

pub fn retrace_glVertexP3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLuint;
    value = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexP3ui(_type, value) };
}

pub fn retrace_glVertexP3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint47_0 = (call.arg(1)).to_array().unwrap();
    value[0] = (_a_PGLuint47_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexP3uiv(_type, value) };
}

pub fn retrace_glVertexP4ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLuint;
    value = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexP4ui(_type, value) };
}

pub fn retrace_glVertexP4uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint48_0 = (call.arg(1)).to_array().unwrap();
    value[0] = (_a_PGLuint48_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexP4uiv(_type, value) };
}

pub fn retrace_glTexCoordP1ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coords: GLuint;
    coords = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::TexCoordP1ui(_type, coords) };
}

pub fn retrace_glTexCoordP1uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLuint];
    coords = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint49_0 = (call.arg(1)).to_array().unwrap();
    coords[0] = (_a_PGLuint49_0.values[0]).to_u32().unwrap();

    unsafe { gl::TexCoordP1uiv(_type, coords) };
}

pub fn retrace_glTexCoordP2ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coords: GLuint;
    coords = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::TexCoordP2ui(_type, coords) };
}

pub fn retrace_glTexCoordP2uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLuint];
    coords = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint50_0 = (call.arg(1)).to_array().unwrap();
    coords[0] = (_a_PGLuint50_0.values[0]).to_u32().unwrap();

    unsafe { gl::TexCoordP2uiv(_type, coords) };
}

pub fn retrace_glTexCoordP3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coords: GLuint;
    coords = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::TexCoordP3ui(_type, coords) };
}

pub fn retrace_glTexCoordP3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLuint];
    coords = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint51_0 = (call.arg(1)).to_array().unwrap();
    coords[0] = (_a_PGLuint51_0.values[0]).to_u32().unwrap();

    unsafe { gl::TexCoordP3uiv(_type, coords) };
}

pub fn retrace_glTexCoordP4ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coords: GLuint;
    coords = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::TexCoordP4ui(_type, coords) };
}

pub fn retrace_glTexCoordP4uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLuint];
    coords = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint52_0 = (call.arg(1)).to_array().unwrap();
    coords[0] = (_a_PGLuint52_0.values[0]).to_u32().unwrap();

    unsafe { gl::TexCoordP4uiv(_type, coords) };
}

pub fn retrace_glMultiTexCoordP1ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut coords: GLuint;
    coords = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::MultiTexCoordP1ui(texture, _type, coords) };
}

pub fn retrace_glMultiTexCoordP1uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLuint];
    coords = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_PGLuint53_0 = (call.arg(2)).to_array().unwrap();
    coords[0] = (_a_PGLuint53_0.values[0]).to_u32().unwrap();

    unsafe { gl::MultiTexCoordP1uiv(texture, _type, coords) };
}

pub fn retrace_glMultiTexCoordP2ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut coords: GLuint;
    coords = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::MultiTexCoordP2ui(texture, _type, coords) };
}

pub fn retrace_glMultiTexCoordP2uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLuint];
    coords = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_PGLuint54_0 = (call.arg(2)).to_array().unwrap();
    coords[0] = (_a_PGLuint54_0.values[0]).to_u32().unwrap();

    unsafe { gl::MultiTexCoordP2uiv(texture, _type, coords) };
}

pub fn retrace_glMultiTexCoordP3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut coords: GLuint;
    coords = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::MultiTexCoordP3ui(texture, _type, coords) };
}

pub fn retrace_glMultiTexCoordP3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLuint];
    coords = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_PGLuint55_0 = (call.arg(2)).to_array().unwrap();
    coords[0] = (_a_PGLuint55_0.values[0]).to_u32().unwrap();

    unsafe { gl::MultiTexCoordP3uiv(texture, _type, coords) };
}

pub fn retrace_glMultiTexCoordP4ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut coords: GLuint;
    coords = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::MultiTexCoordP4ui(texture, _type, coords) };
}

pub fn retrace_glMultiTexCoordP4uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLenum;
    texture = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLuint];
    coords = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_PGLuint56_0 = (call.arg(2)).to_array().unwrap();
    coords[0] = (_a_PGLuint56_0.values[0]).to_u32().unwrap();

    unsafe { gl::MultiTexCoordP4uiv(texture, _type, coords) };
}

pub fn retrace_glNormalP3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coords: GLuint;
    coords = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::NormalP3ui(_type, coords) };
}

pub fn retrace_glNormalP3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLuint];
    coords = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint57_0 = (call.arg(1)).to_array().unwrap();
    coords[0] = (_a_PGLuint57_0.values[0]).to_u32().unwrap();

    unsafe { gl::NormalP3uiv(_type, coords) };
}

pub fn retrace_glColorP3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut color: GLuint;
    color = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::ColorP3ui(_type, color) };
}

pub fn retrace_glColorP3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let color: &mut [GLuint];
    color = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint58_0 = (call.arg(1)).to_array().unwrap();
    color[0] = (_a_PGLuint58_0.values[0]).to_u32().unwrap();

    unsafe { gl::ColorP3uiv(_type, color) };
}

pub fn retrace_glColorP4ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut color: GLuint;
    color = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::ColorP4ui(_type, color) };
}

pub fn retrace_glColorP4uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let color: &mut [GLuint];
    color = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint59_0 = (call.arg(1)).to_array().unwrap();
    color[0] = (_a_PGLuint59_0.values[0]).to_u32().unwrap();

    unsafe { gl::ColorP4uiv(_type, color) };
}

pub fn retrace_glSecondaryColorP3ui(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut color: GLuint;
    color = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::SecondaryColorP3ui(_type, color) };
}

pub fn retrace_glSecondaryColorP3uiv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let color: &mut [GLuint];
    color = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint60_0 = (call.arg(1)).to_array().unwrap();
    color[0] = (_a_PGLuint60_0.values[0]).to_u32().unwrap();

    unsafe { gl::SecondaryColorP3uiv(_type, color) };
}

pub fn retrace_glViewportArrayv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLuint;
    first = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat187_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat187_0) = _a_GLfloat187_0 {
        for _jGLfloat187 in 0.._a_GLfloat187_0.values.len() {
    v[_jGLfloat187] = (*_a_GLfloat187_0.values[_jGLfloat187]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    if (first == 0 && count > 0) {
        GLfloat x = v[0], y = v[1], w = v[2], h = v[3];
        glretrace::updateDrawable(x + w, y + h);
    }
    unsafe { gl::ViewportArrayv(first, count, v) };
}

pub fn retrace_glViewportIndexedf(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(3)).to_f32().unwrap();

    let mut h: GLfloat;
    h = (call.arg(4)).to_f32().unwrap();

    if (index == 0) {
        glretrace::updateDrawable(x + w, y + h);
    }
    unsafe { gl::ViewportIndexedf(index, x, y, w, h) };
}

pub fn retrace_glViewportIndexedfv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat188_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat188_0) = _a_GLfloat188_0 {
        for _jGLfloat188 in 0.._a_GLfloat188_0.values.len() {
    v[_jGLfloat188] = (*_a_GLfloat188_0.values[_jGLfloat188]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    if (index == 0) {
        GLfloat x = v[0], y = v[1], w = v[2], h = v[3];
        glretrace::updateDrawable(x + w, y + h);
    }
    unsafe { gl::ViewportIndexedfv(index, v) };
}

pub fn retrace_glScissorArrayv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLuint;
    first = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint210_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint210_0) = _a_GLint210_0 {
        for _jGLint210 in 0.._a_GLint210_0.values.len() {
    v[_jGLint210] = (*_a_GLint210_0.values[_jGLint210]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ScissorArrayv(first, count, v) };
}

pub fn retrace_glScissorIndexed(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut left: GLint;
    left = (call.arg(1)).to_i32().unwrap();

    let mut bottom: GLint;
    bottom = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::ScissorIndexed(index, left, bottom, width, height) };
}

pub fn retrace_glScissorIndexedv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint211_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint211_0) = _a_GLint211_0 {
        for _jGLint211 in 0.._a_GLint211_0.values.len() {
    v[_jGLint211] = (*_a_GLint211_0.values[_jGLint211]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ScissorIndexedv(index, v) };
}

pub fn retrace_glDepthRangeArrayv(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLuint;
    first = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble97_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble97_0) = _a_GLdouble97_0 {
        for _jGLdouble97 in 0.._a_GLdouble97_0.values.len() {
    v[_jGLdouble97] = (*_a_GLdouble97_0.values[_jGLdouble97]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DepthRangeArrayv(first, count, v) };
}

pub fn retrace_glDepthRangeIndexed(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut n: GLdouble;
    n = (call.arg(1)).to_f64().unwrap();

    let mut f: GLdouble;
    f = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::DepthRangeIndexed(index, n, f) };
}

pub fn retrace_glWindowPos2dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::WindowPos2dARB(x, y) };
}

pub fn retrace_glWindowPos2dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble98_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble98_0) = _a_GLdouble98_0 {
        for _jGLdouble98 in 0.._a_GLdouble98_0.values.len() {
    v[_jGLdouble98] = (*_a_GLdouble98_0.values[_jGLdouble98]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2dvARB(v) };
}

pub fn retrace_glWindowPos2fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::WindowPos2fARB(x, y) };
}

pub fn retrace_glWindowPos2fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat189_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat189_0) = _a_GLfloat189_0 {
        for _jGLfloat189 in 0.._a_GLfloat189_0.values.len() {
    v[_jGLfloat189] = (*_a_GLfloat189_0.values[_jGLfloat189]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2fvARB(v) };
}

pub fn retrace_glWindowPos2iARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::WindowPos2iARB(x, y) };
}

pub fn retrace_glWindowPos2ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint212_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint212_0) = _a_GLint212_0 {
        for _jGLint212 in 0.._a_GLint212_0.values.len() {
    v[_jGLint212] = (*_a_GLint212_0.values[_jGLint212]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2ivARB(v) };
}

pub fn retrace_glWindowPos2sARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::WindowPos2sARB(x, y) };
}

pub fn retrace_glWindowPos2svARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort34_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort34_0) = _a_GLshort34_0 {
        for _jGLshort34 in 0.._a_GLshort34_0.values.len() {
    v[_jGLshort34] = (*_a_GLshort34_0.values[_jGLshort34]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2svARB(v) };
}

pub fn retrace_glWindowPos3dARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::WindowPos3dARB(x, y, z) };
}

pub fn retrace_glWindowPos3dvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble99_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble99_0) = _a_GLdouble99_0 {
        for _jGLdouble99 in 0.._a_GLdouble99_0.values.len() {
    v[_jGLdouble99] = (*_a_GLdouble99_0.values[_jGLdouble99]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3dvARB(v) };
}

pub fn retrace_glWindowPos3fARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::WindowPos3fARB(x, y, z) };
}

pub fn retrace_glWindowPos3fvARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat190_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat190_0) = _a_GLfloat190_0 {
        for _jGLfloat190 in 0.._a_GLfloat190_0.values.len() {
    v[_jGLfloat190] = (*_a_GLfloat190_0.values[_jGLfloat190]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3fvARB(v) };
}

pub fn retrace_glWindowPos3iARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::WindowPos3iARB(x, y, z) };
}

pub fn retrace_glWindowPos3ivARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint213_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint213_0) = _a_GLint213_0 {
        for _jGLint213 in 0.._a_GLint213_0.values.len() {
    v[_jGLint213] = (*_a_GLint213_0.values[_jGLint213]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3ivARB(v) };
}

pub fn retrace_glWindowPos3sARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::WindowPos3sARB(x, y, z) };
}

pub fn retrace_glWindowPos3svARB(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort35_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort35_0) = _a_GLshort35_0 {
        for _jGLshort35 in 0.._a_GLshort35_0.values.len() {
    v[_jGLshort35] = (*_a_GLshort35_0.values[_jGLshort35]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3svARB(v) };
}

pub fn retrace_glDrawBuffersATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let bufs: &mut [GLenum];
    bufs = _allocator.alloc_array::<GLenum>(&call.arg(1));
    let _a_GLenum22_0 = (call.arg(1)).to_array();
    if let Some(_a_GLenum22_0) = _a_GLenum22_0 {
        for _jGLenum22 in 0.._a_GLenum22_0.values.len() {
    bufs[_jGLenum22] = (*_a_GLenum22_0.values[_jGLenum22]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DrawBuffersATI(n, bufs) };
}

pub fn retrace_glElementPointerATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::ElementPointerATI(_type, pointer) };
}

pub fn retrace_glDrawElementArrayATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::DrawElementArrayATI(mode, count) };
}

pub fn retrace_glDrawRangeElementArrayATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLuint;
    start = (call.arg(1)).to_u32().unwrap();

    let mut end: GLuint;
    end = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::DrawRangeElementArrayATI(mode, start, end, count) };
}

pub fn retrace_glTexBumpParameterivATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let param: &mut [GLint];
    param = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint214_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint214_0) = _a_GLint214_0 {
        for _jGLint214 in 0.._a_GLint214_0.values.len() {
    param[_jGLint214] = (*_a_GLint214_0.values[_jGLint214]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexBumpParameterivATI(pname, param) };
}

pub fn retrace_glTexBumpParameterfvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let param: &mut [GLfloat];
    param = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat191_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat191_0) = _a_GLfloat191_0 {
        for _jGLfloat191 in 0.._a_GLfloat191_0.values.len() {
    param[_jGLfloat191] = (*_a_GLfloat191_0.values[_jGLfloat191]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexBumpParameterfvATI(pname, param) };
}

pub fn retrace_glBlendEquationSeparateATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut equationRGB: GLenum;
    equationRGB = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut equationAlpha: GLenum;
    equationAlpha = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationSeparateATI(equationRGB, equationAlpha) };
}

pub fn retrace_glGenFragmentShadersATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut range: GLuint;
    range = (call.arg(0)).to_u32().unwrap();

    let _result = unsafe { gl::GenFragmentShadersATI(range) };

    let _origResult: GLuint;
    _origResult = (*call.ret).to_u32().unwrap();
    for _hPGLuint22 in 0..range {
        _fragmentShaderATI_map[_origResult + _hPGLuint22] = _result + _hPGLuint22;
    }
}

pub fn retrace_glBindFragmentShaderATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _fragmentShaderATI_map[id];

    unsafe { gl::BindFragmentShaderATI(id) };
}

pub fn retrace_glDeleteFragmentShaderATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _fragmentShaderATI_map[id];

    unsafe { gl::DeleteFragmentShaderATI(id) };
}

pub fn retrace_glBeginFragmentShaderATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::BeginFragmentShaderATI() };
}

pub fn retrace_glEndFragmentShaderATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::EndFragmentShaderATI() };
}

pub fn retrace_glPassTexCoordATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut dst: GLenum;
    dst = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coord: GLenum;
    coord = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut swizzle: GLenum;
    swizzle = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::PassTexCoordATI(dst, coord, swizzle) };
}

pub fn retrace_glSampleMapATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut dst: GLenum;
    dst = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut interp: GLenum;
    interp = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut swizzle: GLenum;
    swizzle = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::SampleMapATI(dst, interp, swizzle) };
}

pub fn retrace_glColorFragmentOp1ATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut op: GLenum;
    op = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dst: GLenum;
    dst = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dstMask: GLuint;
    dstMask = (call.arg(2)).to_u32().unwrap();

    let mut dstMod: GLuint;
    dstMod = (call.arg(3)).to_u32().unwrap();

    let mut arg1: GLenum;
    arg1 = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut arg1Rep: GLuint;
    arg1Rep = (call.arg(5)).to_u32().unwrap();

    let mut arg1Mod: GLuint;
    arg1Mod = (call.arg(6)).to_u32().unwrap();

    unsafe { gl::ColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod) };
}

pub fn retrace_glColorFragmentOp2ATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut op: GLenum;
    op = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dst: GLenum;
    dst = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dstMask: GLuint;
    dstMask = (call.arg(2)).to_u32().unwrap();

    let mut dstMod: GLuint;
    dstMod = (call.arg(3)).to_u32().unwrap();

    let mut arg1: GLenum;
    arg1 = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut arg1Rep: GLuint;
    arg1Rep = (call.arg(5)).to_u32().unwrap();

    let mut arg1Mod: GLuint;
    arg1Mod = (call.arg(6)).to_u32().unwrap();

    let mut arg2: GLenum;
    arg2 = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut arg2Rep: GLuint;
    arg2Rep = (call.arg(8)).to_u32().unwrap();

    let mut arg2Mod: GLuint;
    arg2Mod = (call.arg(9)).to_u32().unwrap();

    unsafe { gl::ColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod) };
}

pub fn retrace_glColorFragmentOp3ATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut op: GLenum;
    op = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dst: GLenum;
    dst = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dstMask: GLuint;
    dstMask = (call.arg(2)).to_u32().unwrap();

    let mut dstMod: GLuint;
    dstMod = (call.arg(3)).to_u32().unwrap();

    let mut arg1: GLenum;
    arg1 = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut arg1Rep: GLuint;
    arg1Rep = (call.arg(5)).to_u32().unwrap();

    let mut arg1Mod: GLuint;
    arg1Mod = (call.arg(6)).to_u32().unwrap();

    let mut arg2: GLenum;
    arg2 = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut arg2Rep: GLuint;
    arg2Rep = (call.arg(8)).to_u32().unwrap();

    let mut arg2Mod: GLuint;
    arg2Mod = (call.arg(9)).to_u32().unwrap();

    let mut arg3: GLenum;
    arg3 = (call.arg(10)).to_u32().unwrap().try_into().unwrap();

    let mut arg3Rep: GLuint;
    arg3Rep = (call.arg(11)).to_u32().unwrap();

    let mut arg3Mod: GLuint;
    arg3Mod = (call.arg(12)).to_u32().unwrap();

    unsafe { gl::ColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod) };
}

pub fn retrace_glAlphaFragmentOp1ATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut op: GLenum;
    op = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dst: GLenum;
    dst = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dstMod: GLuint;
    dstMod = (call.arg(2)).to_u32().unwrap();

    let mut arg1: GLenum;
    arg1 = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut arg1Rep: GLuint;
    arg1Rep = (call.arg(4)).to_u32().unwrap();

    let mut arg1Mod: GLuint;
    arg1Mod = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::AlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod) };
}

pub fn retrace_glAlphaFragmentOp2ATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut op: GLenum;
    op = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dst: GLenum;
    dst = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dstMod: GLuint;
    dstMod = (call.arg(2)).to_u32().unwrap();

    let mut arg1: GLenum;
    arg1 = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut arg1Rep: GLuint;
    arg1Rep = (call.arg(4)).to_u32().unwrap();

    let mut arg1Mod: GLuint;
    arg1Mod = (call.arg(5)).to_u32().unwrap();

    let mut arg2: GLenum;
    arg2 = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut arg2Rep: GLuint;
    arg2Rep = (call.arg(7)).to_u32().unwrap();

    let mut arg2Mod: GLuint;
    arg2Mod = (call.arg(8)).to_u32().unwrap();

    unsafe { gl::AlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod) };
}

pub fn retrace_glAlphaFragmentOp3ATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut op: GLenum;
    op = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dst: GLenum;
    dst = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dstMod: GLuint;
    dstMod = (call.arg(2)).to_u32().unwrap();

    let mut arg1: GLenum;
    arg1 = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut arg1Rep: GLuint;
    arg1Rep = (call.arg(4)).to_u32().unwrap();

    let mut arg1Mod: GLuint;
    arg1Mod = (call.arg(5)).to_u32().unwrap();

    let mut arg2: GLenum;
    arg2 = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut arg2Rep: GLuint;
    arg2Rep = (call.arg(7)).to_u32().unwrap();

    let mut arg2Mod: GLuint;
    arg2Mod = (call.arg(8)).to_u32().unwrap();

    let mut arg3: GLenum;
    arg3 = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let mut arg3Rep: GLuint;
    arg3Rep = (call.arg(10)).to_u32().unwrap();

    let mut arg3Mod: GLuint;
    arg3Mod = (call.arg(11)).to_u32().unwrap();

    unsafe { gl::AlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod) };
}

pub fn retrace_glSetFragmentShaderConstantATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut dst: GLenum;
    dst = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat192_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat192_0) = _a_GLfloat192_0 {
        for _jGLfloat192 in 0.._a_GLfloat192_0.values.len() {
    value[_jGLfloat192] = (*_a_GLfloat192_0.values[_jGLfloat192]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SetFragmentShaderConstantATI(dst, value) };
}

pub fn retrace_glMapObjectBufferATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let _result = unsafe { gl::MapObjectBufferATI(buffer) };

    let length = 0;
    gl::GetObjectBufferivATI(buffer, gl::OBJECT_BUFFER_SIZE_ATI, &length);
    retrace::addRegion(call, (*call.ret).toUIntPtr(), _result, length);
}

pub fn retrace_glUnmapObjectBufferATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

        GLvoid *ptr = NULL;
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "failed to get mapped pointer\n";
        }
    unsafe { gl::UnmapObjectBufferATI(buffer) };
}

pub fn retrace_glPNTrianglesiATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PNTrianglesiATI(pname, param) };
}

pub fn retrace_glPNTrianglesfATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PNTrianglesfATI(pname, param) };
}

pub fn retrace_glPNTrianglesiATIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PNTrianglesiATIX(pname, param) };
}

pub fn retrace_glPNTrianglesfATIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PNTrianglesfATIX(pname, param) };
}

pub fn retrace_glStencilOpSeparateATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut sfail: GLenum;
    sfail = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dpfail: GLenum;
    dpfail = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut dppass: GLenum;
    dppass = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::StencilOpSeparateATI(face, sfail, dpfail, dppass) };
}

pub fn retrace_glStencilFuncSeparateATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut frontfunc: GLenum;
    frontfunc = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut backfunc: GLenum;
    backfunc = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _ref: GLint;
    _ref = (call.arg(2)).to_i32().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::StencilFuncSeparateATI(frontfunc, backfunc, _ref, mask) };
}

pub fn retrace_glNewObjectBufferATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLsizei;
    size = (call.arg(0)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    let pointer = (call.arg(1)).to_pointer().unwrap() as *mut c_void;

    let mut usage: GLenum;
    usage = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::NewObjectBufferATI(size, pointer, usage) };

}

pub fn retrace_glUpdateObjectBufferATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();

    let mut offset: GLuint;
    offset = (call.arg(1)).to_u32().unwrap();

    let mut size: GLsizei;
    size = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    let pointer = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut preserve: GLenum;
    preserve = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::UpdateObjectBufferATI(buffer, offset, size, pointer, preserve) };
}

pub fn retrace_glFreeObjectBufferATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::FreeObjectBufferATI(buffer) };
}

pub fn retrace_glArrayObjectATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut array: GLenum;
    array = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(4)).to_u32().unwrap();

    let mut offset: GLuint;
    offset = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::ArrayObjectATI(array, size, _type, stride, buffer, offset) };
}

pub fn retrace_glVariantArrayObjectATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(3)).to_u32().unwrap();

    let mut offset: GLuint;
    offset = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VariantArrayObjectATI(id, _type, stride, buffer, offset) };
}

pub fn retrace_glVertexAttribArrayObjectATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(3)).to_u32().unwrap() as u8;

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(5)).to_u32().unwrap();

    let mut offset: GLuint;
    offset = (call.arg(6)).to_u32().unwrap();

    unsafe { gl::VertexAttribArrayObjectATI(index, size, _type, normalized, stride, buffer, offset) };
}

pub fn retrace_glVertexStream1sATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::VertexStream1sATI(stream, x) };
}

pub fn retrace_glVertexStream1svATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLshort];
    coords = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_PGLshort6_0 = (call.arg(1)).to_array().unwrap();
    coords[0] = (_a_PGLshort6_0.values[0]).to_i32().unwrap();

    unsafe { gl::VertexStream1svATI(stream, coords) };
}

pub fn retrace_glVertexStream1iATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::VertexStream1iATI(stream, x) };
}

pub fn retrace_glVertexStream1ivATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLint];
    coords = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_PGLint34_0 = (call.arg(1)).to_array().unwrap();
    coords[0] = (_a_PGLint34_0.values[0]).to_i32().unwrap();

    unsafe { gl::VertexStream1ivATI(stream, coords) };
}

pub fn retrace_glVertexStream1fATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::VertexStream1fATI(stream, x) };
}

pub fn retrace_glVertexStream1fvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLfloat];
    coords = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_PGLfloat19_0 = (call.arg(1)).to_array().unwrap();
    coords[0] = (_a_PGLfloat19_0.values[0]).to_f32().unwrap();

    unsafe { gl::VertexStream1fvATI(stream, coords) };
}

pub fn retrace_glVertexStream1dATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::VertexStream1dATI(stream, x) };
}

pub fn retrace_glVertexStream1dvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLdouble];
    coords = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_PGLdouble10_0 = (call.arg(1)).to_array().unwrap();
    coords[0] = (_a_PGLdouble10_0.values[0]).to_f64().unwrap();

    unsafe { gl::VertexStream1dvATI(stream, coords) };
}

pub fn retrace_glVertexStream2sATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::VertexStream2sATI(stream, x, y) };
}

pub fn retrace_glVertexStream2svATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLshort];
    coords = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort36_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort36_0) = _a_GLshort36_0 {
        for _jGLshort36 in 0.._a_GLshort36_0.values.len() {
    coords[_jGLshort36] = (*_a_GLshort36_0.values[_jGLshort36]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream2svATI(stream, coords) };
}

pub fn retrace_glVertexStream2iATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::VertexStream2iATI(stream, x, y) };
}

pub fn retrace_glVertexStream2ivATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLint];
    coords = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint215_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint215_0) = _a_GLint215_0 {
        for _jGLint215 in 0.._a_GLint215_0.values.len() {
    coords[_jGLint215] = (*_a_GLint215_0.values[_jGLint215]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream2ivATI(stream, coords) };
}

pub fn retrace_glVertexStream2fATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::VertexStream2fATI(stream, x, y) };
}

pub fn retrace_glVertexStream2fvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLfloat];
    coords = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat193_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat193_0) = _a_GLfloat193_0 {
        for _jGLfloat193 in 0.._a_GLfloat193_0.values.len() {
    coords[_jGLfloat193] = (*_a_GLfloat193_0.values[_jGLfloat193]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream2fvATI(stream, coords) };
}

pub fn retrace_glVertexStream2dATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::VertexStream2dATI(stream, x, y) };
}

pub fn retrace_glVertexStream2dvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLdouble];
    coords = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble100_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble100_0) = _a_GLdouble100_0 {
        for _jGLdouble100 in 0.._a_GLdouble100_0.values.len() {
    coords[_jGLdouble100] = (*_a_GLdouble100_0.values[_jGLdouble100]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream2dvATI(stream, coords) };
}

pub fn retrace_glVertexStream3sATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexStream3sATI(stream, x, y, z) };
}

pub fn retrace_glVertexStream3svATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLshort];
    coords = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort37_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort37_0) = _a_GLshort37_0 {
        for _jGLshort37 in 0.._a_GLshort37_0.values.len() {
    coords[_jGLshort37] = (*_a_GLshort37_0.values[_jGLshort37]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream3svATI(stream, coords) };
}

pub fn retrace_glVertexStream3iATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexStream3iATI(stream, x, y, z) };
}

pub fn retrace_glVertexStream3ivATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLint];
    coords = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint216_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint216_0) = _a_GLint216_0 {
        for _jGLint216 in 0.._a_GLint216_0.values.len() {
    coords[_jGLint216] = (*_a_GLint216_0.values[_jGLint216]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream3ivATI(stream, coords) };
}

pub fn retrace_glVertexStream3fATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::VertexStream3fATI(stream, x, y, z) };
}

pub fn retrace_glVertexStream3fvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLfloat];
    coords = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat194_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat194_0) = _a_GLfloat194_0 {
        for _jGLfloat194 in 0.._a_GLfloat194_0.values.len() {
    coords[_jGLfloat194] = (*_a_GLfloat194_0.values[_jGLfloat194]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream3fvATI(stream, coords) };
}

pub fn retrace_glVertexStream3dATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::VertexStream3dATI(stream, x, y, z) };
}

pub fn retrace_glVertexStream3dvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLdouble];
    coords = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble101_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble101_0) = _a_GLdouble101_0 {
        for _jGLdouble101 in 0.._a_GLdouble101_0.values.len() {
    coords[_jGLdouble101] = (*_a_GLdouble101_0.values[_jGLdouble101]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream3dvATI(stream, coords) };
}

pub fn retrace_glVertexStream4sATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(3)).to_i32().unwrap();

    let mut w: GLshort;
    w = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexStream4sATI(stream, x, y, z, w) };
}

pub fn retrace_glVertexStream4svATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLshort];
    coords = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort38_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort38_0) = _a_GLshort38_0 {
        for _jGLshort38 in 0.._a_GLshort38_0.values.len() {
    coords[_jGLshort38] = (*_a_GLshort38_0.values[_jGLshort38]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream4svATI(stream, coords) };
}

pub fn retrace_glVertexStream4iATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(3)).to_i32().unwrap();

    let mut w: GLint;
    w = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexStream4iATI(stream, x, y, z, w) };
}

pub fn retrace_glVertexStream4ivATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLint];
    coords = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint217_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint217_0) = _a_GLint217_0 {
        for _jGLint217 in 0.._a_GLint217_0.values.len() {
    coords[_jGLint217] = (*_a_GLint217_0.values[_jGLint217]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream4ivATI(stream, coords) };
}

pub fn retrace_glVertexStream4fATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::VertexStream4fATI(stream, x, y, z, w) };
}

pub fn retrace_glVertexStream4fvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLfloat];
    coords = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat195_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat195_0) = _a_GLfloat195_0 {
        for _jGLfloat195 in 0.._a_GLfloat195_0.values.len() {
    coords[_jGLfloat195] = (*_a_GLfloat195_0.values[_jGLfloat195]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream4fvATI(stream, coords) };
}

pub fn retrace_glVertexStream4dATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::VertexStream4dATI(stream, x, y, z, w) };
}

pub fn retrace_glVertexStream4dvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLdouble];
    coords = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble102_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble102_0) = _a_GLdouble102_0 {
        for _jGLdouble102 in 0.._a_GLdouble102_0.values.len() {
    coords[_jGLdouble102] = (*_a_GLdouble102_0.values[_jGLdouble102]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexStream4dvATI(stream, coords) };
}

pub fn retrace_glNormalStream3bATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut nx: GLbyte;
    nx = (call.arg(1)).to_i32().unwrap();

    let mut ny: GLbyte;
    ny = (call.arg(2)).to_i32().unwrap();

    let mut nz: GLbyte;
    nz = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::NormalStream3bATI(stream, nx, ny, nz) };
}

pub fn retrace_glNormalStream3bvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLbyte];
    coords = _allocator.alloc_array::<GLbyte>(&call.arg(1));
    let _a_GLbyte11_0 = (call.arg(1)).to_array();
    if let Some(_a_GLbyte11_0) = _a_GLbyte11_0 {
        for _jGLbyte11 in 0.._a_GLbyte11_0.values.len() {
    coords[_jGLbyte11] = (*_a_GLbyte11_0.values[_jGLbyte11]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NormalStream3bvATI(stream, coords) };
}

pub fn retrace_glNormalStream3sATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut nx: GLshort;
    nx = (call.arg(1)).to_i32().unwrap();

    let mut ny: GLshort;
    ny = (call.arg(2)).to_i32().unwrap();

    let mut nz: GLshort;
    nz = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::NormalStream3sATI(stream, nx, ny, nz) };
}

pub fn retrace_glNormalStream3svATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLshort];
    coords = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort39_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort39_0) = _a_GLshort39_0 {
        for _jGLshort39 in 0.._a_GLshort39_0.values.len() {
    coords[_jGLshort39] = (*_a_GLshort39_0.values[_jGLshort39]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NormalStream3svATI(stream, coords) };
}

pub fn retrace_glNormalStream3iATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut nx: GLint;
    nx = (call.arg(1)).to_i32().unwrap();

    let mut ny: GLint;
    ny = (call.arg(2)).to_i32().unwrap();

    let mut nz: GLint;
    nz = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::NormalStream3iATI(stream, nx, ny, nz) };
}

pub fn retrace_glNormalStream3ivATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLint];
    coords = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint218_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint218_0) = _a_GLint218_0 {
        for _jGLint218 in 0.._a_GLint218_0.values.len() {
    coords[_jGLint218] = (*_a_GLint218_0.values[_jGLint218]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NormalStream3ivATI(stream, coords) };
}

pub fn retrace_glNormalStream3fATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut nx: GLfloat;
    nx = (call.arg(1)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(2)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::NormalStream3fATI(stream, nx, ny, nz) };
}

pub fn retrace_glNormalStream3fvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLfloat];
    coords = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat196_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat196_0) = _a_GLfloat196_0 {
        for _jGLfloat196 in 0.._a_GLfloat196_0.values.len() {
    coords[_jGLfloat196] = (*_a_GLfloat196_0.values[_jGLfloat196]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NormalStream3fvATI(stream, coords) };
}

pub fn retrace_glNormalStream3dATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut nx: GLdouble;
    nx = (call.arg(1)).to_f64().unwrap();

    let mut ny: GLdouble;
    ny = (call.arg(2)).to_f64().unwrap();

    let mut nz: GLdouble;
    nz = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::NormalStream3dATI(stream, nx, ny, nz) };
}

pub fn retrace_glNormalStream3dvATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLdouble];
    coords = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble103_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble103_0) = _a_GLdouble103_0 {
        for _jGLdouble103 in 0.._a_GLdouble103_0.values.len() {
    coords[_jGLdouble103] = (*_a_GLdouble103_0.values[_jGLdouble103]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NormalStream3dvATI(stream, coords) };
}

pub fn retrace_glClientActiveVertexStreamATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stream: GLenum;
    stream = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ClientActiveVertexStreamATI(stream) };
}

pub fn retrace_glVertexBlendEnviATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::VertexBlendEnviATI(pname, param) };
}

pub fn retrace_glVertexBlendEnvfATI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::VertexBlendEnvfATI(pname, param) };
}

pub fn retrace_glDrawArraysInstancedBaseInstanceEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLint;
    first = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut instancecount: GLsizei;
    instancecount = (call.arg(3)).to_i32().unwrap();

    let mut baseinstance: GLuint;
    baseinstance = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::DrawArraysInstancedBaseInstanceEXT(mode, first, count, instancecount, baseinstance) };
}

pub fn retrace_glDrawElementsInstancedBaseInstanceEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut instancecount: GLsizei;
    instancecount = (call.arg(4)).to_i32().unwrap();

    let mut baseinstance: GLuint;
    baseinstance = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::DrawElementsInstancedBaseInstanceEXT(mode, count, _type, indices, instancecount, baseinstance) };
}

pub fn retrace_glDrawElementsInstancedBaseVertexBaseInstanceEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut instancecount: GLsizei;
    instancecount = (call.arg(4)).to_i32().unwrap();

    let mut basevertex: GLint;
    basevertex = (call.arg(5)).to_i32().unwrap();

    let mut baseinstance: GLuint;
    baseinstance = (call.arg(6)).to_u32().unwrap();

    unsafe { gl::DrawElementsInstancedBaseVertexBaseInstanceEXT(mode, count, _type, indices, instancecount, basevertex, baseinstance) };
}

pub fn retrace_glUniformBufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::UniformBufferEXT(program, location, buffer) };
}

pub fn retrace_glGetUniformBufferSizeEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let _result = unsafe { gl::GetUniformBufferSizeEXT(program, location) };

}

pub fn retrace_glGetUniformOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let _result = unsafe { gl::GetUniformOffsetEXT(program, location) };

}

pub fn retrace_glBlendColorEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLfloat;
    red = (call.arg(0)).to_f32().unwrap();

    let mut green: GLfloat;
    green = (call.arg(1)).to_f32().unwrap();

    let mut blue: GLfloat;
    blue = (call.arg(2)).to_f32().unwrap();

    let mut alpha: GLfloat;
    alpha = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::BlendColorEXT(red, green, blue, alpha) };
}

pub fn retrace_glBlendEquationSeparateEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut modeRGB: GLenum;
    modeRGB = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut modeAlpha: GLenum;
    modeAlpha = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationSeparateEXT(modeRGB, modeAlpha) };
}

pub fn retrace_glBindFragDataLocationIndexedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut colorNumber: GLuint;
    colorNumber = (call.arg(1)).to_u32().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(3)).to_string().unwrap());

    unsafe { gl::BindFragDataLocationIndexedEXT(program, colorNumber, index, name) };
}

pub fn retrace_glBindFragDataLocationEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut color: GLuint;
    color = (call.arg(1)).to_u32().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(2)).to_string().unwrap());

    unsafe { gl::BindFragDataLocationEXT(program, color, name) };
}

pub fn retrace_glGetProgramResourceLocationIndexEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut programInterface: GLenum;
    programInterface = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(2)).to_string().unwrap());

    let _result = unsafe { gl::GetProgramResourceLocationIndexEXT(program, programInterface, name) };

    let _origResult: GLint;
    _origResult = (*call.ret).to_i32().unwrap();
    _location_map[program][_origResult] = _result;
}

pub fn retrace_glGetFragDataIndexEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(1)).to_string().unwrap());

    let _result = unsafe { gl::GetFragDataIndexEXT(program, name) };

}

pub fn retrace_glBlendFuncSeparateEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sfactorRGB: GLenum;
    sfactorRGB = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dfactorRGB: GLenum;
    dfactorRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut sfactorAlpha: GLenum;
    sfactorAlpha = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut dfactorAlpha: GLenum;
    dfactorAlpha = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha) };
}

pub fn retrace_glBlendEquationEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationEXT(mode) };
}

pub fn retrace_glBufferStorageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(1)).to_i32().unwrap();

    let data: &mut [void];
    let data = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut flags: GLbitfield;
    flags = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::BufferStorageEXT(target, size, data, flags) };
}

pub fn retrace_glClearTexImageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(4)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ClearTexImageEXT(texture, level, format, _type, data) };
}

pub fn retrace_glClearTexSubImageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ClearTexSubImageEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, _type, data) };
}

pub fn retrace_glClipControlEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut origin: GLenum;
    origin = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut depth: GLenum;
    depth = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ClipControlEXT(origin, depth) };
}

pub fn retrace_glColorSubTableEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLsizei;
    start = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ColorSubTableEXT(target, start, count, format, _type, data) };
}

pub fn retrace_glCopyColorSubTableEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLsizei;
    start = (call.arg(1)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::CopyColorSubTableEXT(target, start, x, y, width) };
}

pub fn retrace_glLockArraysEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLint;
    first = (call.arg(0)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::LockArraysEXT(first, count) };
}

pub fn retrace_glUnlockArraysEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::UnlockArraysEXT() };
}

pub fn retrace_glConvolutionFilter1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let image: &mut [GLvoid];
    let image = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ConvolutionFilter1DEXT(target, internalformat, width, format, _type, image) };
}

pub fn retrace_glConvolutionFilter2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let image: &mut [GLvoid];
    let image = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ConvolutionFilter2DEXT(target, internalformat, width, height, format, _type, image) };
}

pub fn retrace_glConvolutionParameterfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut params: GLfloat;
    params = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::ConvolutionParameterfEXT(target, pname, params) };
}

pub fn retrace_glConvolutionParameterfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat197_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat197_0) = _a_GLfloat197_0 {
        for _jGLfloat197 in 0.._a_GLfloat197_0.values.len() {
    params[_jGLfloat197] = (*_a_GLfloat197_0.values[_jGLfloat197]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ConvolutionParameterfvEXT(target, pname, params) };
}

pub fn retrace_glConvolutionParameteriEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut params: GLint;
    params = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ConvolutionParameteriEXT(target, pname, params) };
}

pub fn retrace_glConvolutionParameterivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint219_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint219_0) = _a_GLint219_0 {
        for _jGLint219 in 0.._a_GLint219_0.values.len() {
    params[_jGLint219] = (*_a_GLint219_0.values[_jGLint219]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ConvolutionParameterivEXT(target, pname, params) };
}

pub fn retrace_glCopyConvolutionFilter1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::CopyConvolutionFilter1DEXT(target, internalformat, x, y, width) };
}

pub fn retrace_glCopyConvolutionFilter2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::CopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height) };
}

pub fn retrace_glGetConvolutionFilterEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let image: &mut [GLvoid];
    image = (call.arg(3)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetConvolutionFilterEXT(target, format, _type, image) };
}

pub fn retrace_glGetSeparableFilterEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let row: &mut [GLvoid];
    row = (call.arg(3)).to_pointer();

    let column: &mut [GLvoid];
    column = (call.arg(4)).to_pointer();

    let span: &mut [GLvoid];
    span = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetSeparableFilterEXT(target, format, _type, row, column, span) };
}

pub fn retrace_glSeparableFilter2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let row: &mut [GLvoid];
    let row = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    let column: &mut [GLvoid];
    let column = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::SeparableFilter2DEXT(target, internalformat, width, height, format, _type, row, column) };
}

pub fn retrace_glTangent3bEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut tx: GLbyte;
    tx = (call.arg(0)).to_i32().unwrap();

    let mut ty: GLbyte;
    ty = (call.arg(1)).to_i32().unwrap();

    let mut tz: GLbyte;
    tz = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Tangent3bEXT(tx, ty, tz) };
}

pub fn retrace_glTangent3bvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(0));
    let _a_GLbyte12_0 = (call.arg(0)).to_array();
    if let Some(_a_GLbyte12_0) = _a_GLbyte12_0 {
        for _jGLbyte12 in 0.._a_GLbyte12_0.values.len() {
    v[_jGLbyte12] = (*_a_GLbyte12_0.values[_jGLbyte12]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Tangent3bvEXT(v) };
}

pub fn retrace_glTangent3dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut tx: GLdouble;
    tx = (call.arg(0)).to_f64().unwrap();

    let mut ty: GLdouble;
    ty = (call.arg(1)).to_f64().unwrap();

    let mut tz: GLdouble;
    tz = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::Tangent3dEXT(tx, ty, tz) };
}

pub fn retrace_glTangent3dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble104_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble104_0) = _a_GLdouble104_0 {
        for _jGLdouble104 in 0.._a_GLdouble104_0.values.len() {
    v[_jGLdouble104] = (*_a_GLdouble104_0.values[_jGLdouble104]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Tangent3dvEXT(v) };
}

pub fn retrace_glTangent3fEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut tx: GLfloat;
    tx = (call.arg(0)).to_f32().unwrap();

    let mut ty: GLfloat;
    ty = (call.arg(1)).to_f32().unwrap();

    let mut tz: GLfloat;
    tz = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Tangent3fEXT(tx, ty, tz) };
}

pub fn retrace_glTangent3fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat198_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat198_0) = _a_GLfloat198_0 {
        for _jGLfloat198 in 0.._a_GLfloat198_0.values.len() {
    v[_jGLfloat198] = (*_a_GLfloat198_0.values[_jGLfloat198]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Tangent3fvEXT(v) };
}

pub fn retrace_glTangent3iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut tx: GLint;
    tx = (call.arg(0)).to_i32().unwrap();

    let mut ty: GLint;
    ty = (call.arg(1)).to_i32().unwrap();

    let mut tz: GLint;
    tz = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Tangent3iEXT(tx, ty, tz) };
}

pub fn retrace_glTangent3ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint220_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint220_0) = _a_GLint220_0 {
        for _jGLint220 in 0.._a_GLint220_0.values.len() {
    v[_jGLint220] = (*_a_GLint220_0.values[_jGLint220]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Tangent3ivEXT(v) };
}

pub fn retrace_glTangent3sEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut tx: GLshort;
    tx = (call.arg(0)).to_i32().unwrap();

    let mut ty: GLshort;
    ty = (call.arg(1)).to_i32().unwrap();

    let mut tz: GLshort;
    tz = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Tangent3sEXT(tx, ty, tz) };
}

pub fn retrace_glTangent3svEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort40_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort40_0) = _a_GLshort40_0 {
        for _jGLshort40 in 0.._a_GLshort40_0.values.len() {
    v[_jGLshort40] = (*_a_GLshort40_0.values[_jGLshort40]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Tangent3svEXT(v) };
}

pub fn retrace_glBinormal3bEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut bx: GLbyte;
    bx = (call.arg(0)).to_i32().unwrap();

    let mut by: GLbyte;
    by = (call.arg(1)).to_i32().unwrap();

    let mut bz: GLbyte;
    bz = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Binormal3bEXT(bx, by, bz) };
}

pub fn retrace_glBinormal3bvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(0));
    let _a_GLbyte13_0 = (call.arg(0)).to_array();
    if let Some(_a_GLbyte13_0) = _a_GLbyte13_0 {
        for _jGLbyte13 in 0.._a_GLbyte13_0.values.len() {
    v[_jGLbyte13] = (*_a_GLbyte13_0.values[_jGLbyte13]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Binormal3bvEXT(v) };
}

pub fn retrace_glBinormal3dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut bx: GLdouble;
    bx = (call.arg(0)).to_f64().unwrap();

    let mut by: GLdouble;
    by = (call.arg(1)).to_f64().unwrap();

    let mut bz: GLdouble;
    bz = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::Binormal3dEXT(bx, by, bz) };
}

pub fn retrace_glBinormal3dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble105_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble105_0) = _a_GLdouble105_0 {
        for _jGLdouble105 in 0.._a_GLdouble105_0.values.len() {
    v[_jGLdouble105] = (*_a_GLdouble105_0.values[_jGLdouble105]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Binormal3dvEXT(v) };
}

pub fn retrace_glBinormal3fEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut bx: GLfloat;
    bx = (call.arg(0)).to_f32().unwrap();

    let mut by: GLfloat;
    by = (call.arg(1)).to_f32().unwrap();

    let mut bz: GLfloat;
    bz = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::Binormal3fEXT(bx, by, bz) };
}

pub fn retrace_glBinormal3fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat199_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat199_0) = _a_GLfloat199_0 {
        for _jGLfloat199 in 0.._a_GLfloat199_0.values.len() {
    v[_jGLfloat199] = (*_a_GLfloat199_0.values[_jGLfloat199]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Binormal3fvEXT(v) };
}

pub fn retrace_glBinormal3iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut bx: GLint;
    bx = (call.arg(0)).to_i32().unwrap();

    let mut by: GLint;
    by = (call.arg(1)).to_i32().unwrap();

    let mut bz: GLint;
    bz = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Binormal3iEXT(bx, by, bz) };
}

pub fn retrace_glBinormal3ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint221_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint221_0) = _a_GLint221_0 {
        for _jGLint221 in 0.._a_GLint221_0.values.len() {
    v[_jGLint221] = (*_a_GLint221_0.values[_jGLint221]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Binormal3ivEXT(v) };
}

pub fn retrace_glBinormal3sEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut bx: GLshort;
    bx = (call.arg(0)).to_i32().unwrap();

    let mut by: GLshort;
    by = (call.arg(1)).to_i32().unwrap();

    let mut bz: GLshort;
    bz = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Binormal3sEXT(bx, by, bz) };
}

pub fn retrace_glBinormal3svEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort41_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort41_0) = _a_GLshort41_0 {
        for _jGLshort41 in 0.._a_GLshort41_0.values.len() {
    v[_jGLshort41] = (*_a_GLshort41_0.values[_jGLshort41]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Binormal3svEXT(v) };
}

pub fn retrace_glTangentPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::TangentPointerEXT(_type, stride, pointer) };
}

pub fn retrace_glBinormalPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::BinormalPointerEXT(_type, stride, pointer) };
}

pub fn retrace_glCopyImageSubDataEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut srcName: GLuint;
    srcName = (call.arg(0)).to_u32().unwrap();
    srcName = _texture_map[srcName];

    let mut srcTarget: GLenum;
    srcTarget = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut srcLevel: GLint;
    srcLevel = (call.arg(2)).to_i32().unwrap();

    let mut srcX: GLint;
    srcX = (call.arg(3)).to_i32().unwrap();

    let mut srcY: GLint;
    srcY = (call.arg(4)).to_i32().unwrap();

    let mut srcZ: GLint;
    srcZ = (call.arg(5)).to_i32().unwrap();

    let mut dstName: GLuint;
    dstName = (call.arg(6)).to_u32().unwrap();
    dstName = _texture_map[dstName];

    let mut dstTarget: GLenum;
    dstTarget = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut dstLevel: GLint;
    dstLevel = (call.arg(8)).to_i32().unwrap();

    let mut dstX: GLint;
    dstX = (call.arg(9)).to_i32().unwrap();

    let mut dstY: GLint;
    dstY = (call.arg(10)).to_i32().unwrap();

    let mut dstZ: GLint;
    dstZ = (call.arg(11)).to_i32().unwrap();

    let mut srcWidth: GLsizei;
    srcWidth = (call.arg(12)).to_i32().unwrap();

    let mut srcHeight: GLsizei;
    srcHeight = (call.arg(13)).to_i32().unwrap();

    let mut srcDepth: GLsizei;
    srcDepth = (call.arg(14)).to_i32().unwrap();

    if (srcTarget == GL_RENDERBUFFER || dstTarget == GL_RENDERBUFFER) {
        retrace::warning(call) << " renderbuffer targets unsupported (https://git.io/JOMRC)\n";
    }
    unsafe { gl::CopyImageSubDataEXT(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth) };
}

pub fn retrace_glCopyTexImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(3)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::CopyTexImage1DEXT(target, level, internalformat, x, y, width, border) };
}

pub fn retrace_glCopyTexImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(3)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(7)).to_i32().unwrap();

    unsafe { gl::CopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border) };
}

pub fn retrace_glCopyTexSubImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(3)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::CopyTexSubImage1DEXT(target, level, xoffset, x, y, width) };
}

pub fn retrace_glCopyTexSubImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(4)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(7)).to_i32().unwrap();

    unsafe { gl::CopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height) };
}

pub fn retrace_glCopyTexSubImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(5)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(6)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(7)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(8)).to_i32().unwrap();

    unsafe { gl::CopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height) };
}

pub fn retrace_glCullParameterdvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLdouble];
    params = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble106_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble106_0) = _a_GLdouble106_0 {
        for _jGLdouble106 in 0.._a_GLdouble106_0.values.len() {
    params[_jGLdouble106] = (*_a_GLdouble106_0.values[_jGLdouble106]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::CullParameterdvEXT(pname, params) };
}

pub fn retrace_glCullParameterfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat200_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat200_0) = _a_GLfloat200_0 {
        for _jGLfloat200 in 0.._a_GLfloat200_0.values.len() {
    params[_jGLfloat200] = (*_a_GLfloat200_0.values[_jGLfloat200]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::CullParameterfvEXT(pname, params) };
}

pub fn retrace_glLabelObjectEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut object: GLuint;
    object = (call.arg(1)).to_u32().unwrap();

    let mut length: GLsizei;
    length = (call.arg(2)).to_i32().unwrap();

    let label: &mut [GLchar];
    label = (GLchar *)((call.arg(3)).to_string().unwrap());

    unsafe { gl::LabelObjectEXT(_type, object, length, label) };
}

pub fn retrace_glInsertEventMarkerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut length: GLsizei;
    length = (call.arg(0)).to_i32().unwrap();

    let marker: &mut [GLchar];
    marker = (GLchar *)((call.arg(1)).to_string().unwrap());

    unsafe { gl::InsertEventMarkerEXT(length, marker) };
}

pub fn retrace_glPushGroupMarkerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut length: GLsizei;
    length = (call.arg(0)).to_i32().unwrap();

    let marker: &mut [GLchar];
    marker = (GLchar *)((call.arg(1)).to_string().unwrap());

    unsafe { gl::PushGroupMarkerEXT(length, marker) };
}

pub fn retrace_glPopGroupMarkerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PopGroupMarkerEXT() };
}

pub fn retrace_glDepthBoundsEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut zmin: GLclampd;
    zmin = (call.arg(0)).to_f64().unwrap();

    let mut zmax: GLclampd;
    zmax = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::DepthBoundsEXT(zmin, zmax) };
}

pub fn retrace_glBindMultiTextureEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    unsafe { gl::BindMultiTextureEXT(texunit, target, texture) };
}

pub fn retrace_glCheckNamedFramebufferStatusEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::CheckNamedFramebufferStatusEXT(framebuffer, target) };

    let _origResult = call.ret.to_i32().unwrap();
}

pub fn retrace_glClearNamedBufferDataEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [void];
    let data = (call.arg(4)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ClearNamedBufferDataEXT(buffer, internalformat, format, _type, data) };
}

pub fn retrace_glClearNamedBufferSubDataEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLsizeiptr;
    offset = (call.arg(2)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let data: &mut [void];
    let data = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, _type, data) };
}

pub fn retrace_glClientAttribDefaultEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLbitfield;
    mask = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::ClientAttribDefaultEXT(mask) };
}

pub fn retrace_glCompressedMultiTexImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(5)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(6)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits) };
}

pub fn retrace_glCompressedMultiTexImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(7)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits) };
}

pub fn retrace_glCompressedMultiTexImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(6)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(7)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(8)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits) };
}

pub fn retrace_glCompressedMultiTexSubImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(6)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits) };
}

pub fn retrace_glCompressedMultiTexSubImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(8)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits) };
}

pub fn retrace_glCompressedMultiTexSubImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(7)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(8)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(10)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(11)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits) };
}

pub fn retrace_glCompressedTextureImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(5)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(6)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits) };
}

pub fn retrace_glCompressedTextureImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(7)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits) };
}

pub fn retrace_glCompressedTextureImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(6)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(7)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(8)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits) };
}

pub fn retrace_glCompressedTextureSubImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(6)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits) };
}

pub fn retrace_glCompressedTextureSubImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(8)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits) };
}

pub fn retrace_glCompressedTextureSubImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(7)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(8)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(10)).to_i32().unwrap();

    let bits: &mut [GLvoid];
    let bits = (call.arg(11)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits) };
}

pub fn retrace_glCopyMultiTexImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(4)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(7)).to_i32().unwrap();

    unsafe { gl::CopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border) };
}

pub fn retrace_glCopyMultiTexImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(4)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(7)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(8)).to_i32().unwrap();

    unsafe { gl::CopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border) };
}

pub fn retrace_glCopyMultiTexSubImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(4)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::CopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width) };
}

pub fn retrace_glCopyMultiTexSubImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(5)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(6)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(7)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(8)).to_i32().unwrap();

    unsafe { gl::CopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height) };
}

pub fn retrace_glCopyMultiTexSubImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(5)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(6)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(7)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(8)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(9)).to_i32().unwrap();

    unsafe { gl::CopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height) };
}

pub fn retrace_glCopyTextureImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(4)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(7)).to_i32().unwrap();

    unsafe { gl::CopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border) };
}

pub fn retrace_glCopyTextureImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(4)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(7)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(8)).to_i32().unwrap();

    unsafe { gl::CopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border) };
}

pub fn retrace_glCopyTextureSubImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(4)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::CopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width) };
}

pub fn retrace_glCopyTextureSubImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(5)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(6)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(7)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(8)).to_i32().unwrap();

    unsafe { gl::CopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height) };
}

pub fn retrace_glCopyTextureSubImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(5)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(6)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(7)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(8)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(9)).to_i32().unwrap();

    unsafe { gl::CopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height) };
}

pub fn retrace_glDisableClientStateIndexedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut array: GLenum;
    array = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::DisableClientStateIndexedEXT(array, index) };
}

pub fn retrace_glDisableClientStateiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut array: GLenum;
    array = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::DisableClientStateiEXT(array, index) };
}

pub fn retrace_glDisableVertexArrayAttribEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::DisableVertexArrayAttribEXT(vaobj, index) };
}

pub fn retrace_glDisableVertexArrayEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut array: GLenum;
    array = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::DisableVertexArrayEXT(vaobj, array) };
}

pub fn retrace_glEnableClientStateIndexedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut array: GLenum;
    array = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::EnableClientStateIndexedEXT(array, index) };
}

pub fn retrace_glEnableClientStateiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut array: GLenum;
    array = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::EnableClientStateiEXT(array, index) };
}

pub fn retrace_glEnableVertexArrayAttribEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::EnableVertexArrayAttribEXT(vaobj, index) };
}

pub fn retrace_glEnableVertexArrayEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut array: GLenum;
    array = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::EnableVertexArrayEXT(vaobj, array) };
}

pub fn retrace_glFlushMappedNamedBufferRangeEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut length: GLsizeiptr;
    length = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::FlushMappedNamedBufferRangeEXT(buffer, offset, length) };
}

pub fn retrace_glFramebufferDrawBufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::FramebufferDrawBufferEXT(framebuffer, mode) };
}

pub fn retrace_glFramebufferDrawBuffersEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let bufs: &mut [GLenum];
    bufs = _allocator.alloc_array::<GLenum>(&call.arg(2));
    let _a_GLenum23_0 = (call.arg(2)).to_array();
    if let Some(_a_GLenum23_0) = _a_GLenum23_0 {
        for _jGLenum23 in 0.._a_GLenum23_0.values.len() {
    bufs[_jGLenum23] = (*_a_GLenum23_0.values[_jGLenum23]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::FramebufferDrawBuffersEXT(framebuffer, n, bufs) };
}

pub fn retrace_glFramebufferReadBufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::FramebufferReadBufferEXT(framebuffer, mode) };
}

pub fn retrace_glGenerateMultiTexMipmapEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::GenerateMultiTexMipmapEXT(texunit, target) };
}

pub fn retrace_glGenerateTextureMipmapEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::GenerateTextureMipmapEXT(texture, target) };
}

pub fn retrace_glGetCompressedMultiTexImageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut lod: GLint;
    lod = (call.arg(2)).to_i32().unwrap();

    let img: &mut [GLvoid];
    img = (call.arg(3)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetCompressedMultiTexImageEXT(texunit, target, lod, img) };
}

pub fn retrace_glGetCompressedTextureImageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut lod: GLint;
    lod = (call.arg(2)).to_i32().unwrap();

    let img: &mut [GLvoid];
    img = (call.arg(3)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetCompressedTextureImageEXT(texture, target, lod, img) };
}

pub fn retrace_glGetMultiTexImageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    pixels = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetMultiTexImageEXT(texunit, target, level, format, _type, pixels) };
}

pub fn retrace_glGetTextureImageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    pixels = (call.arg(5)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetTextureImageEXT(texture, target, level, format, _type, pixels) };
}

pub fn retrace_glMapNamedBufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut access: GLenum;
    access = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::MapNamedBufferEXT(buffer, access) };

    let length = 0;
    gl::GetNamedBufferParameterivEXT(buffer, gl::BUFFER_SIZE, &length);
    retrace::addRegion(call, (*call.ret).toUIntPtr(), _result, length);
}

pub fn retrace_glMapNamedBufferRangeEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut length: GLsizeiptr;
    length = (call.arg(2)).to_i32().unwrap();

    let mut access: GLbitfield;
    access = (call.arg(3)).to_u32().unwrap();

    let _result = unsafe { gl::MapNamedBufferRangeEXT(buffer, offset, length, access) };

    retrace::addRegion(call, (*call.ret).toUIntPtr(), _result, length);
}

pub fn retrace_glMatrixFrustumEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut left: GLdouble;
    left = (call.arg(1)).to_f64().unwrap();

    let mut right: GLdouble;
    right = (call.arg(2)).to_f64().unwrap();

    let mut bottom: GLdouble;
    bottom = (call.arg(3)).to_f64().unwrap();

    let mut top: GLdouble;
    top = (call.arg(4)).to_f64().unwrap();

    let mut zNear: GLdouble;
    zNear = (call.arg(5)).to_f64().unwrap();

    let mut zFar: GLdouble;
    zFar = (call.arg(6)).to_f64().unwrap();

    unsafe { gl::MatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar) };
}

pub fn retrace_glMatrixLoadIdentityEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::MatrixLoadIdentityEXT(mode) };
}

pub fn retrace_glMatrixLoadTransposedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLdouble];
    m = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble107_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble107_0) = _a_GLdouble107_0 {
        for _jGLdouble107 in 0.._a_GLdouble107_0.values.len() {
    m[_jGLdouble107] = (*_a_GLdouble107_0.values[_jGLdouble107]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixLoadTransposedEXT(mode, m) };
}

pub fn retrace_glMatrixLoadTransposefEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat201_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat201_0) = _a_GLfloat201_0 {
        for _jGLfloat201 in 0.._a_GLfloat201_0.values.len() {
    m[_jGLfloat201] = (*_a_GLfloat201_0.values[_jGLfloat201]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixLoadTransposefEXT(mode, m) };
}

pub fn retrace_glMatrixLoaddEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLdouble];
    m = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble108_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble108_0) = _a_GLdouble108_0 {
        for _jGLdouble108 in 0.._a_GLdouble108_0.values.len() {
    m[_jGLdouble108] = (*_a_GLdouble108_0.values[_jGLdouble108]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixLoaddEXT(mode, m) };
}

pub fn retrace_glMatrixLoadfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat202_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat202_0) = _a_GLfloat202_0 {
        for _jGLfloat202 in 0.._a_GLfloat202_0.values.len() {
    m[_jGLfloat202] = (*_a_GLfloat202_0.values[_jGLfloat202]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixLoadfEXT(mode, m) };
}

pub fn retrace_glMatrixMultTransposedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLdouble];
    m = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble109_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble109_0) = _a_GLdouble109_0 {
        for _jGLdouble109 in 0.._a_GLdouble109_0.values.len() {
    m[_jGLdouble109] = (*_a_GLdouble109_0.values[_jGLdouble109]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixMultTransposedEXT(mode, m) };
}

pub fn retrace_glMatrixMultTransposefEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat203_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat203_0) = _a_GLfloat203_0 {
        for _jGLfloat203 in 0.._a_GLfloat203_0.values.len() {
    m[_jGLfloat203] = (*_a_GLfloat203_0.values[_jGLfloat203]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixMultTransposefEXT(mode, m) };
}

pub fn retrace_glMatrixMultdEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLdouble];
    m = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble110_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble110_0) = _a_GLdouble110_0 {
        for _jGLdouble110 in 0.._a_GLdouble110_0.values.len() {
    m[_jGLdouble110] = (*_a_GLdouble110_0.values[_jGLdouble110]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixMultdEXT(mode, m) };
}

pub fn retrace_glMatrixMultfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat204_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat204_0) = _a_GLfloat204_0 {
        for _jGLfloat204 in 0.._a_GLfloat204_0.values.len() {
    m[_jGLfloat204] = (*_a_GLfloat204_0.values[_jGLfloat204]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixMultfEXT(mode, m) };
}

pub fn retrace_glMatrixOrthoEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut left: GLdouble;
    left = (call.arg(1)).to_f64().unwrap();

    let mut right: GLdouble;
    right = (call.arg(2)).to_f64().unwrap();

    let mut bottom: GLdouble;
    bottom = (call.arg(3)).to_f64().unwrap();

    let mut top: GLdouble;
    top = (call.arg(4)).to_f64().unwrap();

    let mut zNear: GLdouble;
    zNear = (call.arg(5)).to_f64().unwrap();

    let mut zFar: GLdouble;
    zFar = (call.arg(6)).to_f64().unwrap();

    unsafe { gl::MatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar) };
}

pub fn retrace_glMatrixPopEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::MatrixPopEXT(mode) };
}

pub fn retrace_glMatrixPushEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::MatrixPushEXT(mode) };
}

pub fn retrace_glMatrixRotatedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut angle: GLdouble;
    angle = (call.arg(1)).to_f64().unwrap();

    let mut x: GLdouble;
    x = (call.arg(2)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(3)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::MatrixRotatedEXT(mode, angle, x, y, z) };
}

pub fn retrace_glMatrixRotatefEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut angle: GLfloat;
    angle = (call.arg(1)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(2)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(3)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::MatrixRotatefEXT(mode, angle, x, y, z) };
}

pub fn retrace_glMatrixScaledEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::MatrixScaledEXT(mode, x, y, z) };
}

pub fn retrace_glMatrixScalefEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::MatrixScalefEXT(mode, x, y, z) };
}

pub fn retrace_glMatrixTranslatedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::MatrixTranslatedEXT(mode, x, y, z) };
}

pub fn retrace_glMatrixTranslatefEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::MatrixTranslatefEXT(mode, x, y, z) };
}

pub fn retrace_glMultiTexBufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(3)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::MultiTexBufferEXT(texunit, target, internalformat, buffer) };
}

pub fn retrace_glMultiTexCoordPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(4), true));

    unsafe { gl::MultiTexCoordPointerEXT(texunit, size, _type, stride, pointer) };
}

pub fn retrace_glMultiTexEnvfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::MultiTexEnvfEXT(texunit, target, pname, param) };
}

pub fn retrace_glMultiTexEnvfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat205_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat205_0) = _a_GLfloat205_0 {
        for _jGLfloat205 in 0.._a_GLfloat205_0.values.len() {
    params[_jGLfloat205] = (*_a_GLfloat205_0.values[_jGLfloat205]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexEnvfvEXT(texunit, target, pname, params) };
}

pub fn retrace_glMultiTexEnviEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiTexEnviEXT(texunit, target, pname, param) };
}

pub fn retrace_glMultiTexEnvivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint222_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint222_0) = _a_GLint222_0 {
        for _jGLint222 in 0.._a_GLint222_0.values.len() {
    params[_jGLint222] = (*_a_GLint222_0.values[_jGLint222]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexEnvivEXT(texunit, target, pname, params) };
}

pub fn retrace_glMultiTexGendEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coord: GLenum;
    coord = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLdouble;
    param = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::MultiTexGendEXT(texunit, coord, pname, param) };
}

pub fn retrace_glMultiTexGendvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coord: GLenum;
    coord = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLdouble];
    params = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble111_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble111_0) = _a_GLdouble111_0 {
        for _jGLdouble111 in 0.._a_GLdouble111_0.values.len() {
    params[_jGLdouble111] = (*_a_GLdouble111_0.values[_jGLdouble111]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexGendvEXT(texunit, coord, pname, params) };
}

pub fn retrace_glMultiTexGenfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coord: GLenum;
    coord = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::MultiTexGenfEXT(texunit, coord, pname, param) };
}

pub fn retrace_glMultiTexGenfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coord: GLenum;
    coord = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat206_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat206_0) = _a_GLfloat206_0 {
        for _jGLfloat206 in 0.._a_GLfloat206_0.values.len() {
    params[_jGLfloat206] = (*_a_GLfloat206_0.values[_jGLfloat206]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexGenfvEXT(texunit, coord, pname, params) };
}

pub fn retrace_glMultiTexGeniEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coord: GLenum;
    coord = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiTexGeniEXT(texunit, coord, pname, param) };
}

pub fn retrace_glMultiTexGenivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coord: GLenum;
    coord = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint223_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint223_0) = _a_GLint223_0 {
        for _jGLint223 in 0.._a_GLint223_0.values.len() {
    params[_jGLint223] = (*_a_GLint223_0.values[_jGLint223]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexGenivEXT(texunit, coord, pname, params) };
}

pub fn retrace_glMultiTexImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLint;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(5)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::MultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, _type, pixels) };
}

pub fn retrace_glMultiTexImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLint;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::MultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, _type, pixels) };
}

pub fn retrace_glMultiTexImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLint;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(6)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::MultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, _type, pixels) };
}

pub fn retrace_glMultiTexParameterIivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint224_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint224_0) = _a_GLint224_0 {
        for _jGLint224 in 0.._a_GLint224_0.values.len() {
    params[_jGLint224] = (*_a_GLint224_0.values[_jGLint224]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexParameterIivEXT(texunit, target, pname, params) };
}

pub fn retrace_glMultiTexParameterIuivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint203_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint203_0) = _a_GLuint203_0 {
        for _jGLuint203 in 0.._a_GLuint203_0.values.len() {
    params[_jGLuint203] = (*_a_GLuint203_0.values[_jGLuint203]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexParameterIuivEXT(texunit, target, pname, params) };
}

pub fn retrace_glMultiTexParameterfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::MultiTexParameterfEXT(texunit, target, pname, param) };
}

pub fn retrace_glMultiTexParameterfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat207_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat207_0) = _a_GLfloat207_0 {
        for _jGLfloat207 in 0.._a_GLfloat207_0.values.len() {
    params[_jGLfloat207] = (*_a_GLfloat207_0.values[_jGLfloat207]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexParameterfvEXT(texunit, target, pname, params) };
}

pub fn retrace_glMultiTexParameteriEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiTexParameteriEXT(texunit, target, pname, param) };
}

pub fn retrace_glMultiTexParameterivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint225_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint225_0) = _a_GLint225_0 {
        for _jGLint225 in 0.._a_GLint225_0.values.len() {
    params[_jGLint225] = (*_a_GLint225_0.values[_jGLint225]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexParameterivEXT(texunit, target, pname, params) };
}

pub fn retrace_glMultiTexRenderbufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(2)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    unsafe { gl::MultiTexRenderbufferEXT(texunit, target, renderbuffer) };
}

pub fn retrace_glMultiTexSubImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::MultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, _type, pixels) };
}

pub fn retrace_glMultiTexSubImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::MultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, _type, pixels) };
}

pub fn retrace_glMultiTexSubImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texunit: GLenum;
    texunit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(7)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(8)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(10)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(11)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::MultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, _type, pixels) };
}

pub fn retrace_glNamedBufferDataEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut size: GLsizeiptr;
    size = (call.arg(1)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut usage: GLenum;
    usage = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::NamedBufferDataEXT(buffer, size, data, usage) };
}

pub fn retrace_glNamedBufferStorageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut size: GLsizeiptr;
    size = (call.arg(1)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut flags: GLbitfield;
    flags = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::NamedBufferStorageEXT(buffer, size, data, flags) };
}

pub fn retrace_glNamedBufferSubDataEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(2)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::NamedBufferSubDataEXT(buffer, offset, size, data) };
}

pub fn retrace_glNamedCopyBufferSubDataEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut readBuffer: GLuint;
    readBuffer = (call.arg(0)).to_u32().unwrap();
    readBuffer = _buffer_map[readBuffer];

    let mut writeBuffer: GLuint;
    writeBuffer = (call.arg(1)).to_u32().unwrap();
    writeBuffer = _buffer_map[writeBuffer];

    let mut readOffset: GLintptr;
    readOffset = (call.arg(2)).to_i32().unwrap();

    let mut writeOffset: GLintptr;
    writeOffset = (call.arg(3)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::NamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size) };
}

pub fn retrace_glNamedFramebufferParameteriEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::NamedFramebufferParameteriEXT(framebuffer, pname, param) };
}

pub fn retrace_glNamedFramebufferRenderbufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffertarget: GLenum;
    renderbuffertarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(3)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    unsafe { gl::NamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer) };
}

pub fn retrace_glNamedFramebufferTexture1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::NamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level) };
}

pub fn retrace_glNamedFramebufferTexture2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::NamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level) };
}

pub fn retrace_glNamedFramebufferTexture3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::NamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset) };
}

pub fn retrace_glNamedFramebufferTextureEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::NamedFramebufferTextureEXT(framebuffer, attachment, texture, level) };
}

pub fn retrace_glNamedFramebufferTextureFaceEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    let mut face: GLenum;
    face = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::NamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face) };
}

pub fn retrace_glNamedFramebufferTextureLayerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    let mut layer: GLint;
    layer = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::NamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer) };
}

pub fn retrace_glNamedProgramLocalParameter4dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(3)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(4)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(5)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(6)).to_f64().unwrap();

    unsafe { gl::NamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w) };
}

pub fn retrace_glNamedProgramLocalParameter4dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let params: &mut [GLdouble];
    params = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble112_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble112_0) = _a_GLdouble112_0 {
        for _jGLdouble112 in 0.._a_GLdouble112_0.values.len() {
    params[_jGLdouble112] = (*_a_GLdouble112_0.values[_jGLdouble112]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NamedProgramLocalParameter4dvEXT(program, target, index, params) };
}

pub fn retrace_glNamedProgramLocalParameter4fEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(3)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(4)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(5)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(6)).to_f32().unwrap();

    unsafe { gl::NamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w) };
}

pub fn retrace_glNamedProgramLocalParameter4fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat208_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat208_0) = _a_GLfloat208_0 {
        for _jGLfloat208 in 0.._a_GLfloat208_0.values.len() {
    params[_jGLfloat208] = (*_a_GLfloat208_0.values[_jGLfloat208]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NamedProgramLocalParameter4fvEXT(program, target, index, params) };
}

pub fn retrace_glNamedProgramLocalParameterI4iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(3)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(4)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(5)).to_i32().unwrap();

    let mut w: GLint;
    w = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::NamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w) };
}

pub fn retrace_glNamedProgramLocalParameterI4ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint226_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint226_0) = _a_GLint226_0 {
        for _jGLint226 in 0.._a_GLint226_0.values.len() {
    params[_jGLint226] = (*_a_GLint226_0.values[_jGLint226]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NamedProgramLocalParameterI4ivEXT(program, target, index, params) };
}

pub fn retrace_glNamedProgramLocalParameterI4uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(3)).to_u32().unwrap();

    let mut y: GLuint;
    y = (call.arg(4)).to_u32().unwrap();

    let mut z: GLuint;
    z = (call.arg(5)).to_u32().unwrap();

    let mut w: GLuint;
    w = (call.arg(6)).to_u32().unwrap();

    unsafe { gl::NamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w) };
}

pub fn retrace_glNamedProgramLocalParameterI4uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint204_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint204_0) = _a_GLuint204_0 {
        for _jGLuint204 in 0.._a_GLuint204_0.values.len() {
    params[_jGLuint204] = (*_a_GLuint204_0.values[_jGLuint204]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NamedProgramLocalParameterI4uivEXT(program, target, index, params) };
}

pub fn retrace_glNamedProgramLocalParameters4fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat209_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat209_0) = _a_GLfloat209_0 {
        for _jGLfloat209 in 0.._a_GLfloat209_0.values.len() {
    params[_jGLfloat209] = (*_a_GLfloat209_0.values[_jGLfloat209]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NamedProgramLocalParameters4fvEXT(program, target, index, count, params) };
}

pub fn retrace_glNamedProgramLocalParametersI4ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(4));
    let _a_GLint227_0 = (call.arg(4)).to_array();
    if let Some(_a_GLint227_0) = _a_GLint227_0 {
        for _jGLint227 in 0.._a_GLint227_0.values.len() {
    params[_jGLint227] = (*_a_GLint227_0.values[_jGLint227]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NamedProgramLocalParametersI4ivEXT(program, target, index, count, params) };
}

pub fn retrace_glNamedProgramLocalParametersI4uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(4));
    let _a_GLuint205_0 = (call.arg(4)).to_array();
    if let Some(_a_GLuint205_0) = _a_GLuint205_0 {
        for _jGLuint205 in 0.._a_GLuint205_0.values.len() {
    params[_jGLuint205] = (*_a_GLuint205_0.values[_jGLuint205]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::NamedProgramLocalParametersI4uivEXT(program, target, index, count, params) };
}

pub fn retrace_glNamedProgramStringEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut len: GLsizei;
    len = (call.arg(3)).to_i32().unwrap();

    let string: &mut [GLvoid];
    string = (GLvoid *)((call.arg(4)).to_string().unwrap());

    unsafe { gl::NamedProgramStringEXT(program, target, format, len, string) };
}

pub fn retrace_glNamedRenderbufferStorageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(0)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::NamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height) };
}

pub fn retrace_glNamedRenderbufferStorageMultisampleCoverageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(0)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    let mut coverageSamples: GLsizei;
    coverageSamples = (call.arg(1)).to_i32().unwrap();

    let mut colorSamples: GLsizei;
    colorSamples = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::NamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height) };
}

pub fn retrace_glNamedRenderbufferStorageMultisampleEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(0)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::NamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height) };
}

pub fn retrace_glProgramUniform1dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLdouble;
    x = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::ProgramUniform1dEXT(program, location, x) };
}

pub fn retrace_glProgramUniform1dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble113_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble113_0) = _a_GLdouble113_0 {
        for _jGLdouble113 in 0.._a_GLdouble113_0.values.len() {
    value[_jGLdouble113] = (*_a_GLdouble113_0.values[_jGLdouble113]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1dvEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform1fEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::ProgramUniform1fEXT(program, location, v0) };
}

pub fn retrace_glProgramUniform1fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat210_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat210_0) = _a_GLfloat210_0 {
        for _jGLfloat210 in 0.._a_GLfloat210_0.values.len() {
    value[_jGLfloat210] = (*_a_GLfloat210_0.values[_jGLfloat210]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1fvEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform1iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ProgramUniform1iEXT(program, location, v0) };
}

pub fn retrace_glProgramUniform1ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint228_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint228_0) = _a_GLint228_0 {
        for _jGLint228 in 0.._a_GLint228_0.values.len() {
    value[_jGLint228] = (*_a_GLint228_0.values[_jGLint228]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1ivEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform1uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::ProgramUniform1uiEXT(program, location, v0) };
}

pub fn retrace_glProgramUniform1uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint206_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint206_0) = _a_GLuint206_0 {
        for _jGLuint206 in 0.._a_GLuint206_0.values.len() {
    value[_jGLuint206] = (*_a_GLuint206_0.values[_jGLuint206]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1uivEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform2dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLdouble;
    x = (call.arg(2)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::ProgramUniform2dEXT(program, location, x, y) };
}

pub fn retrace_glProgramUniform2dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble114_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble114_0) = _a_GLdouble114_0 {
        for _jGLdouble114 in 0.._a_GLdouble114_0.values.len() {
    value[_jGLdouble114] = (*_a_GLdouble114_0.values[_jGLdouble114]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2dvEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform2fEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(2)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::ProgramUniform2fEXT(program, location, v0, v1) };
}

pub fn retrace_glProgramUniform2fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat211_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat211_0) = _a_GLfloat211_0 {
        for _jGLfloat211 in 0.._a_GLfloat211_0.values.len() {
    value[_jGLfloat211] = (*_a_GLfloat211_0.values[_jGLfloat211]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2fvEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform2iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(2)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::ProgramUniform2iEXT(program, location, v0, v1) };
}

pub fn retrace_glProgramUniform2ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint229_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint229_0) = _a_GLint229_0 {
        for _jGLint229 in 0.._a_GLint229_0.values.len() {
    value[_jGLint229] = (*_a_GLint229_0.values[_jGLint229]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2ivEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform2uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(2)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::ProgramUniform2uiEXT(program, location, v0, v1) };
}

pub fn retrace_glProgramUniform2uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint207_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint207_0) = _a_GLuint207_0 {
        for _jGLuint207 in 0.._a_GLuint207_0.values.len() {
    value[_jGLuint207] = (*_a_GLuint207_0.values[_jGLuint207]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2uivEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform3dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLdouble;
    x = (call.arg(2)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(3)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::ProgramUniform3dEXT(program, location, x, y, z) };
}

pub fn retrace_glProgramUniform3dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble115_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble115_0) = _a_GLdouble115_0 {
        for _jGLdouble115 in 0.._a_GLdouble115_0.values.len() {
    value[_jGLdouble115] = (*_a_GLdouble115_0.values[_jGLdouble115]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3dvEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform3fEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(2)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(3)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::ProgramUniform3fEXT(program, location, v0, v1, v2) };
}

pub fn retrace_glProgramUniform3fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat212_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat212_0) = _a_GLfloat212_0 {
        for _jGLfloat212 in 0.._a_GLfloat212_0.values.len() {
    value[_jGLfloat212] = (*_a_GLfloat212_0.values[_jGLfloat212]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3fvEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform3iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(2)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(3)).to_i32().unwrap();

    let mut v2: GLint;
    v2 = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::ProgramUniform3iEXT(program, location, v0, v1, v2) };
}

pub fn retrace_glProgramUniform3ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint230_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint230_0) = _a_GLint230_0 {
        for _jGLint230 in 0.._a_GLint230_0.values.len() {
    value[_jGLint230] = (*_a_GLint230_0.values[_jGLint230]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3ivEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform3uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(2)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(3)).to_u32().unwrap();

    let mut v2: GLuint;
    v2 = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::ProgramUniform3uiEXT(program, location, v0, v1, v2) };
}

pub fn retrace_glProgramUniform3uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint208_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint208_0) = _a_GLuint208_0 {
        for _jGLuint208 in 0.._a_GLuint208_0.values.len() {
    value[_jGLuint208] = (*_a_GLuint208_0.values[_jGLuint208]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3uivEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform4dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLdouble;
    x = (call.arg(2)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(3)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(4)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(5)).to_f64().unwrap();

    unsafe { gl::ProgramUniform4dEXT(program, location, x, y, z, w) };
}

pub fn retrace_glProgramUniform4dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble116_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble116_0) = _a_GLdouble116_0 {
        for _jGLdouble116 in 0.._a_GLdouble116_0.values.len() {
    value[_jGLdouble116] = (*_a_GLdouble116_0.values[_jGLdouble116]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4dvEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform4fEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLfloat;
    v0 = (call.arg(2)).to_f32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(3)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(4)).to_f32().unwrap();

    let mut v3: GLfloat;
    v3 = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::ProgramUniform4fEXT(program, location, v0, v1, v2, v3) };
}

pub fn retrace_glProgramUniform4fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat213_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat213_0) = _a_GLfloat213_0 {
        for _jGLfloat213 in 0.._a_GLfloat213_0.values.len() {
    value[_jGLfloat213] = (*_a_GLfloat213_0.values[_jGLfloat213]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4fvEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform4iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLint;
    v0 = (call.arg(2)).to_i32().unwrap();

    let mut v1: GLint;
    v1 = (call.arg(3)).to_i32().unwrap();

    let mut v2: GLint;
    v2 = (call.arg(4)).to_i32().unwrap();

    let mut v3: GLint;
    v3 = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::ProgramUniform4iEXT(program, location, v0, v1, v2, v3) };
}

pub fn retrace_glProgramUniform4ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint231_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint231_0) = _a_GLint231_0 {
        for _jGLint231 in 0.._a_GLint231_0.values.len() {
    value[_jGLint231] = (*_a_GLint231_0.values[_jGLint231]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4ivEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniform4uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(2)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(3)).to_u32().unwrap();

    let mut v2: GLuint;
    v2 = (call.arg(4)).to_u32().unwrap();

    let mut v3: GLuint;
    v3 = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::ProgramUniform4uiEXT(program, location, v0, v1, v2, v3) };
}

pub fn retrace_glProgramUniform4uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint209_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint209_0) = _a_GLuint209_0 {
        for _jGLuint209 in 0.._a_GLuint209_0.values.len() {
    value[_jGLuint209] = (*_a_GLuint209_0.values[_jGLuint209]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4uivEXT(program, location, count, value) };
}

pub fn retrace_glProgramUniformMatrix2dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble117_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble117_0) = _a_GLdouble117_0 {
        for _jGLdouble117 in 0.._a_GLdouble117_0.values.len() {
    value[_jGLdouble117] = (*_a_GLdouble117_0.values[_jGLdouble117]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2dvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix2fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat214_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat214_0) = _a_GLfloat214_0 {
        for _jGLfloat214 in 0.._a_GLfloat214_0.values.len() {
    value[_jGLfloat214] = (*_a_GLfloat214_0.values[_jGLfloat214]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2fvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix2x3dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble118_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble118_0) = _a_GLdouble118_0 {
        for _jGLdouble118 in 0.._a_GLdouble118_0.values.len() {
    value[_jGLdouble118] = (*_a_GLdouble118_0.values[_jGLdouble118]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix2x3fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat215_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat215_0) = _a_GLfloat215_0 {
        for _jGLfloat215 in 0.._a_GLfloat215_0.values.len() {
    value[_jGLfloat215] = (*_a_GLfloat215_0.values[_jGLfloat215]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix2x4dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble119_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble119_0) = _a_GLdouble119_0 {
        for _jGLdouble119 in 0.._a_GLdouble119_0.values.len() {
    value[_jGLdouble119] = (*_a_GLdouble119_0.values[_jGLdouble119]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix2x4fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat216_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat216_0) = _a_GLfloat216_0 {
        for _jGLfloat216 in 0.._a_GLfloat216_0.values.len() {
    value[_jGLfloat216] = (*_a_GLfloat216_0.values[_jGLfloat216]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble120_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble120_0) = _a_GLdouble120_0 {
        for _jGLdouble120 in 0.._a_GLdouble120_0.values.len() {
    value[_jGLdouble120] = (*_a_GLdouble120_0.values[_jGLdouble120]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3dvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat217_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat217_0) = _a_GLfloat217_0 {
        for _jGLfloat217 in 0.._a_GLfloat217_0.values.len() {
    value[_jGLfloat217] = (*_a_GLfloat217_0.values[_jGLfloat217]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3fvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3x2dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble121_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble121_0) = _a_GLdouble121_0 {
        for _jGLdouble121 in 0.._a_GLdouble121_0.values.len() {
    value[_jGLdouble121] = (*_a_GLdouble121_0.values[_jGLdouble121]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3x2fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat218_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat218_0) = _a_GLfloat218_0 {
        for _jGLfloat218 in 0.._a_GLfloat218_0.values.len() {
    value[_jGLfloat218] = (*_a_GLfloat218_0.values[_jGLfloat218]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3x4dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble122_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble122_0) = _a_GLdouble122_0 {
        for _jGLdouble122 in 0.._a_GLdouble122_0.values.len() {
    value[_jGLdouble122] = (*_a_GLdouble122_0.values[_jGLdouble122]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix3x4fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat219_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat219_0) = _a_GLfloat219_0 {
        for _jGLfloat219 in 0.._a_GLfloat219_0.values.len() {
    value[_jGLfloat219] = (*_a_GLfloat219_0.values[_jGLfloat219]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble123_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble123_0) = _a_GLdouble123_0 {
        for _jGLdouble123 in 0.._a_GLdouble123_0.values.len() {
    value[_jGLdouble123] = (*_a_GLdouble123_0.values[_jGLdouble123]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4dvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat220_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat220_0) = _a_GLfloat220_0 {
        for _jGLfloat220 in 0.._a_GLfloat220_0.values.len() {
    value[_jGLfloat220] = (*_a_GLfloat220_0.values[_jGLfloat220]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4fvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4x2dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble124_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble124_0) = _a_GLdouble124_0 {
        for _jGLdouble124 in 0.._a_GLdouble124_0.values.len() {
    value[_jGLdouble124] = (*_a_GLdouble124_0.values[_jGLdouble124]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4x2fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat221_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat221_0) = _a_GLfloat221_0 {
        for _jGLfloat221 in 0.._a_GLfloat221_0.values.len() {
    value[_jGLfloat221] = (*_a_GLfloat221_0.values[_jGLfloat221]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4x3dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLdouble];
    value = _allocator.alloc_array::<GLdouble>(&call.arg(4));
    let _a_GLdouble125_0 = (call.arg(4)).to_array();
    if let Some(_a_GLdouble125_0) = _a_GLdouble125_0 {
        for _jGLdouble125 in 0.._a_GLdouble125_0.values.len() {
    value[_jGLdouble125] = (*_a_GLdouble125_0.values[_jGLdouble125]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glProgramUniformMatrix4x3fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut transpose: GLboolean;
    transpose = (call.arg(3)).to_u32().unwrap() as u8;

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat222_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat222_0) = _a_GLfloat222_0 {
        for _jGLfloat222 in 0.._a_GLfloat222_0.values.len() {
    value[_jGLfloat222] = (*_a_GLfloat222_0.values[_jGLfloat222]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value) };
}

pub fn retrace_glPushClientAttribDefaultEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLbitfield;
    mask = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::PushClientAttribDefaultEXT(mask) };
}

pub fn retrace_glTextureBufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(3)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::TextureBufferEXT(texture, target, internalformat, buffer) };
}

pub fn retrace_glTextureBufferRangeEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(3)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(4)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::TextureBufferRangeEXT(texture, target, internalformat, buffer, offset, size) };
}

pub fn retrace_glTextureImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLint;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(5)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TextureImage1DEXT(texture, target, level, internalformat, width, border, format, _type, pixels) };
}

pub fn retrace_glTextureImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLint;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, _type, pixels) };
}

pub fn retrace_glTextureImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLint;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(6)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, _type, pixels) };
}

pub fn retrace_glTexturePageCommitmentEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut commit: GLboolean;
    commit = (call.arg(8)).to_u32().unwrap() as u8;

    unsafe { gl::TexturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit) };
}

pub fn retrace_glTextureParameterIivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint232_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint232_0) = _a_GLint232_0 {
        for _jGLint232 in 0.._a_GLint232_0.values.len() {
    params[_jGLint232] = (*_a_GLint232_0.values[_jGLint232]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TextureParameterIivEXT(texture, target, pname, params) };
}

pub fn retrace_glTextureParameterIuivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint210_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint210_0) = _a_GLuint210_0 {
        for _jGLuint210 in 0.._a_GLuint210_0.values.len() {
    params[_jGLuint210] = (*_a_GLuint210_0.values[_jGLuint210]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TextureParameterIuivEXT(texture, target, pname, params) };
}

pub fn retrace_glTextureParameterfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::TextureParameterfEXT(texture, target, pname, param) };
}

pub fn retrace_glTextureParameterfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat223_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat223_0) = _a_GLfloat223_0 {
        for _jGLfloat223 in 0.._a_GLfloat223_0.values.len() {
    params[_jGLfloat223] = (*_a_GLfloat223_0.values[_jGLfloat223]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TextureParameterfvEXT(texture, target, pname, params) };
}

pub fn retrace_glTextureParameteriEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::TextureParameteriEXT(texture, target, pname, param) };
}

pub fn retrace_glTextureParameterivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint233_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint233_0) = _a_GLint233_0 {
        for _jGLint233 in 0.._a_GLint233_0.values.len() {
    params[_jGLint233] = (*_a_GLint233_0.values[_jGLint233]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TextureParameterivEXT(texture, target, pname, params) };
}

pub fn retrace_glTextureRenderbufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(2)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    unsafe { gl::TextureRenderbufferEXT(texture, target, renderbuffer) };
}

pub fn retrace_glTextureStorage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::TextureStorage1DEXT(texture, target, levels, internalformat, width) };
}

pub fn retrace_glTextureStorage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::TextureStorage2DEXT(texture, target, levels, internalformat, width, height) };
}

pub fn retrace_glTextureStorage2DMultisampleEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(2)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut fixedsamplelocations: GLboolean;
    fixedsamplelocations = (call.arg(6)).to_u32().unwrap() as u8;

    unsafe { gl::TextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations) };
}

pub fn retrace_glTextureStorage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::TextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth) };
}

pub fn retrace_glTextureStorage3DMultisampleEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(2)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(6)).to_i32().unwrap();

    let mut fixedsamplelocations: GLboolean;
    fixedsamplelocations = (call.arg(7)).to_u32().unwrap() as u8;

    unsafe { gl::TextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations) };
}

pub fn retrace_glTextureSubImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TextureSubImage1DEXT(texture, target, level, xoffset, width, format, _type, pixels) };
}

pub fn retrace_glTextureSubImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, _type, pixels) };
}

pub fn retrace_glTextureSubImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(3)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(4)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(7)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(8)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(10)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(11)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, _type, pixels) };
}

pub fn retrace_glUnmapNamedBufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

        GLvoid *ptr = NULL;
            glGetNamedBufferPointervEXT(buffer, GL_BUFFER_MAP_POINTER, &ptr);
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "failed to get mapped pointer\n";
        }
    let _result = unsafe { gl::UnmapNamedBufferEXT(buffer) };

}

pub fn retrace_glVertexArrayBindVertexBufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut bindingindex: GLuint;
    bindingindex = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexArrayBindVertexBufferEXT(vaobj, bindingindex, buffer, offset, stride) };
}

pub fn retrace_glVertexArrayColorOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut size: GLint;
    size = (call.arg(2)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::VertexArrayColorOffsetEXT(vaobj, buffer, size, _type, stride, offset) };
}

pub fn retrace_glVertexArrayEdgeFlagOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset) };
}

pub fn retrace_glVertexArrayFogCoordOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexArrayFogCoordOffsetEXT(vaobj, buffer, _type, stride, offset) };
}

pub fn retrace_glVertexArrayIndexOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexArrayIndexOffsetEXT(vaobj, buffer, _type, stride, offset) };
}

pub fn retrace_glVertexArrayMultiTexCoordOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut texunit: GLenum;
    texunit = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut size: GLint;
    size = (call.arg(3)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(5)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::VertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, _type, stride, offset) };
}

pub fn retrace_glVertexArrayNormalOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexArrayNormalOffsetEXT(vaobj, buffer, _type, stride, offset) };
}

pub fn retrace_glVertexArraySecondaryColorOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut size: GLint;
    size = (call.arg(2)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::VertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, _type, stride, offset) };
}

pub fn retrace_glVertexArrayTexCoordOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut size: GLint;
    size = (call.arg(2)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::VertexArrayTexCoordOffsetEXT(vaobj, buffer, size, _type, stride, offset) };
}

pub fn retrace_glVertexArrayVertexAttribBindingEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut attribindex: GLuint;
    attribindex = (call.arg(1)).to_u32().unwrap();

    let mut bindingindex: GLuint;
    bindingindex = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::VertexArrayVertexAttribBindingEXT(vaobj, attribindex, bindingindex) };
}

pub fn retrace_glVertexArrayVertexAttribDivisorEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut divisor: GLuint;
    divisor = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::VertexArrayVertexAttribDivisorEXT(vaobj, index, divisor) };
}

pub fn retrace_glVertexArrayVertexAttribFormatEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut attribindex: GLuint;
    attribindex = (call.arg(1)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(2)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(4)).to_u32().unwrap() as u8;

    let mut relativeoffset: GLuint;
    relativeoffset = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::VertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, _type, normalized, relativeoffset) };
}

pub fn retrace_glVertexArrayVertexAttribIFormatEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut attribindex: GLuint;
    attribindex = (call.arg(1)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(2)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut relativeoffset: GLuint;
    relativeoffset = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexArrayVertexAttribIFormatEXT(vaobj, attribindex, size, _type, relativeoffset) };
}

pub fn retrace_glVertexArrayVertexAttribIOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(3)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(5)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::VertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, _type, stride, offset) };
}

pub fn retrace_glVertexArrayVertexAttribLFormatEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut attribindex: GLuint;
    attribindex = (call.arg(1)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(2)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut relativeoffset: GLuint;
    relativeoffset = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexArrayVertexAttribLFormatEXT(vaobj, attribindex, size, _type, relativeoffset) };
}

pub fn retrace_glVertexArrayVertexAttribLOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(3)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(5)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::VertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, _type, stride, offset) };
}

pub fn retrace_glVertexArrayVertexAttribOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(3)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(5)).to_u32().unwrap() as u8;

    let mut stride: GLsizei;
    stride = (call.arg(6)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(7)).to_i32().unwrap();

    unsafe { gl::VertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, _type, normalized, stride, offset) };
}

pub fn retrace_glVertexArrayVertexBindingDivisorEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut bindingindex: GLuint;
    bindingindex = (call.arg(1)).to_u32().unwrap();

    let mut divisor: GLuint;
    divisor = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::VertexArrayVertexBindingDivisorEXT(vaobj, bindingindex, divisor) };
}

pub fn retrace_glVertexArrayVertexOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut vaobj: GLuint;
    vaobj = (call.arg(0)).to_u32().unwrap();
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut size: GLint;
    size = (call.arg(2)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::VertexArrayVertexOffsetEXT(vaobj, buffer, size, _type, stride, offset) };
}

pub fn retrace_glDiscardFramebufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut numAttachments: GLsizei;
    numAttachments = (call.arg(1)).to_i32().unwrap();

    let attachments: &mut [GLenum];
    attachments = _allocator.alloc_array::<GLenum>(&call.arg(2));
    let _a_GLenum24_0 = (call.arg(2)).to_array();
    if let Some(_a_GLenum24_0) = _a_GLenum24_0 {
        for _jGLenum24 in 0.._a_GLenum24_0.values.len() {
    attachments[_jGLenum24] = (*_a_GLenum24_0.values[_jGLenum24]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DiscardFramebufferEXT(target, numAttachments, attachments) };
}

pub fn retrace_glGenQueriesEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenQueriesEXT(n, ids) };
    let _aGLuint212 = (call.arg(1)).to_array();
    if (_aGLuint212) {
        for _jGLuint212 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint212.values[_jGLuint212]).to_u32().unwrap();
    _query_map[_origResult] = ids[_jGLuint212];
        }
    }
}

pub fn retrace_glDeleteQueriesEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint213_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint213_0) = _a_GLuint213_0 {
        for _jGLuint213 in 0.._a_GLuint213_0.values.len() {
    ids[_jGLuint213] = (*_a_GLuint213_0.values[_jGLuint213]).to_u32().unwrap();
    ids[_jGLuint213] = _query_map[ids[_jGLuint213]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteQueriesEXT(n, ids) };
}

pub fn retrace_glBeginQueryEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _query_map[id];

    unsafe { gl::BeginQueryEXT(target, id) };
}

pub fn retrace_glEndQueryEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::EndQueryEXT(target) };
}

pub fn retrace_glQueryCounterEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::QueryCounterEXT(id, target) };
}

pub fn retrace_glGetQueryObjectivEXT(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    GLint retval;
    if (_query_buffer)
        params = static_cast<GLint *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectivEXT(id, pname, params) };
    let _aGLint235 = (call.arg(2)).to_array();
    if (_aGLint235) {
        for _jGLint235 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glGetQueryObjectuivEXT(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint];
    GLuint retval;
    if (_query_buffer)
        params = static_cast<GLuint *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectuivEXT(id, pname, params) };
    let _aGLuint215 = (call.arg(2)).to_array();
    if (_aGLuint215) {
        for _jGLuint215 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glGetQueryObjecti64vEXT(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint64];
    GLint64 retval;
    if (_query_buffer)
        params = static_cast<GLint64 *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjecti64vEXT(id, pname, params) };
    let _aGLint6425 = (call.arg(2)).to_array();
    if (_aGLint6425) {
        for _jGLint6425 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glGetQueryObjectui64vEXT(&mut self, call: &mut Call) {
    let _query_buffer = 0;
    if currentContext.features("query_buffer_object") {
        gl::GetIntegerv(gl::QUERY_BUFFER_BINDING, &_query_buffer);
    }
    if (_query_buffer == 0 && retrace::queryHandling == retrace::QUERY_SKIP) {
        return;
    }
wait_for_query_result:
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint64];
    GLuint64 retval;
    if (_query_buffer)
        params = static_cast<GLuint64 *>((call.arg(2)).toPointer());
    else
        params = &retval;

    unsafe { gl::GetQueryObjectui64vEXT(id, pname, params) };
    let _aGLuint6422 = (call.arg(2)).to_array();
    if (_aGLuint6422) {
        for _jGLuint6422 in 0..length {
        }
    }
    if (!_query_buffer && retrace::queryHandling != retrace::QUERY_SKIP) {
        auto query_result = call.arg(2).toArray();
        auto expect = static_cast<decltype(retval)>(query_result->values[0]->toUInt());
        if (call.arg(1).toUInt() == GL_QUERY_RESULT_AVAILABLE) {
            if (expect == 1 && retval == 0)
                goto wait_for_query_result;
        } else if (retrace::queryHandling == retrace::QUERY_RUN_AND_CHECK_RESULT &&
                   abs(static_cast<int64_t>(expect) - static_cast<int64_t>(retval)) > retrace::queryTolerance) {
           retrace::warning(call) << "Warning: query returned " << retval << " but trace contained " << expect
                                  << " (tol = " << retrace::queryTolerance << ")\n";
        }
    }
}

pub fn retrace_glDrawBuffersEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let bufs: &mut [GLenum];
    bufs = _allocator.alloc_array::<GLenum>(&call.arg(1));
    let _a_GLenum25_0 = (call.arg(1)).to_array();
    if let Some(_a_GLenum25_0) = _a_GLenum25_0 {
        for _jGLenum25 in 0.._a_GLenum25_0.values.len() {
    bufs[_jGLenum25] = (*_a_GLenum25_0.values[_jGLenum25]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DrawBuffersEXT(n, bufs) };
}

pub fn retrace_glColorMaskIndexedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut r: GLboolean;
    r = (call.arg(1)).to_u32().unwrap() as u8;

    let mut g: GLboolean;
    g = (call.arg(2)).to_u32().unwrap() as u8;

    let mut b: GLboolean;
    b = (call.arg(3)).to_u32().unwrap() as u8;

    let mut a: GLboolean;
    a = (call.arg(4)).to_u32().unwrap() as u8;

    unsafe { gl::ColorMaskIndexedEXT(index, r, g, b, a) };
}

pub fn retrace_glEnableIndexedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::EnableIndexedEXT(target, index) };
}

pub fn retrace_glDisableIndexedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::DisableIndexedEXT(target, index) };
}

pub fn retrace_glEnableiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::EnableiEXT(target, index) };
}

pub fn retrace_glDisableiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::DisableiEXT(target, index) };
}

pub fn retrace_glBlendEquationiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationiEXT(buf, mode) };
}

pub fn retrace_glBlendEquationSeparateiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut modeRGB: GLenum;
    modeRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut modeAlpha: GLenum;
    modeAlpha = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationSeparateiEXT(buf, modeRGB, modeAlpha) };
}

pub fn retrace_glBlendFunciEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut src: GLenum;
    src = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dst: GLenum;
    dst = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFunciEXT(buf, src, dst) };
}

pub fn retrace_glBlendFuncSeparateiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buf: GLuint;
    buf = (call.arg(0)).to_u32().unwrap();

    let mut srcRGB: GLenum;
    srcRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut dstRGB: GLenum;
    dstRGB = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut srcAlpha: GLenum;
    srcAlpha = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut dstAlpha: GLenum;
    dstAlpha = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFuncSeparateiEXT(buf, srcRGB, dstRGB, srcAlpha, dstAlpha) };
}

pub fn retrace_glColorMaskiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut r: GLboolean;
    r = (call.arg(1)).to_u32().unwrap() as u8;

    let mut g: GLboolean;
    g = (call.arg(2)).to_u32().unwrap() as u8;

    let mut b: GLboolean;
    b = (call.arg(3)).to_u32().unwrap() as u8;

    let mut a: GLboolean;
    a = (call.arg(4)).to_u32().unwrap() as u8;

    unsafe { gl::ColorMaskiEXT(index, r, g, b, a) };
}

pub fn retrace_glDrawElementsBaseVertexEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut basevertex: GLint;
    basevertex = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::DrawElementsBaseVertexEXT(mode, count, _type, indices, basevertex) };
}

pub fn retrace_glDrawRangeElementsBaseVertexEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLuint;
    start = (call.arg(1)).to_u32().unwrap();

    let mut end: GLuint;
    end = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    let mut basevertex: GLint;
    basevertex = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::DrawRangeElementsBaseVertexEXT(mode, start, end, count, _type, indices, basevertex) };
}

pub fn retrace_glDrawElementsInstancedBaseVertexEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut instancecount: GLsizei;
    instancecount = (call.arg(4)).to_i32().unwrap();

    let mut basevertex: GLint;
    basevertex = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::DrawElementsInstancedBaseVertexEXT(mode, count, _type, indices, instancecount, basevertex) };
}

pub fn retrace_glMultiDrawElementsBaseVertexEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let count: &mut [GLsizei];
    count = _allocator.alloc_array::<GLsizei>(&call.arg(1));
    let _a_GLsizei12_0 = (call.arg(1)).to_array();
    if let Some(_a_GLsizei12_0) = _a_GLsizei12_0 {
        for _jGLsizei12 in 0.._a_GLsizei12_0.values.len() {
    count[_jGLsizei12] = (*_a_GLsizei12_0.values[_jGLsizei12]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    indices = _allocator.alloc_array::< GLvoid >(&call.arg(3));
    let _a_constGLvoid245_0 = (call.arg(3)).to_array();
    if let Some(_a_constGLvoid245_0) = _a_constGLvoid245_0 {
        for _jconstGLvoid245 in 0.._a_constGLvoid245_0.values.len() {
    let indices[_jconstGLvoid245] = (*_a_constGLvoid245_0.values[_jconstGLvoid245]).to_pointer().unwrap() as *mut c_void;
        }
    }
    let params = params.as_mut_ptr();

    let mut drawcount: GLsizei;
    drawcount = (call.arg(4)).to_i32().unwrap();

    let basevertex: &mut [GLint];
    basevertex = _allocator.alloc_array::<GLint>(&call.arg(5));
    let _a_GLint236_0 = (call.arg(5)).to_array();
    if let Some(_a_GLint236_0) = _a_GLint236_0 {
        for _jGLint236 in 0.._a_GLint236_0.values.len() {
    basevertex[_jGLint236] = (*_a_GLint236_0.values[_jGLint236]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiDrawElementsBaseVertexEXT(mode, count, _type, indices, drawcount, basevertex) };
}

pub fn retrace_glDrawArraysInstancedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLint;
    first = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut instancecount: GLsizei;
    instancecount = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::DrawArraysInstancedEXT(mode, first, count, instancecount) };
}

pub fn retrace_glDrawElementsInstancedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut instancecount: GLsizei;
    instancecount = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::DrawElementsInstancedEXT(mode, count, _type, indices, instancecount) };
}

pub fn retrace_glDrawRangeElementsEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut start: GLuint;
    start = (call.arg(1)).to_u32().unwrap();

    let mut end: GLuint;
    end = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    let indices = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::DrawRangeElementsEXT(mode, start, end, count, _type, indices) };
}

pub fn retrace_glFogCoordfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLfloat;
    coord = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::FogCoordfEXT(coord) };
}

pub fn retrace_glFogCoordfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let coord: &mut [GLfloat];
    coord = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_PGLfloat20_0 = (call.arg(0)).to_array().unwrap();
    coord[0] = (_a_PGLfloat20_0.values[0]).to_f32().unwrap();

    unsafe { gl::FogCoordfvEXT(coord) };
}

pub fn retrace_glFogCoorddEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLdouble;
    coord = (call.arg(0)).to_f64().unwrap();

    unsafe { gl::FogCoorddEXT(coord) };
}

pub fn retrace_glFogCoorddvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let coord: &mut [GLdouble];
    coord = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_PGLdouble11_0 = (call.arg(0)).to_array().unwrap();
    coord[0] = (_a_PGLdouble11_0.values[0]).to_f64().unwrap();

    unsafe { gl::FogCoorddvEXT(coord) };
}

pub fn retrace_glFogCoordPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(2), true));

    unsafe { gl::FogCoordPointerEXT(_type, stride, pointer) };
}

pub fn retrace_glBlitFramebufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut srcX0: GLint;
    srcX0 = (call.arg(0)).to_i32().unwrap();

    let mut srcY0: GLint;
    srcY0 = (call.arg(1)).to_i32().unwrap();

    let mut srcX1: GLint;
    srcX1 = (call.arg(2)).to_i32().unwrap();

    let mut srcY1: GLint;
    srcY1 = (call.arg(3)).to_i32().unwrap();

    let mut dstX0: GLint;
    dstX0 = (call.arg(4)).to_i32().unwrap();

    let mut dstY0: GLint;
    dstY0 = (call.arg(5)).to_i32().unwrap();

    let mut dstX1: GLint;
    dstX1 = (call.arg(6)).to_i32().unwrap();

    let mut dstY1: GLint;
    dstY1 = (call.arg(7)).to_i32().unwrap();

    let mut mask: GLbitfield;
    mask = (call.arg(8)).to_u32().unwrap();

    let mut filter: GLenum;
    filter = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    glretrace::updateDrawable(std::max(dstX0, dstX1), std::max(dstY0, dstY1));
    unsafe { gl::BlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter) };
}

pub fn retrace_glRenderbufferStorageMultisampleEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::RenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height) };
}

pub fn retrace_glBindRenderbufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(1)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    unsafe { gl::BindRenderbufferEXT(target, renderbuffer) };
}

pub fn retrace_glDeleteRenderbuffersEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let renderbuffers: &mut [GLuint];
    renderbuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint216_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint216_0) = _a_GLuint216_0 {
        for _jGLuint216 in 0.._a_GLuint216_0.values.len() {
    renderbuffers[_jGLuint216] = (*_a_GLuint216_0.values[_jGLuint216]).to_u32().unwrap();
    renderbuffers[_jGLuint216] = _renderbuffer_map[renderbuffers[_jGLuint216]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteRenderbuffersEXT(n, renderbuffers) };
}

pub fn retrace_glGenRenderbuffersEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let renderbuffers: &mut [GLuint];
    renderbuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenRenderbuffersEXT(n, renderbuffers) };
    let _aGLuint218 = (call.arg(1)).to_array();
    if (_aGLuint218) {
        for _jGLuint218 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint218.values[_jGLuint218]).to_u32().unwrap();
    _renderbuffer_map[_origResult] = renderbuffers[_jGLuint218];
        }
    }
}

pub fn retrace_glRenderbufferStorageEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::RenderbufferStorageEXT(target, internalformat, width, height) };
}

pub fn retrace_glBindFramebufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut framebuffer: GLuint;
    framebuffer = (call.arg(1)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    unsafe { gl::BindFramebufferEXT(target, framebuffer) };
}

pub fn retrace_glDeleteFramebuffersEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let framebuffers: &mut [GLuint];
    framebuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint219_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint219_0) = _a_GLuint219_0 {
        for _jGLuint219 in 0.._a_GLuint219_0.values.len() {
    framebuffers[_jGLuint219] = (*_a_GLuint219_0.values[_jGLuint219]).to_u32().unwrap();
    framebuffers[_jGLuint219] = _framebuffer_map[framebuffers[_jGLuint219]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteFramebuffersEXT(n, framebuffers) };
}

pub fn retrace_glGenFramebuffersEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let framebuffers: &mut [GLuint];
    framebuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenFramebuffersEXT(n, framebuffers) };
    let _aGLuint221 = (call.arg(1)).to_array();
    if (_aGLuint221) {
        for _jGLuint221 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint221.values[_jGLuint221]).to_u32().unwrap();
    _framebuffer_map[_origResult] = framebuffers[_jGLuint221];
        }
    }
}

pub fn retrace_glCheckFramebufferStatusEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::CheckFramebufferStatusEXT(target) };

    let _origResult = call.ret.to_i32().unwrap();
}

pub fn retrace_glFramebufferTexture1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::FramebufferTexture1DEXT(target, attachment, textarget, texture, level) };
}

pub fn retrace_glFramebufferTexture2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::FramebufferTexture2DEXT(target, attachment, textarget, texture, level) };
}

pub fn retrace_glFramebufferTexture3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::FramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset) };
}

pub fn retrace_glFramebufferRenderbufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffertarget: GLenum;
    renderbuffertarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(3)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    unsafe { gl::FramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer) };
}

pub fn retrace_glGenerateMipmapEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::GenerateMipmapEXT(target) };
}

pub fn retrace_glFramebufferTextureEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::FramebufferTextureEXT(target, attachment, texture, level) };
}

pub fn retrace_glProgramParameteriEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLint;
    value = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ProgramParameteriEXT(program, pname, value) };
}

pub fn retrace_glProgramEnvParameters4fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat224_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat224_0) = _a_GLfloat224_0 {
        for _jGLfloat224 in 0.._a_GLfloat224_0.values.len() {
    params[_jGLfloat224] = (*_a_GLfloat224_0.values[_jGLfloat224]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramEnvParameters4fvEXT(target, index, count, params) };
}

pub fn retrace_glProgramLocalParameters4fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat225_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat225_0) = _a_GLfloat225_0 {
        for _jGLfloat225 in 0.._a_GLfloat225_0.values.len() {
    params[_jGLfloat225] = (*_a_GLfloat225_0.values[_jGLfloat225]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramLocalParameters4fvEXT(target, index, count, params) };
}

pub fn retrace_glUniform1uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::Uniform1uiEXT(location, v0) };
}

pub fn retrace_glUniform2uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(1)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::Uniform2uiEXT(location, v0, v1) };
}

pub fn retrace_glUniform3uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(1)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(2)).to_u32().unwrap();

    let mut v2: GLuint;
    v2 = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::Uniform3uiEXT(location, v0, v1, v2) };
}

pub fn retrace_glUniform4uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut v0: GLuint;
    v0 = (call.arg(1)).to_u32().unwrap();

    let mut v1: GLuint;
    v1 = (call.arg(2)).to_u32().unwrap();

    let mut v2: GLuint;
    v2 = (call.arg(3)).to_u32().unwrap();

    let mut v3: GLuint;
    v3 = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::Uniform4uiEXT(location, v0, v1, v2, v3) };
}

pub fn retrace_glUniform1uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint222_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint222_0) = _a_GLuint222_0 {
        for _jGLuint222 in 0.._a_GLuint222_0.values.len() {
    value[_jGLuint222] = (*_a_GLuint222_0.values[_jGLuint222]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1uivEXT(location, count, value) };
}

pub fn retrace_glUniform2uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint223_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint223_0) = _a_GLuint223_0 {
        for _jGLuint223 in 0.._a_GLuint223_0.values.len() {
    value[_jGLuint223] = (*_a_GLuint223_0.values[_jGLuint223]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2uivEXT(location, count, value) };
}

pub fn retrace_glUniform3uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint224_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint224_0) = _a_GLuint224_0 {
        for _jGLuint224 in 0.._a_GLuint224_0.values.len() {
    value[_jGLuint224] = (*_a_GLuint224_0.values[_jGLuint224]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3uivEXT(location, count, value) };
}

pub fn retrace_glUniform4uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint];
    value = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint225_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint225_0) = _a_GLuint225_0 {
        for _jGLuint225 in 0.._a_GLuint225_0.values.len() {
    value[_jGLuint225] = (*_a_GLuint225_0.values[_jGLuint225]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4uivEXT(location, count, value) };
}

pub fn retrace_glGetHistogramEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut reset: GLboolean;
    reset = (call.arg(1)).to_u32().unwrap() as u8;

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let values: &mut [GLvoid];
    values = (call.arg(4)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetHistogramEXT(target, reset, format, _type, values) };
}

pub fn retrace_glGetHistogramParameterivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));

    unsafe { gl::GetHistogramParameterivEXT(target, pname, params) };
    let _aGLint238 = (call.arg(2)).to_array();
    if (_aGLint238) {
        for _jGLint238 in 0..length {
        }
    }
}

pub fn retrace_glGetMinmaxEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut reset: GLboolean;
    reset = (call.arg(1)).to_u32().unwrap() as u8;

    let mut format: GLenum;
    format = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let values: &mut [GLvoid];
    values = (call.arg(4)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::GetMinmaxEXT(target, reset, format, _type, values) };
}

pub fn retrace_glHistogramEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut sink: GLboolean;
    sink = (call.arg(3)).to_u32().unwrap() as u8;

    unsafe { gl::HistogramEXT(target, width, internalformat, sink) };
}

pub fn retrace_glMinmaxEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut sink: GLboolean;
    sink = (call.arg(2)).to_u32().unwrap() as u8;

    unsafe { gl::MinmaxEXT(target, internalformat, sink) };
}

pub fn retrace_glResetHistogramEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ResetHistogramEXT(target) };
}

pub fn retrace_glResetMinmaxEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ResetMinmaxEXT(target) };
}

pub fn retrace_glIndexFuncEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut func: GLenum;
    func = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _ref: GLclampf;
    _ref = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::IndexFuncEXT(func, _ref) };
}

pub fn retrace_glIndexMaterialEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::IndexMaterialEXT(face, mode) };
}

pub fn retrace_glVertexAttribDivisorEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut divisor: GLuint;
    divisor = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexAttribDivisorEXT(index, divisor) };
}

pub fn retrace_glApplyTextureEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ApplyTextureEXT(mode) };
}

pub fn retrace_glTextureLightEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::TextureLightEXT(pname) };
}

pub fn retrace_glTextureMaterialEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::TextureMaterialEXT(face, mode) };
}

pub fn retrace_glMapBufferRangeEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut length: GLsizeiptr;
    length = (call.arg(2)).to_i32().unwrap();

    let mut access: GLbitfield;
    access = (call.arg(3)).to_u32().unwrap();

    let _result = unsafe { gl::MapBufferRangeEXT(target, offset, length, access) };

    retrace::addRegion(call, (*call.ret).toUIntPtr(), _result, length);
}

pub fn retrace_glFlushMappedBufferRangeEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptr;
    offset = (call.arg(1)).to_i32().unwrap();

    let mut length: GLsizeiptr;
    length = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::FlushMappedBufferRangeEXT(target, offset, length) };
}

pub fn retrace_glMultiDrawArraysEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let first: &mut [GLint];
    first = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint239_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint239_0) = _a_GLint239_0 {
        for _jGLint239 in 0.._a_GLint239_0.values.len() {
    first[_jGLint239] = (*_a_GLint239_0.values[_jGLint239]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let count: &mut [GLsizei];
    count = _allocator.alloc_array::<GLsizei>(&call.arg(2));
    let _a_GLsizei13_0 = (call.arg(2)).to_array();
    if let Some(_a_GLsizei13_0) = _a_GLsizei13_0 {
        for _jGLsizei13 in 0.._a_GLsizei13_0.values.len() {
    count[_jGLsizei13] = (*_a_GLsizei13_0.values[_jGLsizei13]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut drawcount: GLsizei;
    drawcount = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiDrawArraysEXT(mode, first, count, drawcount) };
}

pub fn retrace_glMultiDrawElementsEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let count: &mut [GLsizei];
    count = _allocator.alloc_array::<GLsizei>(&call.arg(1));
    let _a_GLsizei14_0 = (call.arg(1)).to_array();
    if let Some(_a_GLsizei14_0) = _a_GLsizei14_0 {
        for _jGLsizei14 in 0.._a_GLsizei14_0.values.len() {
    count[_jGLsizei14] = (*_a_GLsizei14_0.values[_jGLsizei14]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    indices = _allocator.alloc_array::< GLvoid >(&call.arg(3));
    let _a_constGLvoid248_0 = (call.arg(3)).to_array();
    if let Some(_a_constGLvoid248_0) = _a_constGLvoid248_0 {
        for _jconstGLvoid248 in 0.._a_constGLvoid248_0.values.len() {
    let indices[_jconstGLvoid248] = (*_a_constGLvoid248_0.values[_jconstGLvoid248]).to_pointer().unwrap() as *mut c_void;
        }
    }
    let params = params.as_mut_ptr();

    let mut drawcount: GLsizei;
    drawcount = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiDrawElementsEXT(mode, count, _type, indices, drawcount) };
}

pub fn retrace_glMultiDrawArraysIndirectEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    indirect = static_cast<GLvoid *>(retrace::toPointer(call.arg(1)));

    let mut drawcount: GLsizei;
    drawcount = (call.arg(2)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::MultiDrawArraysIndirectEXT(mode, indirect, drawcount, stride) };
}

pub fn retrace_glMultiDrawElementsIndirectEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    indirect = static_cast<GLvoid *>(retrace::toPointer(call.arg(2)));

    let mut drawcount: GLsizei;
    drawcount = (call.arg(3)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiDrawElementsIndirectEXT(mode, _type, indirect, drawcount, stride) };
}

pub fn retrace_glSampleMaskEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut value: GLclampf;
    value = (call.arg(0)).to_f32().unwrap();

    let mut invert: GLboolean;
    invert = (call.arg(1)).to_u32().unwrap() as u8;

    unsafe { gl::SampleMaskEXT(value, invert) };
}

pub fn retrace_glSamplePatternEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pattern: GLenum;
    pattern = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::SamplePatternEXT(pattern) };
}

pub fn retrace_glFramebufferTexture2DMultisampleEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(5)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    unsafe { gl::FramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples) };
}

pub fn retrace_glReadBufferIndexedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut src: GLenum;
    src = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLint;
    index = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::ReadBufferIndexedEXT(src, index) };
}

pub fn retrace_glDrawBuffersIndexedEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLint;
    n = (call.arg(0)).to_i32().unwrap();

    let location: &mut [GLenum];
    location = _allocator.alloc_array::<GLenum>(&call.arg(1));
    let _a_GLenum26_0 = (call.arg(1)).to_array();
    if let Some(_a_GLenum26_0) = _a_GLenum26_0 {
        for _jGLenum26 in 0.._a_GLenum26_0.values.len() {
    location[_jGLenum26] = (*_a_GLenum26_0.values[_jGLenum26]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let indices: &mut [GLint];
    indices = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint240_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint240_0) = _a_GLint240_0 {
        for _jGLint240 in 0.._a_GLint240_0.values.len() {
    indices[_jGLint240] = (*_a_GLint240_0.values[_jGLint240]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DrawBuffersIndexedEXT(n, location, indices) };
}

pub fn retrace_glColorTableEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let table: &mut [GLvoid];
    let table = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ColorTableEXT(target, internalformat, width, format, _type, table) };
}

pub fn retrace_glPixelTransformParameteriEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::PixelTransformParameteriEXT(target, pname, param) };
}

pub fn retrace_glPixelTransformParameterfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::PixelTransformParameterfEXT(target, pname, param) };
}

pub fn retrace_glPixelTransformParameterivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint241_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint241_0) = _a_GLint241_0 {
        for _jGLint241 in 0.._a_GLint241_0.values.len() {
    params[_jGLint241] = (*_a_GLint241_0.values[_jGLint241]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PixelTransformParameterivEXT(target, pname, params) };
}

pub fn retrace_glPixelTransformParameterfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat226_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat226_0) = _a_GLfloat226_0 {
        for _jGLfloat226 in 0.._a_GLfloat226_0.values.len() {
    params[_jGLfloat226] = (*_a_GLfloat226_0.values[_jGLfloat226]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PixelTransformParameterfvEXT(target, pname, params) };
}

pub fn retrace_glPointParameterfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PointParameterfEXT(pname, param) };
}

pub fn retrace_glPointParameterfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat227_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat227_0) = _a_GLfloat227_0 {
        for _jGLfloat227 in 0.._a_GLfloat227_0.values.len() {
    params[_jGLfloat227] = (*_a_GLfloat227_0.values[_jGLfloat227]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PointParameterfvEXT(pname, params) };
}

pub fn retrace_glPolygonOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLfloat;
    factor = (call.arg(0)).to_f32().unwrap();

    let mut bias: GLfloat;
    bias = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PolygonOffsetEXT(factor, bias) };
}

pub fn retrace_glPolygonOffsetClampEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLfloat;
    factor = (call.arg(0)).to_f32().unwrap();

    let mut units: GLfloat;
    units = (call.arg(1)).to_f32().unwrap();

    let mut clamp: GLfloat;
    clamp = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::PolygonOffsetClampEXT(factor, units, clamp) };
}

pub fn retrace_glPrimitiveBoundingBoxEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut minX: GLfloat;
    minX = (call.arg(0)).to_f32().unwrap();

    let mut minY: GLfloat;
    minY = (call.arg(1)).to_f32().unwrap();

    let mut minZ: GLfloat;
    minZ = (call.arg(2)).to_f32().unwrap();

    let mut minW: GLfloat;
    minW = (call.arg(3)).to_f32().unwrap();

    let mut maxX: GLfloat;
    maxX = (call.arg(4)).to_f32().unwrap();

    let mut maxY: GLfloat;
    maxY = (call.arg(5)).to_f32().unwrap();

    let mut maxZ: GLfloat;
    maxZ = (call.arg(6)).to_f32().unwrap();

    let mut maxW: GLfloat;
    maxW = (call.arg(7)).to_f32().unwrap();

    unsafe { gl::PrimitiveBoundingBoxEXT(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW) };
}

pub fn retrace_glProvokingVertexEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ProvokingVertexEXT(mode) };
}

pub fn retrace_glRasterSamplesEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut samples: GLuint;
    samples = (call.arg(0)).to_u32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_RASTER_SAMPLES_EXT, &max_samples);
    if (samples > static_cast<GLuint>(max_samples)) {
        samples = static_cast<GLuint>(max_samples);
    }

    let mut fixedsamplelocations: GLboolean;
    fixedsamplelocations = (call.arg(1)).to_u32().unwrap() as u8;

    unsafe { gl::RasterSamplesEXT(samples, fixedsamplelocations) };
}

pub fn retrace_glReadnPixelsEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(6)).to_i32().unwrap();

    let data: &mut [GLvoid];
    data = (call.arg(7)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::ReadnPixelsEXT(x, y, width, height, format, _type, bufSize, data) };
}

pub fn retrace_glSecondaryColor3bEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLbyte;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLbyte;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLbyte;
    blue = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::SecondaryColor3bEXT(red, green, blue) };
}

pub fn retrace_glSecondaryColor3bvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(0));
    let _a_GLbyte14_0 = (call.arg(0)).to_array();
    if let Some(_a_GLbyte14_0) = _a_GLbyte14_0 {
        for _jGLbyte14 in 0.._a_GLbyte14_0.values.len() {
    v[_jGLbyte14] = (*_a_GLbyte14_0.values[_jGLbyte14]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3bvEXT(v) };
}

pub fn retrace_glSecondaryColor3dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLdouble;
    red = (call.arg(0)).to_f64().unwrap();

    let mut green: GLdouble;
    green = (call.arg(1)).to_f64().unwrap();

    let mut blue: GLdouble;
    blue = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::SecondaryColor3dEXT(red, green, blue) };
}

pub fn retrace_glSecondaryColor3dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble126_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble126_0) = _a_GLdouble126_0 {
        for _jGLdouble126 in 0.._a_GLdouble126_0.values.len() {
    v[_jGLdouble126] = (*_a_GLdouble126_0.values[_jGLdouble126]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3dvEXT(v) };
}

pub fn retrace_glSecondaryColor3fEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLfloat;
    red = (call.arg(0)).to_f32().unwrap();

    let mut green: GLfloat;
    green = (call.arg(1)).to_f32().unwrap();

    let mut blue: GLfloat;
    blue = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::SecondaryColor3fEXT(red, green, blue) };
}

pub fn retrace_glSecondaryColor3fvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat228_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat228_0) = _a_GLfloat228_0 {
        for _jGLfloat228 in 0.._a_GLfloat228_0.values.len() {
    v[_jGLfloat228] = (*_a_GLfloat228_0.values[_jGLfloat228]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3fvEXT(v) };
}

pub fn retrace_glSecondaryColor3iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLint;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLint;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLint;
    blue = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::SecondaryColor3iEXT(red, green, blue) };
}

pub fn retrace_glSecondaryColor3ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint242_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint242_0) = _a_GLint242_0 {
        for _jGLint242 in 0.._a_GLint242_0.values.len() {
    v[_jGLint242] = (*_a_GLint242_0.values[_jGLint242]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3ivEXT(v) };
}

pub fn retrace_glSecondaryColor3sEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLshort;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLshort;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLshort;
    blue = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::SecondaryColor3sEXT(red, green, blue) };
}

pub fn retrace_glSecondaryColor3svEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort42_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort42_0) = _a_GLshort42_0 {
        for _jGLshort42 in 0.._a_GLshort42_0.values.len() {
    v[_jGLshort42] = (*_a_GLshort42_0.values[_jGLshort42]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3svEXT(v) };
}

pub fn retrace_glSecondaryColor3ubEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLubyte;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLubyte;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLubyte;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::SecondaryColor3ubEXT(red, green, blue) };
}

pub fn retrace_glSecondaryColor3ubvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(0));
    let _a_GLubyte19_0 = (call.arg(0)).to_array();
    if let Some(_a_GLubyte19_0) = _a_GLubyte19_0 {
        for _jGLubyte19 in 0.._a_GLubyte19_0.values.len() {
    v[_jGLubyte19] = (*_a_GLubyte19_0.values[_jGLubyte19]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3ubvEXT(v) };
}

pub fn retrace_glSecondaryColor3uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLuint;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLuint;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLuint;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::SecondaryColor3uiEXT(red, green, blue) };
}

pub fn retrace_glSecondaryColor3uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_GLuint226_0 = (call.arg(0)).to_array();
    if let Some(_a_GLuint226_0) = _a_GLuint226_0 {
        for _jGLuint226 in 0.._a_GLuint226_0.values.len() {
    v[_jGLuint226] = (*_a_GLuint226_0.values[_jGLuint226]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3uivEXT(v) };
}

pub fn retrace_glSecondaryColor3usEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLushort;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLushort;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLushort;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::SecondaryColor3usEXT(red, green, blue) };
}

pub fn retrace_glSecondaryColor3usvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLushort];
    v = _allocator.alloc_array::<GLushort>(&call.arg(0));
    let _a_GLushort18_0 = (call.arg(0)).to_array();
    if let Some(_a_GLushort18_0) = _a_GLushort18_0 {
        for _jGLushort18 in 0.._a_GLushort18_0.values.len() {
    v[_jGLushort18] = (*_a_GLushort18_0.values[_jGLushort18]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3usvEXT(v) };
}

pub fn retrace_glSecondaryColorPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(3), true));

    unsafe { gl::SecondaryColorPointerEXT(size, _type, stride, pointer) };
}

pub fn retrace_glUseShaderProgramEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut program: GLuint;
    program = (call.arg(1)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    unsafe { gl::UseShaderProgramEXT(_type, program) };
}

pub fn retrace_glActiveProgramEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    unsafe { gl::ActiveProgramEXT(program) };
}

pub fn retrace_glCreateShaderProgramEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let string: &mut [GLchar];
    string = (GLchar *)((call.arg(1)).to_string().unwrap());

    if (retrace::dumpingState) {
        GLuint _shader = glCreateShader(type);
        if (_shader) {
            GLsizei count = 1;
            const GLchar **strings = &string;
            glShaderSource(_shader, count, strings, NULL);
            glCompileShader(_shader);
            const GLuint _program = glCreateProgram();
            if (_program) {
                GLint compiled = GL_FALSE;
                glGetShaderiv(_shader, GL_COMPILE_STATUS, &compiled);
                glProgramParameteri(_program, GL_PROGRAM_SEPARABLE, GL_TRUE);
                if (compiled) {
                    glAttachShader(_program, _shader);
                    glLinkProgram(_program);
                    if (false) glDetachShader(_program, _shader);
                }
                // TODO: append shader info log to program info log
            }
            glDeleteShader(_shader);
            _result = _program;
        } else {
            _result = 0;
        }
    } else {
    let _result = unsafe { gl::CreateShaderProgramEXT(_type, string) };

    }
        let program = _result;
        let link_status = 0;
        gl::GetProgramiv(program, gl::LINK_STATUS, &link_status);
        if link_status == 0 {
             println!("link failed");
        }
        let info_log_length = 0;
        gl::GetProgramiv(program, gl::INFO_LOG_LENGTH, &info_log_length);
        if info_log_length > 1 {
             let infoLog = vec![0i8; info_log_length].as_mut_ptr();
             gl::GetProgramInfoLog(program, info_log_length, std::ptr::null_mut(), infoLog);
        }
    let _origResult: GLuint;
    _origResult = (*call.ret).to_u32().unwrap();
if (glretrace::supportsARBShaderObjects) {
    _handleARB_map[_origResult] = _result;
} else {
    _program_map[_origResult] = _result;
}
}

pub fn retrace_glActiveShaderProgramEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pipeline: GLuint;
    pipeline = (call.arg(0)).to_u32().unwrap();
    pipeline = _pipeline_map[pipeline];

    let mut program: GLuint;
    program = (call.arg(1)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    unsafe { gl::ActiveShaderProgramEXT(pipeline, program) };
}

pub fn retrace_glBindProgramPipelineEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pipeline: GLuint;
    pipeline = (call.arg(0)).to_u32().unwrap();
    pipeline = _pipeline_map[pipeline];

    unsafe { gl::BindProgramPipelineEXT(pipeline) };
    if (currentContext) {
        self.context.currentPipeline = pipeline;
    }
}

pub fn retrace_glCreateShaderProgramvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let strings: &mut [GLchar];
    strings = _allocator.alloc_array::<GLchar >(&call.arg(2));
    let _a_constGLchar13_0 = (call.arg(2)).to_array();
    if let Some(_a_constGLchar13_0) = _a_constGLchar13_0 {
        for _jconstGLchar13 in 0.._a_constGLchar13_0.values.len() {
    strings[_jconstGLchar13] = (GLchar *)((*_a_constGLchar13_0.values[_jconstGLchar13]).to_string().unwrap());
        }
    }
    let params = params.as_mut_ptr();

    if (retrace::dumpingState) {
        GLuint _shader = glCreateShader(type);
        if (_shader) {
            glShaderSource(_shader, count, strings, NULL);
            glCompileShader(_shader);
            const GLuint _program = glCreateProgram();
            if (_program) {
                GLint compiled = GL_FALSE;
                glGetShaderiv(_shader, GL_COMPILE_STATUS, &compiled);
                glProgramParameteriEXT(_program, GL_PROGRAM_SEPARABLE, GL_TRUE);
                if (compiled) {
                    glAttachShader(_program, _shader);
                    glLinkProgram(_program);
                    if (false) glDetachShader(_program, _shader);
                }
                // TODO: append shader info log to program info log
            }
            glDeleteShader(_shader);
            _result = _program;
        } else {
            _result = 0;
        }
    } else {
    let _result = unsafe { gl::CreateShaderProgramvEXT(_type, count, strings) };

    }
        let program = _result;
        let link_status = 0;
        gl::GetProgramiv(program, gl::LINK_STATUS, &link_status);
        if link_status == 0 {
             println!("link failed");
        }
        let info_log_length = 0;
        gl::GetProgramiv(program, gl::INFO_LOG_LENGTH, &info_log_length);
        if info_log_length > 1 {
             let infoLog = vec![0i8; info_log_length].as_mut_ptr();
             gl::GetProgramInfoLog(program, info_log_length, std::ptr::null_mut(), infoLog);
        }
    let _origResult: GLuint;
    _origResult = (*call.ret).to_u32().unwrap();
if (glretrace::supportsARBShaderObjects) {
    _handleARB_map[_origResult] = _result;
} else {
    _program_map[_origResult] = _result;
}
}

pub fn retrace_glDeleteProgramPipelinesEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let pipelines: &mut [GLuint];
    pipelines = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint227_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint227_0) = _a_GLuint227_0 {
        for _jGLuint227 in 0.._a_GLuint227_0.values.len() {
    pipelines[_jGLuint227] = (*_a_GLuint227_0.values[_jGLuint227]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteProgramPipelinesEXT(n, pipelines) };
}

pub fn retrace_glGenProgramPipelinesEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let pipelines: &mut [GLuint];
    pipelines = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenProgramPipelinesEXT(n, pipelines) };
    let _aGLuint229 = (call.arg(1)).to_array();
    if (_aGLuint229) {
        for _jGLuint229 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint229.values[_jGLuint229]).to_u32().unwrap();
    _pipeline_map[_origResult] = pipelines[_jGLuint229];
        }
    }
}

pub fn retrace_glUseProgramStagesEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pipeline: GLuint;
    pipeline = (call.arg(0)).to_u32().unwrap();
    pipeline = _pipeline_map[pipeline];

    let mut stages: GLbitfield;
    stages = (call.arg(1)).to_u32().unwrap();

    let mut program: GLuint;
    program = (call.arg(2)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    unsafe { gl::UseProgramStagesEXT(pipeline, stages, program) };
}

pub fn retrace_glValidateProgramPipelineEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pipeline: GLuint;
    pipeline = (call.arg(0)).to_u32().unwrap();
    pipeline = _pipeline_map[pipeline];

    unsafe { gl::ValidateProgramPipelineEXT(pipeline) };
}

pub fn retrace_glBindImageTextureEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(1)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(2)).to_i32().unwrap();

    let mut layered: GLboolean;
    layered = (call.arg(3)).to_u32().unwrap() as u8;

    let mut layer: GLint;
    layer = (call.arg(4)).to_i32().unwrap();

    let mut access: GLenum;
    access = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut format: GLint;
    format = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::BindImageTextureEXT(index, texture, level, layered, layer, access, format) };
}

pub fn retrace_glMemoryBarrierEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut barriers: GLbitfield;
    barriers = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::MemoryBarrierEXT(barriers) };
}

pub fn retrace_glFramebufferPixelLocalStorageSizeEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLuint;
    target = (call.arg(0)).to_u32().unwrap();
    target = _framebuffer_map[target];

    let mut size: GLsizei;
    size = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::FramebufferPixelLocalStorageSizeEXT(target, size) };
}

pub fn retrace_glClearPixelLocalStorageuiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut offset: GLsizei;
    offset = (call.arg(0)).to_i32().unwrap();

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let values: &mut [GLuint];
    values = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint230_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint230_0) = _a_GLuint230_0 {
        for _jGLuint230 in 0.._a_GLuint230_0.values.len() {
    values[_jGLuint230] = (*_a_GLuint230_0.values[_jGLuint230]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClearPixelLocalStorageuiEXT(offset, n, values) };
}

pub fn retrace_glTexPageCommitmentEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut commit: GLboolean;
    commit = (call.arg(8)).to_u32().unwrap() as u8;

    unsafe { gl::TexPageCommitmentEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, commit) };
}

pub fn retrace_glStencilClearTagEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stencilTagBits: GLsizei;
    stencilTagBits = (call.arg(0)).to_i32().unwrap();

    let mut stencilClearTag: GLuint;
    stencilClearTag = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::StencilClearTagEXT(stencilTagBits, stencilClearTag) };
}

pub fn retrace_glActiveStencilFaceEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ActiveStencilFaceEXT(face) };
}

pub fn retrace_glTexSubImage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexSubImage1DEXT(target, level, xoffset, width, format, _type, pixels) };
}

pub fn retrace_glTexSubImage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, _type, pixels) };
}

pub fn retrace_glPatchParameteriEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLint;
    value = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PatchParameteriEXT(pname, value) };
}

pub fn retrace_glTexImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexImage3DEXT(target, level, internalformat, width, height, depth, border, format, _type, pixels) };
}

pub fn retrace_glTexSubImage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, _type, pixels) };
}

pub fn retrace_glFramebufferTextureLayerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    let mut layer: GLint;
    layer = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::FramebufferTextureLayerEXT(target, attachment, texture, level, layer) };
}

pub fn retrace_glTexParameterIivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint243_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint243_0) = _a_GLint243_0 {
        for _jGLint243 in 0.._a_GLint243_0.values.len() {
    params[_jGLint243] = (*_a_GLint243_0.values[_jGLint243]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexParameterIivEXT(target, pname, params) };
}

pub fn retrace_glTexParameterIuivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint231_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint231_0) = _a_GLuint231_0 {
        for _jGLuint231 in 0.._a_GLuint231_0.values.len() {
    params[_jGLuint231] = (*_a_GLuint231_0.values[_jGLuint231]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexParameterIuivEXT(target, pname, params) };
}

pub fn retrace_glSamplerParameterIivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sampler: GLuint;
    sampler = (call.arg(0)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let param: &mut [GLint];
    param = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint244_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint244_0) = _a_GLint244_0 {
        for _jGLint244 in 0.._a_GLint244_0.values.len() {
    param[_jGLint244] = (*_a_GLint244_0.values[_jGLint244]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SamplerParameterIivEXT(sampler, pname, param) };
}

pub fn retrace_glSamplerParameterIuivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sampler: GLuint;
    sampler = (call.arg(0)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let param: &mut [GLuint];
    param = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint232_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint232_0) = _a_GLuint232_0 {
        for _jGLuint232 in 0.._a_GLuint232_0.values.len() {
    param[_jGLuint232] = (*_a_GLuint232_0.values[_jGLuint232]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SamplerParameterIuivEXT(sampler, pname, param) };
}

pub fn retrace_glTexBufferEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::TexBufferEXT(target, internalformat, buffer) };
}

pub fn retrace_glTexBufferRangeEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::TexBufferRangeEXT(target, internalformat, buffer, offset, size) };
}

pub fn retrace_glClearColorIiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLint;
    red = (call.arg(0)).to_i32().unwrap();

    let mut green: GLint;
    green = (call.arg(1)).to_i32().unwrap();

    let mut blue: GLint;
    blue = (call.arg(2)).to_i32().unwrap();

    let mut alpha: GLint;
    alpha = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::ClearColorIiEXT(red, green, blue, alpha) };
}

pub fn retrace_glClearColorIuiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLuint;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLuint;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLuint;
    blue = (call.arg(2)).to_u32().unwrap();

    let mut alpha: GLuint;
    alpha = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::ClearColorIuiEXT(red, green, blue, alpha) };
}

pub fn retrace_glBindTextureEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(1)).to_u32().unwrap();
    texture = _texture_map[texture];

    unsafe { gl::BindTextureEXT(target, texture) };
}

pub fn retrace_glDeleteTexturesEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let textures: &mut [GLuint];
    textures = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint233_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint233_0) = _a_GLuint233_0 {
        for _jGLuint233 in 0.._a_GLuint233_0.values.len() {
    textures[_jGLuint233] = (*_a_GLuint233_0.values[_jGLuint233]).to_u32().unwrap();
    textures[_jGLuint233] = _texture_map[textures[_jGLuint233]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteTexturesEXT(n, textures) };
}

pub fn retrace_glGenTexturesEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let textures: &mut [GLuint];
    textures = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenTexturesEXT(n, textures) };
    let _aGLuint235 = (call.arg(1)).to_array();
    if (_aGLuint235) {
        for _jGLuint235 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint235.values[_jGLuint235]).to_u32().unwrap();
    _texture_map[_origResult] = textures[_jGLuint235];
        }
    }
}

pub fn retrace_glPrioritizeTexturesEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let textures: &mut [GLuint];
    textures = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint236_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint236_0) = _a_GLuint236_0 {
        for _jGLuint236 in 0.._a_GLuint236_0.values.len() {
    textures[_jGLuint236] = (*_a_GLuint236_0.values[_jGLuint236]).to_u32().unwrap();
    textures[_jGLuint236] = _texture_map[textures[_jGLuint236]];
        }
    }
    let params = params.as_mut_ptr();

    let priorities: &mut [GLclampf];
    priorities = _allocator.alloc_array::<GLclampf>(&call.arg(2));
    let _a_GLclampf2_0 = (call.arg(2)).to_array();
    if let Some(_a_GLclampf2_0) = _a_GLclampf2_0 {
        for _jGLclampf2 in 0.._a_GLclampf2_0.values.len() {
    priorities[_jGLclampf2] = (*_a_GLclampf2_0.values[_jGLclampf2]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PrioritizeTexturesEXT(n, textures, priorities) };
}

pub fn retrace_glTextureNormalEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::TextureNormalEXT(mode) };
}

pub fn retrace_glTexStorage1DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::TexStorage1DEXT(target, levels, internalformat, width) };
}

pub fn retrace_glTexStorage2DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::TexStorage2DEXT(target, levels, internalformat, width, height) };
}

pub fn retrace_glTexStorage3DEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut levels: GLsizei;
    levels = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::TexStorage3DEXT(target, levels, internalformat, width, height, depth) };
}

pub fn retrace_glTextureViewEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut origtexture: GLuint;
    origtexture = (call.arg(2)).to_u32().unwrap();
    origtexture = _texture_map[origtexture];

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut minlevel: GLuint;
    minlevel = (call.arg(4)).to_u32().unwrap();

    let mut numlevels: GLuint;
    numlevels = (call.arg(5)).to_u32().unwrap();

    let mut minlayer: GLuint;
    minlayer = (call.arg(6)).to_u32().unwrap();

    let mut numlayers: GLuint;
    numlayers = (call.arg(7)).to_u32().unwrap();

    unsafe { gl::TextureViewEXT(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers) };
}

pub fn retrace_glBeginTransformFeedbackEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut primitiveMode: GLenum;
    primitiveMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BeginTransformFeedbackEXT(primitiveMode) };
}

pub fn retrace_glEndTransformFeedbackEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::EndTransformFeedbackEXT() };
}

pub fn retrace_glBindBufferRangeEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::BindBufferRangeEXT(target, index, buffer, offset, size) };
}

pub fn retrace_glBindBufferOffsetEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::BindBufferOffsetEXT(target, index, buffer, offset) };
}

pub fn retrace_glBindBufferBaseEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::BindBufferBaseEXT(target, index, buffer) };
}

pub fn retrace_glTransformFeedbackVaryingsEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let varyings: &mut [GLchar];
    varyings = _allocator.alloc_array::<GLchar >(&call.arg(2));
    let _a_GLchar30_0 = (call.arg(2)).to_array();
    if let Some(_a_GLchar30_0) = _a_GLchar30_0 {
        for _jGLchar30 in 0.._a_GLchar30_0.values.len() {
    varyings[_jGLchar30] = (GLchar *)((*_a_GLchar30_0.values[_jGLchar30]).to_string().unwrap());
        }
    }
    let params = params.as_mut_ptr();

    let mut bufferMode: GLenum;
    bufferMode = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::TransformFeedbackVaryingsEXT(program, count, varyings, bufferMode) };
}

pub fn retrace_glArrayElementEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut i: GLint;
    i = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::ArrayElementEXT(i) };
}

pub fn retrace_glColorPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(4), true));

    unsafe { gl::ColorPointerEXT(size, _type, stride, count, pointer) };
}

pub fn retrace_glDrawArraysEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLint;
    first = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::DrawArraysEXT(mode, first, count) };
}

pub fn retrace_glEdgeFlagPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stride: GLsizei;
    stride = (call.arg(0)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLboolean];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(2), true));

    unsafe { gl::EdgeFlagPointerEXT(stride, count, pointer) };
}

pub fn retrace_glIndexPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(3), true));

    unsafe { gl::IndexPointerEXT(_type, stride, count, pointer) };
}

pub fn retrace_glNormalPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(3), true));

    unsafe { gl::NormalPointerEXT(_type, stride, count, pointer) };
}

pub fn retrace_glTexCoordPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(4), true));

    unsafe { gl::TexCoordPointerEXT(size, _type, stride, count, pointer) };
}

pub fn retrace_glVertexPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(4), true));

    unsafe { gl::VertexPointerEXT(size, _type, stride, count, pointer) };
}

pub fn retrace_glVertexAttribL1dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::VertexAttribL1dEXT(index, x) };
}

pub fn retrace_glVertexAttribL2dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::VertexAttribL2dEXT(index, x, y) };
}

pub fn retrace_glVertexAttribL3dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::VertexAttribL3dEXT(index, x, y, z) };
}

pub fn retrace_glVertexAttribL4dEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::VertexAttribL4dEXT(index, x, y, z, w) };
}

pub fn retrace_glVertexAttribL1dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_PGLdouble12_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLdouble12_0.values[0]).to_f64().unwrap();

    unsafe { gl::VertexAttribL1dvEXT(index, v) };
}

pub fn retrace_glVertexAttribL2dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble127_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble127_0) = _a_GLdouble127_0 {
        for _jGLdouble127 in 0.._a_GLdouble127_0.values.len() {
    v[_jGLdouble127] = (*_a_GLdouble127_0.values[_jGLdouble127]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL2dvEXT(index, v) };
}

pub fn retrace_glVertexAttribL3dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble128_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble128_0) = _a_GLdouble128_0 {
        for _jGLdouble128 in 0.._a_GLdouble128_0.values.len() {
    v[_jGLdouble128] = (*_a_GLdouble128_0.values[_jGLdouble128]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL3dvEXT(index, v) };
}

pub fn retrace_glVertexAttribL4dvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble129_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble129_0) = _a_GLdouble129_0 {
        for _jGLdouble129 in 0.._a_GLdouble129_0.values.len() {
    v[_jGLdouble129] = (*_a_GLdouble129_0.values[_jGLdouble129]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL4dvEXT(index, v) };
}

pub fn retrace_glVertexAttribLPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(4), true));

    unsafe { gl::VertexAttribLPointerEXT(index, size, _type, stride, pointer) };
}

pub fn retrace_glBeginVertexShaderEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::BeginVertexShaderEXT() };
}

pub fn retrace_glEndVertexShaderEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::EndVertexShaderEXT() };
}

pub fn retrace_glBindVertexShaderEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::BindVertexShaderEXT(id) };
}

pub fn retrace_glGenVertexShadersEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut range: GLuint;
    range = (call.arg(0)).to_u32().unwrap();

    let _result = unsafe { gl::GenVertexShadersEXT(range) };

}

pub fn retrace_glDeleteVertexShaderEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::DeleteVertexShaderEXT(id) };
}

pub fn retrace_glShaderOp1EXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut op: GLenum;
    op = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut res: GLuint;
    res = (call.arg(1)).to_u32().unwrap();

    let mut arg1: GLuint;
    arg1 = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::ShaderOp1EXT(op, res, arg1) };
}

pub fn retrace_glShaderOp2EXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut op: GLenum;
    op = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut res: GLuint;
    res = (call.arg(1)).to_u32().unwrap();

    let mut arg1: GLuint;
    arg1 = (call.arg(2)).to_u32().unwrap();

    let mut arg2: GLuint;
    arg2 = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::ShaderOp2EXT(op, res, arg1, arg2) };
}

pub fn retrace_glShaderOp3EXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut op: GLenum;
    op = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut res: GLuint;
    res = (call.arg(1)).to_u32().unwrap();

    let mut arg1: GLuint;
    arg1 = (call.arg(2)).to_u32().unwrap();

    let mut arg2: GLuint;
    arg2 = (call.arg(3)).to_u32().unwrap();

    let mut arg3: GLuint;
    arg3 = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::ShaderOp3EXT(op, res, arg1, arg2, arg3) };
}

pub fn retrace_glSwizzleEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut res: GLuint;
    res = (call.arg(0)).to_u32().unwrap();

    let mut in: GLuint;
    in = (call.arg(1)).to_u32().unwrap();

    let mut outX: GLenum;
    outX = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut outY: GLenum;
    outY = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut outZ: GLenum;
    outZ = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut outW: GLenum;
    outW = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::SwizzleEXT(res, in, outX, outY, outZ, outW) };
}

pub fn retrace_glWriteMaskEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut res: GLuint;
    res = (call.arg(0)).to_u32().unwrap();

    let mut in: GLuint;
    in = (call.arg(1)).to_u32().unwrap();

    let mut outX: GLenum;
    outX = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut outY: GLenum;
    outY = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut outZ: GLenum;
    outZ = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut outW: GLenum;
    outW = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::WriteMaskEXT(res, in, outX, outY, outZ, outW) };
}

pub fn retrace_glInsertComponentEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut res: GLuint;
    res = (call.arg(0)).to_u32().unwrap();

    let mut src: GLuint;
    src = (call.arg(1)).to_u32().unwrap();

    let mut num: GLuint;
    num = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::InsertComponentEXT(res, src, num) };
}

pub fn retrace_glExtractComponentEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut res: GLuint;
    res = (call.arg(0)).to_u32().unwrap();

    let mut src: GLuint;
    src = (call.arg(1)).to_u32().unwrap();

    let mut num: GLuint;
    num = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::ExtractComponentEXT(res, src, num) };
}

pub fn retrace_glGenSymbolsEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut datatype: GLenum;
    datatype = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut storagetype: GLenum;
    storagetype = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut range: GLenum;
    range = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut components: GLuint;
    components = (call.arg(3)).to_u32().unwrap();

    let _result = unsafe { gl::GenSymbolsEXT(datatype, storagetype, range, components) };

}

pub fn retrace_glSetInvariantEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let addr: &mut [GLvoid];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::SetInvariantEXT(id, _type, addr) };
}

pub fn retrace_glSetLocalConstantEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let addr: &mut [GLvoid];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::SetLocalConstantEXT(id, _type, addr) };
}

pub fn retrace_glVariantbvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let addr: &mut [GLbyte];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::VariantbvEXT(id, addr) };
}

pub fn retrace_glVariantsvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let addr: &mut [GLshort];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::VariantsvEXT(id, addr) };
}

pub fn retrace_glVariantivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let addr: &mut [GLint];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::VariantivEXT(id, addr) };
}

pub fn retrace_glVariantfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let addr: &mut [GLfloat];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::VariantfvEXT(id, addr) };
}

pub fn retrace_glVariantdvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let addr: &mut [GLdouble];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::VariantdvEXT(id, addr) };
}

pub fn retrace_glVariantubvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let addr: &mut [GLubyte];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::VariantubvEXT(id, addr) };
}

pub fn retrace_glVariantusvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let addr: &mut [GLushort];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::VariantusvEXT(id, addr) };
}

pub fn retrace_glVariantuivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let addr: &mut [GLuint];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::VariantuivEXT(id, addr) };
}

pub fn retrace_glVariantPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLuint;
    stride = (call.arg(2)).to_u32().unwrap();

    let addr: &mut [GLvoid];
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    }
    unsafe { gl::VariantPointerEXT(id, _type, stride, addr) };
}

pub fn retrace_glEnableVariantClientStateEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::EnableVariantClientStateEXT(id) };
}

pub fn retrace_glDisableVariantClientStateEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::DisableVariantClientStateEXT(id) };
}

pub fn retrace_glBindLightParameterEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLenum;
    value = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::BindLightParameterEXT(light, value) };

}

pub fn retrace_glBindMaterialParameterEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLenum;
    value = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::BindMaterialParameterEXT(face, value) };

}

pub fn retrace_glBindTexGenParameterEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut unit: GLenum;
    unit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coord: GLenum;
    coord = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLenum;
    value = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::BindTexGenParameterEXT(unit, coord, value) };

}

pub fn retrace_glBindTextureUnitParameterEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut unit: GLenum;
    unit = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLenum;
    value = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::BindTextureUnitParameterEXT(unit, value) };

}

pub fn retrace_glBindParameterEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut value: GLenum;
    value = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::BindParameterEXT(value) };

}

pub fn retrace_glVertexWeightfEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut weight: GLfloat;
    weight = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::VertexWeightfEXT(weight) };
}

pub fn retrace_glVertexWeightfvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let weight: &mut [GLfloat];
    weight = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_PGLfloat21_0 = (call.arg(0)).to_array().unwrap();
    weight[0] = (_a_PGLfloat21_0.values[0]).to_f32().unwrap();

    unsafe { gl::VertexWeightfvEXT(weight) };
}

pub fn retrace_glVertexWeightPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLsizei;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::VertexWeightPointerEXT(size, _type, stride, pointer) };
}

pub fn retrace_glImportSyncEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut external_sync_type: GLenum;
    external_sync_type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut external_sync: GLintptr;
    external_sync = (call.arg(1)).to_i32().unwrap();

    let mut flags: GLbitfield;
    flags = (call.arg(2)).to_u32().unwrap();

    let _result = unsafe { gl::ImportSyncEXT(external_sync_type, external_sync, flags) };

    let _origResult: GLsync;
    let _origResult = (*call.ret).to_pointer().unwrap() as *mut c_void;
    _sync_map[_origResult] = _result;
}

pub fn retrace_glFrameTerminatorGREMEDY(&mut self, call: &mut Call) {
    glretrace::frame_complete(call);
}

pub fn retrace_glStringMarkerGREMEDY(&mut self, call: &mut Call) {
}

pub fn retrace_glImageTransformParameteriHP(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ImageTransformParameteriHP(target, pname, param) };
}

pub fn retrace_glImageTransformParameterfHP(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::ImageTransformParameterfHP(target, pname, param) };
}

pub fn retrace_glImageTransformParameterivHP(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint245_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint245_0) = _a_GLint245_0 {
        for _jGLint245 in 0.._a_GLint245_0.values.len() {
    params[_jGLint245] = (*_a_GLint245_0.values[_jGLint245]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ImageTransformParameterivHP(target, pname, params) };
}

pub fn retrace_glImageTransformParameterfvHP(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat229_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat229_0) = _a_GLfloat229_0 {
        for _jGLfloat229 in 0.._a_GLfloat229_0.values.len() {
    params[_jGLfloat229] = (*_a_GLfloat229_0.values[_jGLfloat229]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ImageTransformParameterfvHP(target, pname, params) };
}

pub fn retrace_glMultiModeDrawArraysIBM(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mode: &mut [GLenum];
    mode = _allocator.alloc_array::<GLenum>(&call.arg(0));
    let _a_GLenum27_0 = (call.arg(0)).to_array();
    if let Some(_a_GLenum27_0) = _a_GLenum27_0 {
        for _jGLenum27 in 0.._a_GLenum27_0.values.len() {
    mode[_jGLenum27] = (*_a_GLenum27_0.values[_jGLenum27]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let first: &mut [GLint];
    first = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint246_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint246_0) = _a_GLint246_0 {
        for _jGLint246 in 0.._a_GLint246_0.values.len() {
    first[_jGLint246] = (*_a_GLint246_0.values[_jGLint246]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let count: &mut [GLsizei];
    count = _allocator.alloc_array::<GLsizei>(&call.arg(2));
    let _a_GLsizei15_0 = (call.arg(2)).to_array();
    if let Some(_a_GLsizei15_0) = _a_GLsizei15_0 {
        for _jGLsizei15 in 0.._a_GLsizei15_0.values.len() {
    count[_jGLsizei15] = (*_a_GLsizei15_0.values[_jGLsizei15]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut drawcount: GLsizei;
    drawcount = (call.arg(3)).to_i32().unwrap();

    let mut modestride: GLint;
    modestride = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiModeDrawArraysIBM(mode, first, count, drawcount, modestride) };
}

pub fn retrace_glMultiModeDrawElementsIBM(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mode: &mut [GLenum];
    mode = _allocator.alloc_array::<GLenum>(&call.arg(0));
    let _a_GLenum28_0 = (call.arg(0)).to_array();
    if let Some(_a_GLenum28_0) = _a_GLenum28_0 {
        for _jGLenum28 in 0.._a_GLenum28_0.values.len() {
    mode[_jGLenum28] = (*_a_GLenum28_0.values[_jGLenum28]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let count: &mut [GLsizei];
    count = _allocator.alloc_array::<GLsizei>(&call.arg(1));
    let _a_GLsizei16_0 = (call.arg(1)).to_array();
    if let Some(_a_GLsizei16_0) = _a_GLsizei16_0 {
        for _jGLsizei16 in 0.._a_GLsizei16_0.values.len() {
    count[_jGLsizei16] = (*_a_GLsizei16_0.values[_jGLsizei16]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let indices: &mut [GLvoid];
    indices = _allocator.alloc_array::< GLvoid >(&call.arg(3));
    let _a_constGLvoid249_0 = (call.arg(3)).to_array();
    if let Some(_a_constGLvoid249_0) = _a_constGLvoid249_0 {
        for _jconstGLvoid249 in 0.._a_constGLvoid249_0.values.len() {
    let indices[_jconstGLvoid249] = (*_a_constGLvoid249_0.values[_jconstGLvoid249]).to_pointer().unwrap() as *mut c_void;
        }
    }
    let params = params.as_mut_ptr();

    let mut drawcount: GLsizei;
    drawcount = (call.arg(4)).to_i32().unwrap();

    let mut modestride: GLint;
    modestride = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::MultiModeDrawElementsIBM(mode, count, _type, indices, drawcount, modestride) };
}

pub fn retrace_glColorPointerListIBM(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLint;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    let mut ptrstride: GLint;
    ptrstride = (call.arg(4)).to_i32().unwrap();

    if (1) {
    }
    unsafe { gl::ColorPointerListIBM(size, _type, stride, pointer, ptrstride) };
}

pub fn retrace_glSecondaryColorPointerListIBM(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLint;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    let mut ptrstride: GLint;
    ptrstride = (call.arg(4)).to_i32().unwrap();

    if (1) {
    }
    unsafe { gl::SecondaryColorPointerListIBM(size, _type, stride, pointer, ptrstride) };
}

pub fn retrace_glEdgeFlagPointerListIBM(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stride: GLint;
    stride = (call.arg(0)).to_i32().unwrap();

    let pointer: &mut [GLboolean];
    memset(&pointer, 0, sizeof pointer); // FIXME

    let mut ptrstride: GLint;
    ptrstride = (call.arg(2)).to_i32().unwrap();

    if (1) {
    }
    unsafe { gl::EdgeFlagPointerListIBM(stride, pointer, ptrstride) };
}

pub fn retrace_glFogCoordPointerListIBM(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLint;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    let mut ptrstride: GLint;
    ptrstride = (call.arg(3)).to_i32().unwrap();

    if (1) {
    }
    unsafe { gl::FogCoordPointerListIBM(_type, stride, pointer, ptrstride) };
}

pub fn retrace_glIndexPointerListIBM(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLint;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    let mut ptrstride: GLint;
    ptrstride = (call.arg(3)).to_i32().unwrap();

    if (1) {
    }
    unsafe { gl::IndexPointerListIBM(_type, stride, pointer, ptrstride) };
}

pub fn retrace_glNormalPointerListIBM(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLint;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    let mut ptrstride: GLint;
    ptrstride = (call.arg(3)).to_i32().unwrap();

    if (1) {
    }
    unsafe { gl::NormalPointerListIBM(_type, stride, pointer, ptrstride) };
}

pub fn retrace_glTexCoordPointerListIBM(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLint;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    let mut ptrstride: GLint;
    ptrstride = (call.arg(4)).to_i32().unwrap();

    if (1) {
    }
    unsafe { gl::TexCoordPointerListIBM(size, _type, stride, pointer, ptrstride) };
}

pub fn retrace_glVertexPointerListIBM(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLint;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    let mut ptrstride: GLint;
    ptrstride = (call.arg(4)).to_i32().unwrap();

    if (1) {
    }
    unsafe { gl::VertexPointerListIBM(size, _type, stride, pointer, ptrstride) };
}

pub fn retrace_glRenderbufferStorageMultisampleIMG(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(1)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::RenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height) };
}

pub fn retrace_glFramebufferTexture2DMultisampleIMG(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(5)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    unsafe { gl::FramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples) };
}

pub fn retrace_glBlendFuncSeparateINGR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sfactorRGB: GLenum;
    sfactorRGB = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dfactorRGB: GLenum;
    dfactorRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut sfactorAlpha: GLenum;
    sfactorAlpha = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut dfactorAlpha: GLenum;
    dfactorAlpha = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha) };
}

pub fn retrace_glSyncTextureINTEL(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    unsafe { gl::SyncTextureINTEL(texture) };
}

pub fn retrace_glUnmapTexture2DINTEL(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::UnmapTexture2DINTEL(texture, level) };
}

pub fn retrace_glMapTexture2DINTEL(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut access: GLbitfield;
    access = (call.arg(2)).to_u32().unwrap();

    let stride: &mut [GLint];
    stride = _allocator.alloc_array::<GLint>(&call.arg(3));

    let layout: &mut [GLenum];
    layout = _allocator.alloc_array::<GLenum>(&call.arg(4));

    let _result = unsafe { gl::MapTexture2DINTEL(texture, level, access, stride, layout) };

    let _aPGLint23 = (call.arg(3)).to_array();
    if (_aPGLint23) {
    }
    let _aPGLenum8 = (call.arg(4)).to_array();
    if (_aPGLenum8) {
    }
}

pub fn retrace_glVertexPointervINTEL(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::VertexPointervINTEL(size, _type, pointer) };
}

pub fn retrace_glNormalPointervINTEL(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::NormalPointervINTEL(_type, pointer) };
}

pub fn retrace_glColorPointervINTEL(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::ColorPointervINTEL(size, _type, pointer) };
}

pub fn retrace_glTexCoordPointervINTEL(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::TexCoordPointervINTEL(size, _type, pointer) };
}

pub fn retrace_glBlendBarrierKHR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::BlendBarrierKHR() };
}

pub fn retrace_glDebugMessageControl(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut source: GLenum;
    source = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut severity: GLenum;
    severity = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(4));
    let _a_GLuint237_0 = (call.arg(4)).to_array();
    if let Some(_a_GLuint237_0) = _a_GLuint237_0 {
        for _jGLuint237 in 0.._a_GLuint237_0.values.len() {
    ids[_jGLuint237] = (*_a_GLuint237_0.values[_jGLuint237]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut enabled: GLboolean;
    enabled = (call.arg(5)).to_u32().unwrap() as u8;

    unsafe { gl::DebugMessageControl(source, _type, severity, count, ids, enabled) };
}

pub fn retrace_glDebugMessageInsert(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut source: GLenum;
    source = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(2)).to_u32().unwrap();

    let mut severity: GLenum;
    severity = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut length: GLsizei;
    length = (call.arg(4)).to_i32().unwrap();

    let buf: &mut [GLchar];
    buf = (GLchar *)((call.arg(5)).to_string().unwrap());

    unsafe { gl::DebugMessageInsert(source, _type, id, severity, length, buf) };
}

pub fn retrace_glPushDebugGroup(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut source: GLenum;
    source = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();

    let mut length: GLsizei;
    length = (call.arg(2)).to_i32().unwrap();

    let message: &mut [GLchar];
    message = (GLchar *)((call.arg(3)).to_string().unwrap());

    unsafe { gl::PushDebugGroup(source, id, length, message) };
}

pub fn retrace_glPopDebugGroup(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PopDebugGroup() };
}

pub fn retrace_glObjectLabel(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut identifier: GLenum;
    identifier = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut name: GLuint;
    name = (call.arg(1)).to_u32().unwrap();

    let mut length: GLsizei;
    length = (call.arg(2)).to_i32().unwrap();

    let label: &mut [GLchar];
    label = (GLchar *)((call.arg(3)).to_string().unwrap());

    unsafe { gl::ObjectLabel(identifier, name, length, label) };
}

pub fn retrace_glObjectPtrLabel(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let ptr: &mut [void];
    memset(&ptr, 0, sizeof ptr); // FIXME

    let mut length: GLsizei;
    length = (call.arg(1)).to_i32().unwrap();

    let label: &mut [GLchar];
    label = (GLchar *)((call.arg(2)).to_string().unwrap());

    if (1) {
    }
    unsafe { gl::ObjectPtrLabel(ptr, length, label) };
}

pub fn retrace_glDebugMessageControlKHR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut source: GLenum;
    source = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut severity: GLenum;
    severity = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(4));
    let _a_GLuint238_0 = (call.arg(4)).to_array();
    if let Some(_a_GLuint238_0) = _a_GLuint238_0 {
        for _jGLuint238 in 0.._a_GLuint238_0.values.len() {
    ids[_jGLuint238] = (*_a_GLuint238_0.values[_jGLuint238]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut enabled: GLboolean;
    enabled = (call.arg(5)).to_u32().unwrap() as u8;

    unsafe { gl::DebugMessageControlKHR(source, _type, severity, count, ids, enabled) };
}

pub fn retrace_glDebugMessageInsertKHR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut source: GLenum;
    source = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(2)).to_u32().unwrap();

    let mut severity: GLenum;
    severity = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut length: GLsizei;
    length = (call.arg(4)).to_i32().unwrap();

    let buf: &mut [GLchar];
    buf = (GLchar *)((call.arg(5)).to_string().unwrap());

    unsafe { gl::DebugMessageInsertKHR(source, _type, id, severity, length, buf) };
}

pub fn retrace_glPushDebugGroupKHR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut source: GLenum;
    source = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();

    let mut length: GLsizei;
    length = (call.arg(2)).to_i32().unwrap();

    let message: &mut [GLchar];
    message = (GLchar *)((call.arg(3)).to_string().unwrap());

    unsafe { gl::PushDebugGroupKHR(source, id, length, message) };
}

pub fn retrace_glPopDebugGroupKHR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PopDebugGroupKHR() };
}

pub fn retrace_glObjectLabelKHR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut identifier: GLenum;
    identifier = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut name: GLuint;
    name = (call.arg(1)).to_u32().unwrap();

    let mut length: GLsizei;
    length = (call.arg(2)).to_i32().unwrap();

    let label: &mut [GLchar];
    label = (GLchar *)((call.arg(3)).to_string().unwrap());

    unsafe { gl::ObjectLabelKHR(identifier, name, length, label) };
}

pub fn retrace_glObjectPtrLabelKHR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let ptr: &mut [void];
    memset(&ptr, 0, sizeof ptr); // FIXME

    let mut length: GLsizei;
    length = (call.arg(1)).to_i32().unwrap();

    let label: &mut [GLchar];
    label = (GLchar *)((call.arg(2)).to_string().unwrap());

    if (1) {
    }
    unsafe { gl::ObjectPtrLabelKHR(ptr, length, label) };
}

pub fn retrace_glReadnPixels(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(6)).to_i32().unwrap();

    let data: &mut [GLvoid];
    data = (call.arg(7)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
     buffer.resize(call.arg(6).to_i32().unwrap());
    }
    data = buffer.data();
    unsafe { gl::ReadnPixels(x, y, width, height, format, _type, bufSize, data) };
}

pub fn retrace_glReadnPixelsKHR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(6)).to_i32().unwrap();

    let data: &mut [GLvoid];
    data = (call.arg(7)).to_pointer();

    let _pack_buffer = 0;
    if currentContext.features().pixel_buffer_object == true {
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    }
     let buffer = Vec::<u8>::new();
    if _pack_buffer != 0 {
    return;
    }
    unsafe { gl::ReadnPixelsKHR(x, y, width, height, format, _type, bufSize, data) };
}

pub fn retrace_glNewBufferRegion(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::NewBufferRegion(_type) };

    let _origResult: GLuint;
    _origResult = (*call.ret).to_u32().unwrap();
    _region_map[_origResult] = _result;
}

pub fn retrace_glDeleteBufferRegion(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut region: GLuint;
    region = (call.arg(0)).to_u32().unwrap();
    region = _region_map[region];

    unsafe { gl::DeleteBufferRegion(region) };
}

pub fn retrace_glReadBufferRegion(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut region: GLuint;
    region = (call.arg(0)).to_u32().unwrap();
    region = _region_map[region];

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::ReadBufferRegion(region, x, y, width, height) };
}

pub fn retrace_glDrawBufferRegion(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut region: GLuint;
    region = (call.arg(0)).to_u32().unwrap();
    region = _region_map[region];

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut xDest: GLint;
    xDest = (call.arg(5)).to_i32().unwrap();

    let mut yDest: GLint;
    yDest = (call.arg(6)).to_i32().unwrap();

    unsafe { gl::DrawBufferRegion(region, x, y, width, height, xDest, yDest) };
}

pub fn retrace_glResizeBuffersMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::ResizeBuffersMESA() };
}

pub fn retrace_glWindowPos2dMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::WindowPos2dMESA(x, y) };
}

pub fn retrace_glWindowPos2dvMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble130_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble130_0) = _a_GLdouble130_0 {
        for _jGLdouble130 in 0.._a_GLdouble130_0.values.len() {
    v[_jGLdouble130] = (*_a_GLdouble130_0.values[_jGLdouble130]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2dvMESA(v) };
}

pub fn retrace_glWindowPos2fMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::WindowPos2fMESA(x, y) };
}

pub fn retrace_glWindowPos2fvMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat230_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat230_0) = _a_GLfloat230_0 {
        for _jGLfloat230 in 0.._a_GLfloat230_0.values.len() {
    v[_jGLfloat230] = (*_a_GLfloat230_0.values[_jGLfloat230]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2fvMESA(v) };
}

pub fn retrace_glWindowPos2iMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::WindowPos2iMESA(x, y) };
}

pub fn retrace_glWindowPos2ivMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint247_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint247_0) = _a_GLint247_0 {
        for _jGLint247 in 0.._a_GLint247_0.values.len() {
    v[_jGLint247] = (*_a_GLint247_0.values[_jGLint247]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2ivMESA(v) };
}

pub fn retrace_glWindowPos2sMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::WindowPos2sMESA(x, y) };
}

pub fn retrace_glWindowPos2svMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort43_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort43_0) = _a_GLshort43_0 {
        for _jGLshort43 in 0.._a_GLshort43_0.values.len() {
    v[_jGLshort43] = (*_a_GLshort43_0.values[_jGLshort43]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos2svMESA(v) };
}

pub fn retrace_glWindowPos3dMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::WindowPos3dMESA(x, y, z) };
}

pub fn retrace_glWindowPos3dvMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble131_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble131_0) = _a_GLdouble131_0 {
        for _jGLdouble131 in 0.._a_GLdouble131_0.values.len() {
    v[_jGLdouble131] = (*_a_GLdouble131_0.values[_jGLdouble131]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3dvMESA(v) };
}

pub fn retrace_glWindowPos3fMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::WindowPos3fMESA(x, y, z) };
}

pub fn retrace_glWindowPos3fvMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat231_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat231_0) = _a_GLfloat231_0 {
        for _jGLfloat231 in 0.._a_GLfloat231_0.values.len() {
    v[_jGLfloat231] = (*_a_GLfloat231_0.values[_jGLfloat231]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3fvMESA(v) };
}

pub fn retrace_glWindowPos3iMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::WindowPos3iMESA(x, y, z) };
}

pub fn retrace_glWindowPos3ivMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint248_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint248_0) = _a_GLint248_0 {
        for _jGLint248 in 0.._a_GLint248_0.values.len() {
    v[_jGLint248] = (*_a_GLint248_0.values[_jGLint248]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3ivMESA(v) };
}

pub fn retrace_glWindowPos3sMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::WindowPos3sMESA(x, y, z) };
}

pub fn retrace_glWindowPos3svMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort44_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort44_0) = _a_GLshort44_0 {
        for _jGLshort44 in 0.._a_GLshort44_0.values.len() {
    v[_jGLshort44] = (*_a_GLshort44_0.values[_jGLshort44]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos3svMESA(v) };
}

pub fn retrace_glWindowPos4dMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLdouble;
    x = (call.arg(0)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(1)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(2)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::WindowPos4dMESA(x, y, z, w) };
}

pub fn retrace_glWindowPos4dvMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble132_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble132_0) = _a_GLdouble132_0 {
        for _jGLdouble132 in 0.._a_GLdouble132_0.values.len() {
    v[_jGLdouble132] = (*_a_GLdouble132_0.values[_jGLdouble132]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos4dvMESA(v) };
}

pub fn retrace_glWindowPos4fMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::WindowPos4fMESA(x, y, z, w) };
}

pub fn retrace_glWindowPos4fvMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat232_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat232_0) = _a_GLfloat232_0 {
        for _jGLfloat232 in 0.._a_GLfloat232_0.values.len() {
    v[_jGLfloat232] = (*_a_GLfloat232_0.values[_jGLfloat232]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos4fvMESA(v) };
}

pub fn retrace_glWindowPos4iMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(2)).to_i32().unwrap();

    let mut w: GLint;
    w = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::WindowPos4iMESA(x, y, z, w) };
}

pub fn retrace_glWindowPos4ivMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint249_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint249_0) = _a_GLint249_0 {
        for _jGLint249 in 0.._a_GLint249_0.values.len() {
    v[_jGLint249] = (*_a_GLint249_0.values[_jGLint249]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos4ivMESA(v) };
}

pub fn retrace_glWindowPos4sMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(2)).to_i32().unwrap();

    let mut w: GLshort;
    w = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::WindowPos4sMESA(x, y, z, w) };
}

pub fn retrace_glWindowPos4svMESA(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort45_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort45_0) = _a_GLshort45_0 {
        for _jGLshort45 in 0.._a_GLshort45_0.values.len() {
    v[_jGLshort45] = (*_a_GLshort45_0.values[_jGLshort45]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WindowPos4svMESA(v) };
}

pub fn retrace_glBeginConditionalRenderNVX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    unsafe { gl::BeginConditionalRenderNVX(id) };
}

pub fn retrace_glEndConditionalRenderNVX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::EndConditionalRenderNVX() };
}

pub fn retrace_glMultiDrawArraysIndirectBindlessNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    indirect = static_cast<GLvoid *>(retrace::toPointer(call.arg(1)));

    let mut drawCount: GLsizei;
    drawCount = (call.arg(2)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let mut vertexBufferCount: GLint;
    vertexBufferCount = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::MultiDrawArraysIndirectBindlessNV(mode, indirect, drawCount, stride, vertexBufferCount) };
}

pub fn retrace_glMultiDrawElementsIndirectBindlessNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let indirect: &mut [GLvoid];
    indirect = static_cast<GLvoid *>(retrace::toPointer(call.arg(2)));

    let mut drawCount: GLsizei;
    drawCount = (call.arg(3)).to_i32().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    let mut vertexBufferCount: GLint;
    vertexBufferCount = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::MultiDrawElementsIndirectBindlessNV(mode, _type, indirect, drawCount, stride, vertexBufferCount) };
}

pub fn retrace_glGetTextureHandleNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let _result = unsafe { gl::GetTextureHandleNV(texture) };

    let _origResult: GLuint64;
    _origResult = (*call.ret).to_u32().unwrap();
    _textureHandle_map[_origResult] = _result;
}

pub fn retrace_glGetTextureSamplerHandleNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut sampler: GLuint;
    sampler = (call.arg(1)).to_u32().unwrap();
    sampler = _sampler_map[sampler];

    let _result = unsafe { gl::GetTextureSamplerHandleNV(texture, sampler) };

    let _origResult: GLuint64;
    _origResult = (*call.ret).to_u32().unwrap();
    _textureHandle_map[_origResult] = _result;
}

pub fn retrace_glMakeTextureHandleResidentNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut handle: GLuint64;
    handle = (call.arg(0)).to_u32().unwrap();
    handle = _textureHandle_map[handle];

    unsafe { gl::MakeTextureHandleResidentNV(handle) };
}

pub fn retrace_glMakeTextureHandleNonResidentNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut handle: GLuint64;
    handle = (call.arg(0)).to_u32().unwrap();
    handle = _textureHandle_map[handle];

    unsafe { gl::MakeTextureHandleNonResidentNV(handle) };
}

pub fn retrace_glGetImageHandleNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut layered: GLboolean;
    layered = (call.arg(2)).to_u32().unwrap() as u8;

    let mut layer: GLint;
    layer = (call.arg(3)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::GetImageHandleNV(texture, level, layered, layer, format) };

    let _origResult: GLuint64;
    _origResult = (*call.ret).to_u32().unwrap();
    _imageHandle_map[_origResult] = _result;
}

pub fn retrace_glMakeImageHandleResidentNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut handle: GLuint64;
    handle = (call.arg(0)).to_u32().unwrap();
    handle = _imageHandle_map[handle];

    let mut access: GLenum;
    access = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::MakeImageHandleResidentNV(handle, access) };
}

pub fn retrace_glMakeImageHandleNonResidentNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut handle: GLuint64;
    handle = (call.arg(0)).to_u32().unwrap();
    handle = _imageHandle_map[handle];

    unsafe { gl::MakeImageHandleNonResidentNV(handle) };
}

pub fn retrace_glUniformHandleui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut value: GLuint64;
    value = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::UniformHandleui64NV(location, value) };
}

pub fn retrace_glUniformHandleui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64];
    value = _allocator.alloc_array::<GLuint64>(&call.arg(2));
    let _a_GLuint6423_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint6423_0) = _a_GLuint6423_0 {
        for _jGLuint6423 in 0.._a_GLuint6423_0.values.len() {
    value[_jGLuint6423] = (*_a_GLuint6423_0.values[_jGLuint6423]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::UniformHandleui64vNV(location, count, value) };
}

pub fn retrace_glProgramUniformHandleui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut value: GLuint64;
    value = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::ProgramUniformHandleui64NV(program, location, value) };
}

pub fn retrace_glProgramUniformHandleui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let values: &mut [GLuint64];
    values = _allocator.alloc_array::<GLuint64>(&call.arg(3));
    let _a_GLuint6424_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint6424_0) = _a_GLuint6424_0 {
        for _jGLuint6424 in 0.._a_GLuint6424_0.values.len() {
    values[_jGLuint6424] = (*_a_GLuint6424_0.values[_jGLuint6424]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformHandleui64vNV(program, location, count, values) };
}

pub fn retrace_glBlendParameteriNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLint;
    value = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::BlendParameteriNV(pname, value) };
}

pub fn retrace_glBlendBarrierNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::BlendBarrierNV() };
}

pub fn retrace_glBeginConditionalRenderNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BeginConditionalRenderNV(id, mode) };
}

pub fn retrace_glEndConditionalRenderNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::EndConditionalRenderNV() };
}

pub fn retrace_glCopyImageSubDataNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut srcName: GLuint;
    srcName = (call.arg(0)).to_u32().unwrap();
    srcName = _texture_map[srcName];

    let mut srcTarget: GLenum;
    srcTarget = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut srcLevel: GLint;
    srcLevel = (call.arg(2)).to_i32().unwrap();

    let mut srcX: GLint;
    srcX = (call.arg(3)).to_i32().unwrap();

    let mut srcY: GLint;
    srcY = (call.arg(4)).to_i32().unwrap();

    let mut srcZ: GLint;
    srcZ = (call.arg(5)).to_i32().unwrap();

    let mut dstName: GLuint;
    dstName = (call.arg(6)).to_u32().unwrap();
    dstName = _texture_map[dstName];

    let mut dstTarget: GLenum;
    dstTarget = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut dstLevel: GLint;
    dstLevel = (call.arg(8)).to_i32().unwrap();

    let mut dstX: GLint;
    dstX = (call.arg(9)).to_i32().unwrap();

    let mut dstY: GLint;
    dstY = (call.arg(10)).to_i32().unwrap();

    let mut dstZ: GLint;
    dstZ = (call.arg(11)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(12)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(13)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(14)).to_i32().unwrap();

    if (srcTarget == GL_RENDERBUFFER || dstTarget == GL_RENDERBUFFER) {
        retrace::warning(call) << " renderbuffer targets unsupported (https://git.io/JOMRC)\n";
    }
    unsafe { gl::CopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth) };
}

pub fn retrace_glCoverageMaskNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLboolean;
    mask = (call.arg(0)).to_u32().unwrap() as u8;

    unsafe { gl::CoverageMaskNV(mask) };
}

pub fn retrace_glCoverageOperationNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut operation: GLenum;
    operation = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::CoverageOperationNV(operation) };
}

pub fn retrace_glDepthRangedNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut zNear: GLdouble;
    zNear = (call.arg(0)).to_f64().unwrap();

    let mut zFar: GLdouble;
    zFar = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::DepthRangedNV(zNear, zFar) };
}

pub fn retrace_glClearDepthdNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut depth: GLdouble;
    depth = (call.arg(0)).to_f64().unwrap();

    unsafe { gl::ClearDepthdNV(depth) };
}

pub fn retrace_glDepthBoundsdNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut zmin: GLdouble;
    zmin = (call.arg(0)).to_f64().unwrap();

    let mut zmax: GLdouble;
    zmax = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::DepthBoundsdNV(zmin, zmax) };
}

pub fn retrace_glDrawBuffersNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let bufs: &mut [GLenum];
    bufs = _allocator.alloc_array::<GLenum>(&call.arg(1));
    let _a_GLenum29_0 = (call.arg(1)).to_array();
    if let Some(_a_GLenum29_0) = _a_GLenum29_0 {
        for _jGLenum29 in 0.._a_GLenum29_0.values.len() {
    bufs[_jGLenum29] = (*_a_GLenum29_0.values[_jGLenum29]).to_u32().unwrap().try_into().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DrawBuffersNV(n, bufs) };
}

pub fn retrace_glDrawTextureNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut sampler: GLuint;
    sampler = (call.arg(1)).to_u32().unwrap();
    sampler = _sampler_map[sampler];

    let mut x0: GLfloat;
    x0 = (call.arg(2)).to_f32().unwrap();

    let mut y0: GLfloat;
    y0 = (call.arg(3)).to_f32().unwrap();

    let mut x1: GLfloat;
    x1 = (call.arg(4)).to_f32().unwrap();

    let mut y1: GLfloat;
    y1 = (call.arg(5)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(6)).to_f32().unwrap();

    let mut s0: GLfloat;
    s0 = (call.arg(7)).to_f32().unwrap();

    let mut t0: GLfloat;
    t0 = (call.arg(8)).to_f32().unwrap();

    let mut s1: GLfloat;
    s1 = (call.arg(9)).to_f32().unwrap();

    let mut t1: GLfloat;
    t1 = (call.arg(10)).to_f32().unwrap();

    unsafe { gl::DrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1) };
}

pub fn retrace_glMapControlPointsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut ustride: GLsizei;
    ustride = (call.arg(3)).to_i32().unwrap();

    let mut vstride: GLsizei;
    vstride = (call.arg(4)).to_i32().unwrap();

    let mut uorder: GLint;
    uorder = (call.arg(5)).to_i32().unwrap();

    let mut vorder: GLint;
    vorder = (call.arg(6)).to_i32().unwrap();

    let mut packed: GLboolean;
    packed = (call.arg(7)).to_u32().unwrap() as u8;

    let points: &mut [GLvoid];
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    }
    unsafe { gl::MapControlPointsNV(target, index, _type, ustride, vstride, uorder, vorder, packed, points) };
}

pub fn retrace_glMapParameterivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    memset(&params, 0, sizeof params); // FIXME

    if (1) {
    }
    unsafe { gl::MapParameterivNV(target, pname, params) };
}

pub fn retrace_glMapParameterfvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    memset(&params, 0, sizeof params); // FIXME

    if (1) {
    }
    unsafe { gl::MapParameterfvNV(target, pname, params) };
}

pub fn retrace_glEvalMapsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::EvalMapsNV(target, mode) };
}

pub fn retrace_glSampleMaskIndexedNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut mask: GLbitfield;
    mask = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::SampleMaskIndexedNV(index, mask) };
}

pub fn retrace_glTexRenderbufferNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(1)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    unsafe { gl::TexRenderbufferNV(target, renderbuffer) };
}

pub fn retrace_glDeleteFencesNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let fences: &mut [GLuint];
    fences = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint239_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint239_0) = _a_GLuint239_0 {
        for _jGLuint239 in 0.._a_GLuint239_0.values.len() {
    fences[_jGLuint239] = (*_a_GLuint239_0.values[_jGLuint239]).to_u32().unwrap();
    fences[_jGLuint239] = _fence_map[fences[_jGLuint239]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteFencesNV(n, fences) };
}

pub fn retrace_glGenFencesNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let fences: &mut [GLuint];
    fences = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenFencesNV(n, fences) };
    let _aGLuint241 = (call.arg(1)).to_array();
    if (_aGLuint241) {
        for _jGLuint241 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint241.values[_jGLuint241]).to_u32().unwrap();
    _fence_map[_origResult] = fences[_jGLuint241];
        }
    }
}

pub fn retrace_glTestFenceNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut fence: GLuint;
    fence = (call.arg(0)).to_u32().unwrap();
    fence = _fence_map[fence];

    let _result = unsafe { gl::TestFenceNV(fence) };

}

pub fn retrace_glFinishFenceNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut fence: GLuint;
    fence = (call.arg(0)).to_u32().unwrap();
    fence = _fence_map[fence];

    unsafe { gl::FinishFenceNV(fence) };
}

pub fn retrace_glSetFenceNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut fence: GLuint;
    fence = (call.arg(0)).to_u32().unwrap();
    fence = _fence_map[fence];

    let mut condition: GLenum;
    condition = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::SetFenceNV(fence, condition) };
}

pub fn retrace_glProgramNamedParameter4fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _programARB_map[id];

    let mut len: GLsizei;
    len = (call.arg(1)).to_i32().unwrap();

    let name: &mut [GLubyte];
    name = (GLubyte *)((call.arg(2)).to_string().unwrap());

    let mut x: GLfloat;
    x = (call.arg(3)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(4)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(5)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(6)).to_f32().unwrap();

    unsafe { gl::ProgramNamedParameter4fNV(id, len, name, x, y, z, w) };
}

pub fn retrace_glProgramNamedParameter4dNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _programARB_map[id];

    let mut len: GLsizei;
    len = (call.arg(1)).to_i32().unwrap();

    let name: &mut [GLubyte];
    name = (GLubyte *)((call.arg(2)).to_string().unwrap());

    let mut x: GLdouble;
    x = (call.arg(3)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(4)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(5)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(6)).to_f64().unwrap();

    unsafe { gl::ProgramNamedParameter4dNV(id, len, name, x, y, z, w) };
}

pub fn retrace_glProgramNamedParameter4fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _programARB_map[id];

    let mut len: GLsizei;
    len = (call.arg(1)).to_i32().unwrap();

    let name: &mut [GLubyte];
    name = (GLubyte *)((call.arg(2)).to_string().unwrap());

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat233_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat233_0) = _a_GLfloat233_0 {
        for _jGLfloat233 in 0.._a_GLfloat233_0.values.len() {
    v[_jGLfloat233] = (*_a_GLfloat233_0.values[_jGLfloat233]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramNamedParameter4fvNV(id, len, name, v) };
}

pub fn retrace_glProgramNamedParameter4dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _programARB_map[id];

    let mut len: GLsizei;
    len = (call.arg(1)).to_i32().unwrap();

    let name: &mut [GLubyte];
    name = (GLubyte *)((call.arg(2)).to_string().unwrap());

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble133_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble133_0) = _a_GLdouble133_0 {
        for _jGLdouble133 in 0.._a_GLdouble133_0.values.len() {
    v[_jGLdouble133] = (*_a_GLdouble133_0.values[_jGLdouble133]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramNamedParameter4dvNV(id, len, name, v) };
}

pub fn retrace_glBlitFramebufferNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut srcX0: GLint;
    srcX0 = (call.arg(0)).to_i32().unwrap();

    let mut srcY0: GLint;
    srcY0 = (call.arg(1)).to_i32().unwrap();

    let mut srcX1: GLint;
    srcX1 = (call.arg(2)).to_i32().unwrap();

    let mut srcY1: GLint;
    srcY1 = (call.arg(3)).to_i32().unwrap();

    let mut dstX0: GLint;
    dstX0 = (call.arg(4)).to_i32().unwrap();

    let mut dstY0: GLint;
    dstY0 = (call.arg(5)).to_i32().unwrap();

    let mut dstX1: GLint;
    dstX1 = (call.arg(6)).to_i32().unwrap();

    let mut dstY1: GLint;
    dstY1 = (call.arg(7)).to_i32().unwrap();

    let mut mask: GLbitfield;
    mask = (call.arg(8)).to_u32().unwrap();

    let mut filter: GLenum;
    filter = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter) };
}

pub fn retrace_glCoverageModulationTableNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat234_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat234_0) = _a_GLfloat234_0 {
        for _jGLfloat234 in 0.._a_GLfloat234_0.values.len() {
    v[_jGLfloat234] = (*_a_GLfloat234_0.values[_jGLfloat234]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::CoverageModulationTableNV(n, v) };
}

pub fn retrace_glCoverageModulationNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut components: GLenum;
    components = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::CoverageModulationNV(components) };
}

pub fn retrace_glRenderbufferStorageMultisampleCoverageNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coverageSamples: GLsizei;
    coverageSamples = (call.arg(1)).to_i32().unwrap();

    let mut colorSamples: GLsizei;
    colorSamples = (call.arg(2)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::RenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height) };
}

pub fn retrace_glProgramVertexLimitNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut limit: GLint;
    limit = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::ProgramVertexLimitNV(target, limit) };
}

pub fn retrace_glFramebufferTextureFaceEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    let mut face: GLenum;
    face = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::FramebufferTextureFaceEXT(target, attachment, texture, level, face) };
}

pub fn retrace_glProgramLocalParameterI4iNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(3)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(4)).to_i32().unwrap();

    let mut w: GLint;
    w = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::ProgramLocalParameterI4iNV(target, index, x, y, z, w) };
}

pub fn retrace_glProgramLocalParameterI4ivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint250_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint250_0) = _a_GLint250_0 {
        for _jGLint250 in 0.._a_GLint250_0.values.len() {
    params[_jGLint250] = (*_a_GLint250_0.values[_jGLint250]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramLocalParameterI4ivNV(target, index, params) };
}

pub fn retrace_glProgramLocalParametersI4ivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint251_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint251_0) = _a_GLint251_0 {
        for _jGLint251 in 0.._a_GLint251_0.values.len() {
    params[_jGLint251] = (*_a_GLint251_0.values[_jGLint251]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramLocalParametersI4ivNV(target, index, count, params) };
}

pub fn retrace_glProgramLocalParameterI4uiNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(2)).to_u32().unwrap();

    let mut y: GLuint;
    y = (call.arg(3)).to_u32().unwrap();

    let mut z: GLuint;
    z = (call.arg(4)).to_u32().unwrap();

    let mut w: GLuint;
    w = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::ProgramLocalParameterI4uiNV(target, index, x, y, z, w) };
}

pub fn retrace_glProgramLocalParameterI4uivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint242_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint242_0) = _a_GLuint242_0 {
        for _jGLuint242 in 0.._a_GLuint242_0.values.len() {
    params[_jGLuint242] = (*_a_GLuint242_0.values[_jGLuint242]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramLocalParameterI4uivNV(target, index, params) };
}

pub fn retrace_glProgramLocalParametersI4uivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint243_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint243_0) = _a_GLuint243_0 {
        for _jGLuint243 in 0.._a_GLuint243_0.values.len() {
    params[_jGLuint243] = (*_a_GLuint243_0.values[_jGLuint243]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramLocalParametersI4uivNV(target, index, count, params) };
}

pub fn retrace_glProgramEnvParameterI4iNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(3)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(4)).to_i32().unwrap();

    let mut w: GLint;
    w = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::ProgramEnvParameterI4iNV(target, index, x, y, z, w) };
}

pub fn retrace_glProgramEnvParameterI4ivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint252_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint252_0) = _a_GLint252_0 {
        for _jGLint252 in 0.._a_GLint252_0.values.len() {
    params[_jGLint252] = (*_a_GLint252_0.values[_jGLint252]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramEnvParameterI4ivNV(target, index, params) };
}

pub fn retrace_glProgramEnvParametersI4ivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint253_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint253_0) = _a_GLint253_0 {
        for _jGLint253 in 0.._a_GLint253_0.values.len() {
    params[_jGLint253] = (*_a_GLint253_0.values[_jGLint253]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramEnvParametersI4ivNV(target, index, count, params) };
}

pub fn retrace_glProgramEnvParameterI4uiNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(2)).to_u32().unwrap();

    let mut y: GLuint;
    y = (call.arg(3)).to_u32().unwrap();

    let mut z: GLuint;
    z = (call.arg(4)).to_u32().unwrap();

    let mut w: GLuint;
    w = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::ProgramEnvParameterI4uiNV(target, index, x, y, z, w) };
}

pub fn retrace_glProgramEnvParameterI4uivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint244_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint244_0) = _a_GLuint244_0 {
        for _jGLuint244 in 0.._a_GLuint244_0.values.len() {
    params[_jGLuint244] = (*_a_GLuint244_0.values[_jGLuint244]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramEnvParameterI4uivNV(target, index, params) };
}

pub fn retrace_glProgramEnvParametersI4uivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint245_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint245_0) = _a_GLuint245_0 {
        for _jGLuint245 in 0.._a_GLuint245_0.values.len() {
    params[_jGLuint245] = (*_a_GLuint245_0.values[_jGLuint245]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramEnvParametersI4uivNV(target, index, count, params) };
}

pub fn retrace_glProgramSubroutineParametersuivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint246_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint246_0) = _a_GLuint246_0 {
        for _jGLuint246 in 0.._a_GLuint246_0.values.len() {
    params[_jGLuint246] = (*_a_GLuint246_0.values[_jGLuint246]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramSubroutineParametersuivNV(target, count, params) };
}

pub fn retrace_glUniform1i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64EXT;
    x = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::Uniform1i64NV(location, x) };
}

pub fn retrace_glUniform2i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64EXT;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint64EXT;
    y = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::Uniform2i64NV(location, x, y) };
}

pub fn retrace_glUniform3i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64EXT;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint64EXT;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint64EXT;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::Uniform3i64NV(location, x, y, z) };
}

pub fn retrace_glUniform4i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64EXT;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint64EXT;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint64EXT;
    z = (call.arg(3)).to_i32().unwrap();

    let mut w: GLint64EXT;
    w = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::Uniform4i64NV(location, x, y, z, w) };
}

pub fn retrace_glUniform1i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint64EXT];
    value = _allocator.alloc_array::<GLint64EXT>(&call.arg(2));
    let _a_GLint64EXT4_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint64EXT4_0) = _a_GLint64EXT4_0 {
        for _jGLint64EXT4 in 0.._a_GLint64EXT4_0.values.len() {
    value[_jGLint64EXT4] = (*_a_GLint64EXT4_0.values[_jGLint64EXT4]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1i64vNV(location, count, value) };
}

pub fn retrace_glUniform2i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint64EXT];
    value = _allocator.alloc_array::<GLint64EXT>(&call.arg(2));
    let _a_GLint64EXT5_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint64EXT5_0) = _a_GLint64EXT5_0 {
        for _jGLint64EXT5 in 0.._a_GLint64EXT5_0.values.len() {
    value[_jGLint64EXT5] = (*_a_GLint64EXT5_0.values[_jGLint64EXT5]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2i64vNV(location, count, value) };
}

pub fn retrace_glUniform3i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint64EXT];
    value = _allocator.alloc_array::<GLint64EXT>(&call.arg(2));
    let _a_GLint64EXT6_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint64EXT6_0) = _a_GLint64EXT6_0 {
        for _jGLint64EXT6 in 0.._a_GLint64EXT6_0.values.len() {
    value[_jGLint64EXT6] = (*_a_GLint64EXT6_0.values[_jGLint64EXT6]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3i64vNV(location, count, value) };
}

pub fn retrace_glUniform4i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLint64EXT];
    value = _allocator.alloc_array::<GLint64EXT>(&call.arg(2));
    let _a_GLint64EXT7_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint64EXT7_0) = _a_GLint64EXT7_0 {
        for _jGLint64EXT7 in 0.._a_GLint64EXT7_0.values.len() {
    value[_jGLint64EXT7] = (*_a_GLint64EXT7_0.values[_jGLint64EXT7]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4i64vNV(location, count, value) };
}

pub fn retrace_glUniform1ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64EXT;
    x = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::Uniform1ui64NV(location, x) };
}

pub fn retrace_glUniform2ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64EXT;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint64EXT;
    y = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::Uniform2ui64NV(location, x, y) };
}

pub fn retrace_glUniform3ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64EXT;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint64EXT;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLuint64EXT;
    z = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::Uniform3ui64NV(location, x, y, z) };
}

pub fn retrace_glUniform4ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64EXT;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint64EXT;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLuint64EXT;
    z = (call.arg(3)).to_u32().unwrap();

    let mut w: GLuint64EXT;
    w = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::Uniform4ui64NV(location, x, y, z, w) };
}

pub fn retrace_glUniform1ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64EXT];
    value = _allocator.alloc_array::<GLuint64EXT>(&call.arg(2));
    let _a_GLuint64EXT8_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint64EXT8_0) = _a_GLuint64EXT8_0 {
        for _jGLuint64EXT8 in 0.._a_GLuint64EXT8_0.values.len() {
    value[_jGLuint64EXT8] = (*_a_GLuint64EXT8_0.values[_jGLuint64EXT8]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform1ui64vNV(location, count, value) };
}

pub fn retrace_glUniform2ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64EXT];
    value = _allocator.alloc_array::<GLuint64EXT>(&call.arg(2));
    let _a_GLuint64EXT9_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint64EXT9_0) = _a_GLuint64EXT9_0 {
        for _jGLuint64EXT9 in 0.._a_GLuint64EXT9_0.values.len() {
    value[_jGLuint64EXT9] = (*_a_GLuint64EXT9_0.values[_jGLuint64EXT9]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform2ui64vNV(location, count, value) };
}

pub fn retrace_glUniform3ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64EXT];
    value = _allocator.alloc_array::<GLuint64EXT>(&call.arg(2));
    let _a_GLuint64EXT10_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint64EXT10_0) = _a_GLuint64EXT10_0 {
        for _jGLuint64EXT10 in 0.._a_GLuint64EXT10_0.values.len() {
    value[_jGLuint64EXT10] = (*_a_GLuint64EXT10_0.values[_jGLuint64EXT10]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform3ui64vNV(location, count, value) };
}

pub fn retrace_glUniform4ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64EXT];
    value = _allocator.alloc_array::<GLuint64EXT>(&call.arg(2));
    let _a_GLuint64EXT11_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint64EXT11_0) = _a_GLuint64EXT11_0 {
        for _jGLuint64EXT11 in 0.._a_GLuint64EXT11_0.values.len() {
    value[_jGLuint64EXT11] = (*_a_GLuint64EXT11_0.values[_jGLuint64EXT11]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniform4ui64vNV(location, count, value) };
}

pub fn retrace_glProgramUniform1i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64EXT;
    x = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ProgramUniform1i64NV(program, location, x) };
}

pub fn retrace_glProgramUniform2i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64EXT;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint64EXT;
    y = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::ProgramUniform2i64NV(program, location, x, y) };
}

pub fn retrace_glProgramUniform3i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64EXT;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint64EXT;
    y = (call.arg(3)).to_i32().unwrap();

    let mut z: GLint64EXT;
    z = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::ProgramUniform3i64NV(program, location, x, y, z) };
}

pub fn retrace_glProgramUniform4i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLint64EXT;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint64EXT;
    y = (call.arg(3)).to_i32().unwrap();

    let mut z: GLint64EXT;
    z = (call.arg(4)).to_i32().unwrap();

    let mut w: GLint64EXT;
    w = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::ProgramUniform4i64NV(program, location, x, y, z, w) };
}

pub fn retrace_glProgramUniform1i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint64EXT];
    value = _allocator.alloc_array::<GLint64EXT>(&call.arg(3));
    let _a_GLint64EXT8_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint64EXT8_0) = _a_GLint64EXT8_0 {
        for _jGLint64EXT8 in 0.._a_GLint64EXT8_0.values.len() {
    value[_jGLint64EXT8] = (*_a_GLint64EXT8_0.values[_jGLint64EXT8]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1i64vNV(program, location, count, value) };
}

pub fn retrace_glProgramUniform2i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint64EXT];
    value = _allocator.alloc_array::<GLint64EXT>(&call.arg(3));
    let _a_GLint64EXT9_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint64EXT9_0) = _a_GLint64EXT9_0 {
        for _jGLint64EXT9 in 0.._a_GLint64EXT9_0.values.len() {
    value[_jGLint64EXT9] = (*_a_GLint64EXT9_0.values[_jGLint64EXT9]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2i64vNV(program, location, count, value) };
}

pub fn retrace_glProgramUniform3i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint64EXT];
    value = _allocator.alloc_array::<GLint64EXT>(&call.arg(3));
    let _a_GLint64EXT10_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint64EXT10_0) = _a_GLint64EXT10_0 {
        for _jGLint64EXT10 in 0.._a_GLint64EXT10_0.values.len() {
    value[_jGLint64EXT10] = (*_a_GLint64EXT10_0.values[_jGLint64EXT10]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3i64vNV(program, location, count, value) };
}

pub fn retrace_glProgramUniform4i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLint64EXT];
    value = _allocator.alloc_array::<GLint64EXT>(&call.arg(3));
    let _a_GLint64EXT11_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint64EXT11_0) = _a_GLint64EXT11_0 {
        for _jGLint64EXT11 in 0.._a_GLint64EXT11_0.values.len() {
    value[_jGLint64EXT11] = (*_a_GLint64EXT11_0.values[_jGLint64EXT11]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4i64vNV(program, location, count, value) };
}

pub fn retrace_glProgramUniform1ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64EXT;
    x = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::ProgramUniform1ui64NV(program, location, x) };
}

pub fn retrace_glProgramUniform2ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64EXT;
    x = (call.arg(2)).to_u32().unwrap();

    let mut y: GLuint64EXT;
    y = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::ProgramUniform2ui64NV(program, location, x, y) };
}

pub fn retrace_glProgramUniform3ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64EXT;
    x = (call.arg(2)).to_u32().unwrap();

    let mut y: GLuint64EXT;
    y = (call.arg(3)).to_u32().unwrap();

    let mut z: GLuint64EXT;
    z = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::ProgramUniform3ui64NV(program, location, x, y, z) };
}

pub fn retrace_glProgramUniform4ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut x: GLuint64EXT;
    x = (call.arg(2)).to_u32().unwrap();

    let mut y: GLuint64EXT;
    y = (call.arg(3)).to_u32().unwrap();

    let mut z: GLuint64EXT;
    z = (call.arg(4)).to_u32().unwrap();

    let mut w: GLuint64EXT;
    w = (call.arg(5)).to_u32().unwrap();

    unsafe { gl::ProgramUniform4ui64NV(program, location, x, y, z, w) };
}

pub fn retrace_glProgramUniform1ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint64EXT];
    value = _allocator.alloc_array::<GLuint64EXT>(&call.arg(3));
    let _a_GLuint64EXT12_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint64EXT12_0) = _a_GLuint64EXT12_0 {
        for _jGLuint64EXT12 in 0.._a_GLuint64EXT12_0.values.len() {
    value[_jGLuint64EXT12] = (*_a_GLuint64EXT12_0.values[_jGLuint64EXT12]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform1ui64vNV(program, location, count, value) };
}

pub fn retrace_glProgramUniform2ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint64EXT];
    value = _allocator.alloc_array::<GLuint64EXT>(&call.arg(3));
    let _a_GLuint64EXT13_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint64EXT13_0) = _a_GLuint64EXT13_0 {
        for _jGLuint64EXT13 in 0.._a_GLuint64EXT13_0.values.len() {
    value[_jGLuint64EXT13] = (*_a_GLuint64EXT13_0.values[_jGLuint64EXT13]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform2ui64vNV(program, location, count, value) };
}

pub fn retrace_glProgramUniform3ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint64EXT];
    value = _allocator.alloc_array::<GLuint64EXT>(&call.arg(3));
    let _a_GLuint64EXT14_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint64EXT14_0) = _a_GLuint64EXT14_0 {
        for _jGLuint64EXT14 in 0.._a_GLuint64EXT14_0.values.len() {
    value[_jGLuint64EXT14] = (*_a_GLuint64EXT14_0.values[_jGLuint64EXT14]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform3ui64vNV(program, location, count, value) };
}

pub fn retrace_glProgramUniform4ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint64EXT];
    value = _allocator.alloc_array::<GLuint64EXT>(&call.arg(3));
    let _a_GLuint64EXT15_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint64EXT15_0) = _a_GLuint64EXT15_0 {
        for _jGLuint64EXT15 in 0.._a_GLuint64EXT15_0.values.len() {
    value[_jGLuint64EXT15] = (*_a_GLuint64EXT15_0.values[_jGLuint64EXT15]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniform4ui64vNV(program, location, count, value) };
}

pub fn retrace_glVertex2hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLhalfNV;
    x = (call.arg(0)).to_u32().unwrap();

    let mut y: GLhalfNV;
    y = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::Vertex2hNV(x, y) };
}

pub fn retrace_glVertex2hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_GLhalfNV1_0 = (call.arg(0)).to_array();
    if let Some(_a_GLhalfNV1_0) = _a_GLhalfNV1_0 {
        for _jGLhalfNV1 in 0.._a_GLhalfNV1_0.values.len() {
    v[_jGLhalfNV1] = (*_a_GLhalfNV1_0.values[_jGLhalfNV1]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex2hvNV(v) };
}

pub fn retrace_glVertex3hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLhalfNV;
    x = (call.arg(0)).to_u32().unwrap();

    let mut y: GLhalfNV;
    y = (call.arg(1)).to_u32().unwrap();

    let mut z: GLhalfNV;
    z = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::Vertex3hNV(x, y, z) };
}

pub fn retrace_glVertex3hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_GLhalfNV2_0 = (call.arg(0)).to_array();
    if let Some(_a_GLhalfNV2_0) = _a_GLhalfNV2_0 {
        for _jGLhalfNV2 in 0.._a_GLhalfNV2_0.values.len() {
    v[_jGLhalfNV2] = (*_a_GLhalfNV2_0.values[_jGLhalfNV2]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex3hvNV(v) };
}

pub fn retrace_glVertex4hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLhalfNV;
    x = (call.arg(0)).to_u32().unwrap();

    let mut y: GLhalfNV;
    y = (call.arg(1)).to_u32().unwrap();

    let mut z: GLhalfNV;
    z = (call.arg(2)).to_u32().unwrap();

    let mut w: GLhalfNV;
    w = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::Vertex4hNV(x, y, z, w) };
}

pub fn retrace_glVertex4hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_GLhalfNV3_0 = (call.arg(0)).to_array();
    if let Some(_a_GLhalfNV3_0) = _a_GLhalfNV3_0 {
        for _jGLhalfNV3 in 0.._a_GLhalfNV3_0.values.len() {
    v[_jGLhalfNV3] = (*_a_GLhalfNV3_0.values[_jGLhalfNV3]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Vertex4hvNV(v) };
}

pub fn retrace_glNormal3hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut nx: GLhalfNV;
    nx = (call.arg(0)).to_u32().unwrap();

    let mut ny: GLhalfNV;
    ny = (call.arg(1)).to_u32().unwrap();

    let mut nz: GLhalfNV;
    nz = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::Normal3hNV(nx, ny, nz) };
}

pub fn retrace_glNormal3hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_GLhalfNV4_0 = (call.arg(0)).to_array();
    if let Some(_a_GLhalfNV4_0) = _a_GLhalfNV4_0 {
        for _jGLhalfNV4 in 0.._a_GLhalfNV4_0.values.len() {
    v[_jGLhalfNV4] = (*_a_GLhalfNV4_0.values[_jGLhalfNV4]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Normal3hvNV(v) };
}

pub fn retrace_glColor3hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLhalfNV;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLhalfNV;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLhalfNV;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::Color3hNV(red, green, blue) };
}

pub fn retrace_glColor3hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_GLhalfNV5_0 = (call.arg(0)).to_array();
    if let Some(_a_GLhalfNV5_0) = _a_GLhalfNV5_0 {
        for _jGLhalfNV5 in 0.._a_GLhalfNV5_0.values.len() {
    v[_jGLhalfNV5] = (*_a_GLhalfNV5_0.values[_jGLhalfNV5]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color3hvNV(v) };
}

pub fn retrace_glColor4hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLhalfNV;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLhalfNV;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLhalfNV;
    blue = (call.arg(2)).to_u32().unwrap();

    let mut alpha: GLhalfNV;
    alpha = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::Color4hNV(red, green, blue, alpha) };
}

pub fn retrace_glColor4hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_GLhalfNV6_0 = (call.arg(0)).to_array();
    if let Some(_a_GLhalfNV6_0) = _a_GLhalfNV6_0 {
        for _jGLhalfNV6 in 0.._a_GLhalfNV6_0.values.len() {
    v[_jGLhalfNV6] = (*_a_GLhalfNV6_0.values[_jGLhalfNV6]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4hvNV(v) };
}

pub fn retrace_glTexCoord1hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLhalfNV;
    s = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::TexCoord1hNV(s) };
}

pub fn retrace_glTexCoord1hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_PGLhalfNV_0 = (call.arg(0)).to_array().unwrap();
    v[0] = (_a_PGLhalfNV_0.values[0]).to_u32().unwrap();

    unsafe { gl::TexCoord1hvNV(v) };
}

pub fn retrace_glTexCoord2hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLhalfNV;
    s = (call.arg(0)).to_u32().unwrap();

    let mut t: GLhalfNV;
    t = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::TexCoord2hNV(s, t) };
}

pub fn retrace_glTexCoord2hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_GLhalfNV7_0 = (call.arg(0)).to_array();
    if let Some(_a_GLhalfNV7_0) = _a_GLhalfNV7_0 {
        for _jGLhalfNV7 in 0.._a_GLhalfNV7_0.values.len() {
    v[_jGLhalfNV7] = (*_a_GLhalfNV7_0.values[_jGLhalfNV7]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord2hvNV(v) };
}

pub fn retrace_glTexCoord3hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLhalfNV;
    s = (call.arg(0)).to_u32().unwrap();

    let mut t: GLhalfNV;
    t = (call.arg(1)).to_u32().unwrap();

    let mut r: GLhalfNV;
    r = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::TexCoord3hNV(s, t, r) };
}

pub fn retrace_glTexCoord3hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_GLhalfNV8_0 = (call.arg(0)).to_array();
    if let Some(_a_GLhalfNV8_0) = _a_GLhalfNV8_0 {
        for _jGLhalfNV8 in 0.._a_GLhalfNV8_0.values.len() {
    v[_jGLhalfNV8] = (*_a_GLhalfNV8_0.values[_jGLhalfNV8]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord3hvNV(v) };
}

pub fn retrace_glTexCoord4hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLhalfNV;
    s = (call.arg(0)).to_u32().unwrap();

    let mut t: GLhalfNV;
    t = (call.arg(1)).to_u32().unwrap();

    let mut r: GLhalfNV;
    r = (call.arg(2)).to_u32().unwrap();

    let mut q: GLhalfNV;
    q = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::TexCoord4hNV(s, t, r, q) };
}

pub fn retrace_glTexCoord4hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_GLhalfNV9_0 = (call.arg(0)).to_array();
    if let Some(_a_GLhalfNV9_0) = _a_GLhalfNV9_0 {
        for _jGLhalfNV9 in 0.._a_GLhalfNV9_0.values.len() {
    v[_jGLhalfNV9] = (*_a_GLhalfNV9_0.values[_jGLhalfNV9]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord4hvNV(v) };
}

pub fn retrace_glMultiTexCoord1hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLhalfNV;
    s = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::MultiTexCoord1hNV(target, s) };
}

pub fn retrace_glMultiTexCoord1hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(1));
    let _a_PGLhalfNV1_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLhalfNV1_0.values[0]).to_u32().unwrap();

    unsafe { gl::MultiTexCoord1hvNV(target, v) };
}

pub fn retrace_glMultiTexCoord2hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLhalfNV;
    s = (call.arg(1)).to_u32().unwrap();

    let mut t: GLhalfNV;
    t = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::MultiTexCoord2hNV(target, s, t) };
}

pub fn retrace_glMultiTexCoord2hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(1));
    let _a_GLhalfNV10_0 = (call.arg(1)).to_array();
    if let Some(_a_GLhalfNV10_0) = _a_GLhalfNV10_0 {
        for _jGLhalfNV10 in 0.._a_GLhalfNV10_0.values.len() {
    v[_jGLhalfNV10] = (*_a_GLhalfNV10_0.values[_jGLhalfNV10]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord2hvNV(target, v) };
}

pub fn retrace_glMultiTexCoord3hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLhalfNV;
    s = (call.arg(1)).to_u32().unwrap();

    let mut t: GLhalfNV;
    t = (call.arg(2)).to_u32().unwrap();

    let mut r: GLhalfNV;
    r = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::MultiTexCoord3hNV(target, s, t, r) };
}

pub fn retrace_glMultiTexCoord3hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(1));
    let _a_GLhalfNV11_0 = (call.arg(1)).to_array();
    if let Some(_a_GLhalfNV11_0) = _a_GLhalfNV11_0 {
        for _jGLhalfNV11 in 0.._a_GLhalfNV11_0.values.len() {
    v[_jGLhalfNV11] = (*_a_GLhalfNV11_0.values[_jGLhalfNV11]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord3hvNV(target, v) };
}

pub fn retrace_glMultiTexCoord4hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut s: GLhalfNV;
    s = (call.arg(1)).to_u32().unwrap();

    let mut t: GLhalfNV;
    t = (call.arg(2)).to_u32().unwrap();

    let mut r: GLhalfNV;
    r = (call.arg(3)).to_u32().unwrap();

    let mut q: GLhalfNV;
    q = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::MultiTexCoord4hNV(target, s, t, r, q) };
}

pub fn retrace_glMultiTexCoord4hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(1));
    let _a_GLhalfNV12_0 = (call.arg(1)).to_array();
    if let Some(_a_GLhalfNV12_0) = _a_GLhalfNV12_0 {
        for _jGLhalfNV12 in 0.._a_GLhalfNV12_0.values.len() {
    v[_jGLhalfNV12] = (*_a_GLhalfNV12_0.values[_jGLhalfNV12]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MultiTexCoord4hvNV(target, v) };
}

pub fn retrace_glFogCoordhNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut fog: GLhalfNV;
    fog = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::FogCoordhNV(fog) };
}

pub fn retrace_glFogCoordhvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let fog: &mut [GLhalfNV];
    fog = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_PGLhalfNV2_0 = (call.arg(0)).to_array().unwrap();
    fog[0] = (_a_PGLhalfNV2_0.values[0]).to_u32().unwrap();

    unsafe { gl::FogCoordhvNV(fog) };
}

pub fn retrace_glSecondaryColor3hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLhalfNV;
    red = (call.arg(0)).to_u32().unwrap();

    let mut green: GLhalfNV;
    green = (call.arg(1)).to_u32().unwrap();

    let mut blue: GLhalfNV;
    blue = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::SecondaryColor3hNV(red, green, blue) };
}

pub fn retrace_glSecondaryColor3hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_GLhalfNV13_0 = (call.arg(0)).to_array();
    if let Some(_a_GLhalfNV13_0) = _a_GLhalfNV13_0 {
        for _jGLhalfNV13 in 0.._a_GLhalfNV13_0.values.len() {
    v[_jGLhalfNV13] = (*_a_GLhalfNV13_0.values[_jGLhalfNV13]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SecondaryColor3hvNV(v) };
}

pub fn retrace_glVertexWeighthNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut weight: GLhalfNV;
    weight = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::VertexWeighthNV(weight) };
}

pub fn retrace_glVertexWeighthvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let weight: &mut [GLhalfNV];
    weight = _allocator.alloc_array::<GLhalfNV>(&call.arg(0));
    let _a_PGLhalfNV3_0 = (call.arg(0)).to_array().unwrap();
    weight[0] = (_a_PGLhalfNV3_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexWeighthvNV(weight) };
}

pub fn retrace_glVertexAttrib1hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLhalfNV;
    x = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexAttrib1hNV(index, x) };
}

pub fn retrace_glVertexAttrib1hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(1));
    let _a_PGLhalfNV4_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLhalfNV4_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexAttrib1hvNV(index, v) };
}

pub fn retrace_glVertexAttrib2hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLhalfNV;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLhalfNV;
    y = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::VertexAttrib2hNV(index, x, y) };
}

pub fn retrace_glVertexAttrib2hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(1));
    let _a_GLhalfNV14_0 = (call.arg(1)).to_array();
    if let Some(_a_GLhalfNV14_0) = _a_GLhalfNV14_0 {
        for _jGLhalfNV14 in 0.._a_GLhalfNV14_0.values.len() {
    v[_jGLhalfNV14] = (*_a_GLhalfNV14_0.values[_jGLhalfNV14]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib2hvNV(index, v) };
}

pub fn retrace_glVertexAttrib3hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLhalfNV;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLhalfNV;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLhalfNV;
    z = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::VertexAttrib3hNV(index, x, y, z) };
}

pub fn retrace_glVertexAttrib3hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(1));
    let _a_GLhalfNV15_0 = (call.arg(1)).to_array();
    if let Some(_a_GLhalfNV15_0) = _a_GLhalfNV15_0 {
        for _jGLhalfNV15 in 0.._a_GLhalfNV15_0.values.len() {
    v[_jGLhalfNV15] = (*_a_GLhalfNV15_0.values[_jGLhalfNV15]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib3hvNV(index, v) };
}

pub fn retrace_glVertexAttrib4hNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLhalfNV;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLhalfNV;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLhalfNV;
    z = (call.arg(3)).to_u32().unwrap();

    let mut w: GLhalfNV;
    w = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexAttrib4hNV(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(1));
    let _a_GLhalfNV16_0 = (call.arg(1)).to_array();
    if let Some(_a_GLhalfNV16_0) = _a_GLhalfNV16_0 {
        for _jGLhalfNV16 in 0.._a_GLhalfNV16_0.values.len() {
    v[_jGLhalfNV16] = (*_a_GLhalfNV16_0.values[_jGLhalfNV16]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4hvNV(index, v) };
}

pub fn retrace_glVertexAttribs1hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(2));
    let _a_GLhalfNV17_0 = (call.arg(2)).to_array();
    if let Some(_a_GLhalfNV17_0) = _a_GLhalfNV17_0 {
        for _jGLhalfNV17 in 0.._a_GLhalfNV17_0.values.len() {
    v[_jGLhalfNV17] = (*_a_GLhalfNV17_0.values[_jGLhalfNV17]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs1hvNV(index, n, v) };
}

pub fn retrace_glVertexAttribs2hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(2));
    let _a_GLhalfNV18_0 = (call.arg(2)).to_array();
    if let Some(_a_GLhalfNV18_0) = _a_GLhalfNV18_0 {
        for _jGLhalfNV18 in 0.._a_GLhalfNV18_0.values.len() {
    v[_jGLhalfNV18] = (*_a_GLhalfNV18_0.values[_jGLhalfNV18]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs2hvNV(index, n, v) };
}

pub fn retrace_glVertexAttribs3hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(2));
    let _a_GLhalfNV19_0 = (call.arg(2)).to_array();
    if let Some(_a_GLhalfNV19_0) = _a_GLhalfNV19_0 {
        for _jGLhalfNV19 in 0.._a_GLhalfNV19_0.values.len() {
    v[_jGLhalfNV19] = (*_a_GLhalfNV19_0.values[_jGLhalfNV19]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs3hvNV(index, n, v) };
}

pub fn retrace_glVertexAttribs4hvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLhalfNV];
    v = _allocator.alloc_array::<GLhalfNV>(&call.arg(2));
    let _a_GLhalfNV20_0 = (call.arg(2)).to_array();
    if let Some(_a_GLhalfNV20_0) = _a_GLhalfNV20_0 {
        for _jGLhalfNV20 in 0.._a_GLhalfNV20_0.values.len() {
    v[_jGLhalfNV20] = (*_a_GLhalfNV20_0.values[_jGLhalfNV20]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs4hvNV(index, n, v) };
}

pub fn retrace_glGenOcclusionQueriesNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenOcclusionQueriesNV(n, ids) };
    let _aGLuint248 = (call.arg(1)).to_array();
    if (_aGLuint248) {
        for _jGLuint248 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint248.values[_jGLuint248]).to_u32().unwrap();
    _query_map[_origResult] = ids[_jGLuint248];
        }
    }
}

pub fn retrace_glDeleteOcclusionQueriesNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint249_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint249_0) = _a_GLuint249_0 {
        for _jGLuint249 in 0.._a_GLuint249_0.values.len() {
    ids[_jGLuint249] = (*_a_GLuint249_0.values[_jGLuint249]).to_u32().unwrap();
    ids[_jGLuint249] = _query_map[ids[_jGLuint249]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteOcclusionQueriesNV(n, ids) };
}

pub fn retrace_glBeginOcclusionQueryNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut id: GLuint;
    id = (call.arg(0)).to_u32().unwrap();
    id = _query_map[id];

    unsafe { gl::BeginOcclusionQueryNV(id) };
}

pub fn retrace_glEndOcclusionQueryNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::EndOcclusionQueryNV() };
}

pub fn retrace_glProgramBufferParametersfvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat235_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat235_0) = _a_GLfloat235_0 {
        for _jGLfloat235 in 0.._a_GLfloat235_0.values.len() {
    params[_jGLfloat235] = (*_a_GLfloat235_0.values[_jGLfloat235]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramBufferParametersfvNV(target, buffer, index, count, params) };
}

pub fn retrace_glProgramBufferParametersIivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(4));
    let _a_GLint254_0 = (call.arg(4)).to_array();
    if let Some(_a_GLint254_0) = _a_GLint254_0 {
        for _jGLint254 in 0.._a_GLint254_0.values.len() {
    params[_jGLint254] = (*_a_GLint254_0.values[_jGLint254]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramBufferParametersIivNV(target, buffer, index, count, params) };
}

pub fn retrace_glProgramBufferParametersIuivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(1)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut index: GLuint;
    index = (call.arg(2)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(3)).to_i32().unwrap();

    let params: &mut [GLuint];
    params = _allocator.alloc_array::<GLuint>(&call.arg(4));
    let _a_GLuint250_0 = (call.arg(4)).to_array();
    if let Some(_a_GLuint250_0) = _a_GLuint250_0 {
        for _jGLuint250 in 0.._a_GLuint250_0.values.len() {
    params[_jGLuint250] = (*_a_GLuint250_0.values[_jGLuint250]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramBufferParametersIuivNV(target, buffer, index, count, params) };
}

pub fn retrace_glGenPathsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut range: GLsizei;
    range = (call.arg(0)).to_i32().unwrap();

    let _result = unsafe { gl::GenPathsNV(range) };

}

pub fn retrace_glDeletePathsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut range: GLsizei;
    range = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::DeletePathsNV(path, range) };
}

pub fn retrace_glIsPathNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let _result = unsafe { gl::IsPathNV(path) };

}

pub fn retrace_glPathCommandsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut numCommands: GLsizei;
    numCommands = (call.arg(1)).to_i32().unwrap();

    let commands: &mut [GLubyte];
    commands = _allocator.alloc_array::<GLubyte>(&call.arg(2));
    let _a_GLubyte20_0 = (call.arg(2)).to_array();
    if let Some(_a_GLubyte20_0) = _a_GLubyte20_0 {
        for _jGLubyte20 in 0.._a_GLubyte20_0.values.len() {
    commands[_jGLubyte20] = (*_a_GLubyte20_0.values[_jGLubyte20]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut numCoords: GLsizei;
    numCoords = (call.arg(3)).to_i32().unwrap();

    let mut coordType: GLenum;
    coordType = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLvoid];
    let coords = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::PathCommandsNV(path, numCommands, commands, numCoords, coordType, coords) };
}

pub fn retrace_glPathCoordsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut numCoords: GLsizei;
    numCoords = (call.arg(1)).to_i32().unwrap();

    let mut coordType: GLenum;
    coordType = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLvoid];
    let coords = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::PathCoordsNV(path, numCoords, coordType, coords) };
}

pub fn retrace_glPathSubCommandsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut commandStart: GLsizei;
    commandStart = (call.arg(1)).to_i32().unwrap();

    let mut commandsToDelete: GLsizei;
    commandsToDelete = (call.arg(2)).to_i32().unwrap();

    let mut numCommands: GLsizei;
    numCommands = (call.arg(3)).to_i32().unwrap();

    let commands: &mut [GLubyte];
    commands = _allocator.alloc_array::<GLubyte>(&call.arg(4));
    let _a_GLubyte21_0 = (call.arg(4)).to_array();
    if let Some(_a_GLubyte21_0) = _a_GLubyte21_0 {
        for _jGLubyte21 in 0.._a_GLubyte21_0.values.len() {
    commands[_jGLubyte21] = (*_a_GLubyte21_0.values[_jGLubyte21]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut numCoords: GLsizei;
    numCoords = (call.arg(5)).to_i32().unwrap();

    let mut coordType: GLenum;
    coordType = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLvoid];
    let coords = (call.arg(7)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords) };
}

pub fn retrace_glPathSubCoordsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut coordStart: GLsizei;
    coordStart = (call.arg(1)).to_i32().unwrap();

    let mut numCoords: GLsizei;
    numCoords = (call.arg(2)).to_i32().unwrap();

    let mut coordType: GLenum;
    coordType = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let coords: &mut [GLvoid];
    let coords = (call.arg(4)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::PathSubCoordsNV(path, coordStart, numCoords, coordType, coords) };
}

pub fn retrace_glPathStringNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut format: GLenum;
    format = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut length: GLsizei;
    length = (call.arg(2)).to_i32().unwrap();

    let pathString: &mut [GLvoid];
    let pathString = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::PathStringNV(path, format, length, pathString) };
}

pub fn retrace_glPathGlyphsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut firstPathName: GLuint;
    firstPathName = (call.arg(0)).to_u32().unwrap();

    let mut fontTarget: GLenum;
    fontTarget = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let fontName: &mut [GLvoid];
    let fontName = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut fontStyle: GLbitfield;
    fontStyle = (call.arg(3)).to_u32().unwrap();

    let mut numGlyphs: GLsizei;
    numGlyphs = (call.arg(4)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let charcodes: &mut [GLvoid];
    let charcodes = (call.arg(6)).to_pointer().unwrap() as *mut c_void;

    let mut handleMissingGlyphs: GLenum;
    handleMissingGlyphs = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut pathParameterTemplate: GLuint;
    pathParameterTemplate = (call.arg(8)).to_u32().unwrap();

    let mut emScale: GLfloat;
    emScale = (call.arg(9)).to_f32().unwrap();

    unsafe { gl::PathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, _type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale) };
}

pub fn retrace_glPathGlyphRangeNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut firstPathName: GLuint;
    firstPathName = (call.arg(0)).to_u32().unwrap();

    let mut fontTarget: GLenum;
    fontTarget = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let fontName: &mut [GLvoid];
    let fontName = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut fontStyle: GLbitfield;
    fontStyle = (call.arg(3)).to_u32().unwrap();

    let mut firstGlyph: GLuint;
    firstGlyph = (call.arg(4)).to_u32().unwrap();

    let mut numGlyphs: GLsizei;
    numGlyphs = (call.arg(5)).to_i32().unwrap();

    let mut handleMissingGlyphs: GLenum;
    handleMissingGlyphs = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut pathParameterTemplate: GLuint;
    pathParameterTemplate = (call.arg(7)).to_u32().unwrap();

    let mut emScale: GLfloat;
    emScale = (call.arg(8)).to_f32().unwrap();

    unsafe { gl::PathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale) };
}

pub fn retrace_glWeightPathsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut resultPath: GLuint;
    resultPath = (call.arg(0)).to_u32().unwrap();

    let mut numPaths: GLsizei;
    numPaths = (call.arg(1)).to_i32().unwrap();

    let paths: &mut [GLuint];
    paths = _allocator.alloc_array::<GLuint>(&call.arg(2));
    let _a_GLuint251_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint251_0) = _a_GLuint251_0 {
        for _jGLuint251 in 0.._a_GLuint251_0.values.len() {
    paths[_jGLuint251] = (*_a_GLuint251_0.values[_jGLuint251]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let weights: &mut [GLfloat];
    weights = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat236_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat236_0) = _a_GLfloat236_0 {
        for _jGLfloat236 in 0.._a_GLfloat236_0.values.len() {
    weights[_jGLfloat236] = (*_a_GLfloat236_0.values[_jGLfloat236]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::WeightPathsNV(resultPath, numPaths, paths, weights) };
}

pub fn retrace_glCopyPathNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut resultPath: GLuint;
    resultPath = (call.arg(0)).to_u32().unwrap();

    let mut srcPath: GLuint;
    srcPath = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::CopyPathNV(resultPath, srcPath) };
}

pub fn retrace_glInterpolatePathsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut resultPath: GLuint;
    resultPath = (call.arg(0)).to_u32().unwrap();

    let mut pathA: GLuint;
    pathA = (call.arg(1)).to_u32().unwrap();

    let mut pathB: GLuint;
    pathB = (call.arg(2)).to_u32().unwrap();

    let mut weight: GLfloat;
    weight = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::InterpolatePathsNV(resultPath, pathA, pathB, weight) };
}

pub fn retrace_glTransformPathNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut resultPath: GLuint;
    resultPath = (call.arg(0)).to_u32().unwrap();

    let mut srcPath: GLuint;
    srcPath = (call.arg(1)).to_u32().unwrap();

    let mut transformType: GLenum;
    transformType = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let transformValues: &mut [GLfloat];
    transformValues = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat237_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat237_0) = _a_GLfloat237_0 {
        for _jGLfloat237 in 0.._a_GLfloat237_0.values.len() {
    transformValues[_jGLfloat237] = (*_a_GLfloat237_0.values[_jGLfloat237]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TransformPathNV(resultPath, srcPath, transformType, transformValues) };
}

pub fn retrace_glPathParameterivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let value: &mut [GLint];
    value = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint255_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint255_0) = _a_GLint255_0 {
        for _jGLint255 in 0.._a_GLint255_0.values.len() {
    value[_jGLint255] = (*_a_GLint255_0.values[_jGLint255]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PathParameterivNV(path, pname, value) };
}

pub fn retrace_glPathParameteriNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLint;
    value = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::PathParameteriNV(path, pname, value) };
}

pub fn retrace_glPathParameterfvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let value: &mut [GLfloat];
    value = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat238_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat238_0) = _a_GLfloat238_0 {
        for _jGLfloat238 in 0.._a_GLfloat238_0.values.len() {
    value[_jGLfloat238] = (*_a_GLfloat238_0.values[_jGLfloat238]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PathParameterfvNV(path, pname, value) };
}

pub fn retrace_glPathParameterfNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut value: GLfloat;
    value = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::PathParameterfNV(path, pname, value) };
}

pub fn retrace_glPathDashArrayNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut dashCount: GLsizei;
    dashCount = (call.arg(1)).to_i32().unwrap();

    let dashArray: &mut [GLfloat];
    dashArray = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat239_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat239_0) = _a_GLfloat239_0 {
        for _jGLfloat239 in 0.._a_GLfloat239_0.values.len() {
    dashArray[_jGLfloat239] = (*_a_GLfloat239_0.values[_jGLfloat239]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PathDashArrayNV(path, dashCount, dashArray) };
}

pub fn retrace_glPathStencilFuncNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut func: GLenum;
    func = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut _ref: GLint;
    _ref = (call.arg(1)).to_i32().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::PathStencilFuncNV(func, _ref, mask) };
}

pub fn retrace_glPathStencilDepthOffsetNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLfloat;
    factor = (call.arg(0)).to_f32().unwrap();

    let mut units: GLfloat;
    units = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PathStencilDepthOffsetNV(factor, units) };
}

pub fn retrace_glStencilFillPathNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut fillMode: GLenum;
    fillMode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::StencilFillPathNV(path, fillMode, mask) };
}

pub fn retrace_glStencilStrokePathNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut reference: GLint;
    reference = (call.arg(1)).to_i32().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::StencilStrokePathNV(path, reference, mask) };
}

pub fn retrace_glStencilFillPathInstancedNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut numPaths: GLsizei;
    numPaths = (call.arg(0)).to_i32().unwrap();

    let mut pathNameType: GLenum;
    pathNameType = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let paths: &mut [GLvoid];
    let paths = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut pathBase: GLuint;
    pathBase = (call.arg(3)).to_u32().unwrap();

    let mut fillMode: GLenum;
    fillMode = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(5)).to_u32().unwrap();

    let mut transformType: GLenum;
    transformType = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let transformValues: &mut [GLfloat];
    transformValues = _allocator.alloc_array::<GLfloat>(&call.arg(7));
    let _a_GLfloat240_0 = (call.arg(7)).to_array();
    if let Some(_a_GLfloat240_0) = _a_GLfloat240_0 {
        for _jGLfloat240 in 0.._a_GLfloat240_0.values.len() {
    transformValues[_jGLfloat240] = (*_a_GLfloat240_0.values[_jGLfloat240]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::StencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues) };
}

pub fn retrace_glStencilStrokePathInstancedNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut numPaths: GLsizei;
    numPaths = (call.arg(0)).to_i32().unwrap();

    let mut pathNameType: GLenum;
    pathNameType = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let paths: &mut [GLvoid];
    let paths = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut pathBase: GLuint;
    pathBase = (call.arg(3)).to_u32().unwrap();

    let mut reference: GLint;
    reference = (call.arg(4)).to_i32().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(5)).to_u32().unwrap();

    let mut transformType: GLenum;
    transformType = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let transformValues: &mut [GLfloat];
    transformValues = _allocator.alloc_array::<GLfloat>(&call.arg(7));
    let _a_GLfloat241_0 = (call.arg(7)).to_array();
    if let Some(_a_GLfloat241_0) = _a_GLfloat241_0 {
        for _jGLfloat241 in 0.._a_GLfloat241_0.values.len() {
    transformValues[_jGLfloat241] = (*_a_GLfloat241_0.values[_jGLfloat241]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::StencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues) };
}

pub fn retrace_glPathCoverDepthFuncNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut func: GLenum;
    func = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::PathCoverDepthFuncNV(func) };
}

pub fn retrace_glPathColorGenNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut color: GLenum;
    color = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut genMode: GLenum;
    genMode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut colorFormat: GLenum;
    colorFormat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let coeffs: &mut [GLfloat];
    coeffs = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat242_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat242_0) = _a_GLfloat242_0 {
        for _jGLfloat242 in 0.._a_GLfloat242_0.values.len() {
    coeffs[_jGLfloat242] = (*_a_GLfloat242_0.values[_jGLfloat242]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PathColorGenNV(color, genMode, colorFormat, coeffs) };
}

pub fn retrace_glPathTexGenNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texCoordSet: GLenum;
    texCoordSet = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut genMode: GLenum;
    genMode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut components: GLint;
    components = (call.arg(2)).to_i32().unwrap();

    let coeffs: &mut [GLfloat];
    coeffs = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat243_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat243_0) = _a_GLfloat243_0 {
        for _jGLfloat243 in 0.._a_GLfloat243_0.values.len() {
    coeffs[_jGLfloat243] = (*_a_GLfloat243_0.values[_jGLfloat243]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PathTexGenNV(texCoordSet, genMode, components, coeffs) };
}

pub fn retrace_glPathFogGenNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut genMode: GLenum;
    genMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::PathFogGenNV(genMode) };
}

pub fn retrace_glCoverFillPathNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut coverMode: GLenum;
    coverMode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::CoverFillPathNV(path, coverMode) };
}

pub fn retrace_glCoverStrokePathNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut coverMode: GLenum;
    coverMode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::CoverStrokePathNV(path, coverMode) };
}

pub fn retrace_glCoverFillPathInstancedNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut numPaths: GLsizei;
    numPaths = (call.arg(0)).to_i32().unwrap();

    let mut pathNameType: GLenum;
    pathNameType = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let paths: &mut [GLvoid];
    let paths = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut pathBase: GLuint;
    pathBase = (call.arg(3)).to_u32().unwrap();

    let mut coverMode: GLenum;
    coverMode = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut transformType: GLenum;
    transformType = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let transformValues: &mut [GLfloat];
    transformValues = _allocator.alloc_array::<GLfloat>(&call.arg(6));
    let _a_GLfloat244_0 = (call.arg(6)).to_array();
    if let Some(_a_GLfloat244_0) = _a_GLfloat244_0 {
        for _jGLfloat244 in 0.._a_GLfloat244_0.values.len() {
    transformValues[_jGLfloat244] = (*_a_GLfloat244_0.values[_jGLfloat244]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::CoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues) };
}

pub fn retrace_glCoverStrokePathInstancedNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut numPaths: GLsizei;
    numPaths = (call.arg(0)).to_i32().unwrap();

    let mut pathNameType: GLenum;
    pathNameType = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let paths: &mut [GLvoid];
    let paths = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut pathBase: GLuint;
    pathBase = (call.arg(3)).to_u32().unwrap();

    let mut coverMode: GLenum;
    coverMode = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut transformType: GLenum;
    transformType = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let transformValues: &mut [GLfloat];
    transformValues = _allocator.alloc_array::<GLfloat>(&call.arg(6));
    let _a_GLfloat245_0 = (call.arg(6)).to_array();
    if let Some(_a_GLfloat245_0) = _a_GLfloat245_0 {
        for _jGLfloat245 in 0.._a_GLfloat245_0.values.len() {
    transformValues[_jGLfloat245] = (*_a_GLfloat245_0.values[_jGLfloat245]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::CoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues) };
}

pub fn retrace_glGetPathSpacingNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pathListMode: GLenum;
    pathListMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut numPaths: GLsizei;
    numPaths = (call.arg(1)).to_i32().unwrap();

    let mut pathNameType: GLenum;
    pathNameType = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let paths: &mut [GLvoid];
    let paths = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut pathBase: GLuint;
    pathBase = (call.arg(4)).to_u32().unwrap();

    let mut advanceScale: GLfloat;
    advanceScale = (call.arg(5)).to_f32().unwrap();

    let mut kerningScale: GLfloat;
    kerningScale = (call.arg(6)).to_f32().unwrap();

    let mut transformType: GLenum;
    transformType = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let returnedSpacing: &mut [GLfloat];
    returnedSpacing = _allocator.alloc_array::<GLfloat>(&call.arg(8));

    unsafe { gl::GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing) };
    let _aGLfloat247 = (call.arg(8)).to_array();
    if (_aGLfloat247) {
        for _jGLfloat247 in 0..length {
        }
    }
}

pub fn retrace_glGetPathLengthNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut startSegment: GLsizei;
    startSegment = (call.arg(1)).to_i32().unwrap();

    let mut numSegments: GLsizei;
    numSegments = (call.arg(2)).to_i32().unwrap();

    let _result = unsafe { gl::GetPathLengthNV(path, startSegment, numSegments) };

}

pub fn retrace_glMatrixLoad3x2fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut matrixMode: GLenum;
    matrixMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat248_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat248_0) = _a_GLfloat248_0 {
        for _jGLfloat248 in 0.._a_GLfloat248_0.values.len() {
    m[_jGLfloat248] = (*_a_GLfloat248_0.values[_jGLfloat248]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixLoad3x2fNV(matrixMode, m) };
}

pub fn retrace_glMatrixLoad3x3fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut matrixMode: GLenum;
    matrixMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat249_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat249_0) = _a_GLfloat249_0 {
        for _jGLfloat249 in 0.._a_GLfloat249_0.values.len() {
    m[_jGLfloat249] = (*_a_GLfloat249_0.values[_jGLfloat249]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixLoad3x3fNV(matrixMode, m) };
}

pub fn retrace_glMatrixLoadTranspose3x3fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut matrixMode: GLenum;
    matrixMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat250_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat250_0) = _a_GLfloat250_0 {
        for _jGLfloat250 in 0.._a_GLfloat250_0.values.len() {
    m[_jGLfloat250] = (*_a_GLfloat250_0.values[_jGLfloat250]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixLoadTranspose3x3fNV(matrixMode, m) };
}

pub fn retrace_glMatrixMult3x2fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut matrixMode: GLenum;
    matrixMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat251_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat251_0) = _a_GLfloat251_0 {
        for _jGLfloat251 in 0.._a_GLfloat251_0.values.len() {
    m[_jGLfloat251] = (*_a_GLfloat251_0.values[_jGLfloat251]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixMult3x2fNV(matrixMode, m) };
}

pub fn retrace_glMatrixMult3x3fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut matrixMode: GLenum;
    matrixMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat252_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat252_0) = _a_GLfloat252_0 {
        for _jGLfloat252 in 0.._a_GLfloat252_0.values.len() {
    m[_jGLfloat252] = (*_a_GLfloat252_0.values[_jGLfloat252]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixMult3x3fNV(matrixMode, m) };
}

pub fn retrace_glMatrixMultTranspose3x3fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut matrixMode: GLenum;
    matrixMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let m: &mut [GLfloat];
    m = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat253_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat253_0) = _a_GLfloat253_0 {
        for _jGLfloat253 in 0.._a_GLfloat253_0.values.len() {
    m[_jGLfloat253] = (*_a_GLfloat253_0.values[_jGLfloat253]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::MatrixMultTranspose3x3fNV(matrixMode, m) };
}

pub fn retrace_glStencilThenCoverFillPathNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut fillMode: GLenum;
    fillMode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(2)).to_u32().unwrap();

    let mut coverMode: GLenum;
    coverMode = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::StencilThenCoverFillPathNV(path, fillMode, mask, coverMode) };
}

pub fn retrace_glStencilThenCoverStrokePathNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut path: GLuint;
    path = (call.arg(0)).to_u32().unwrap();

    let mut reference: GLint;
    reference = (call.arg(1)).to_i32().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(2)).to_u32().unwrap();

    let mut coverMode: GLenum;
    coverMode = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::StencilThenCoverStrokePathNV(path, reference, mask, coverMode) };
}

pub fn retrace_glStencilThenCoverFillPathInstancedNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut numPaths: GLsizei;
    numPaths = (call.arg(0)).to_i32().unwrap();

    let mut pathNameType: GLenum;
    pathNameType = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let paths: &mut [GLvoid];
    let paths = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut pathBase: GLuint;
    pathBase = (call.arg(3)).to_u32().unwrap();

    let mut fillMode: GLenum;
    fillMode = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(5)).to_u32().unwrap();

    let mut coverMode: GLenum;
    coverMode = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut transformType: GLenum;
    transformType = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let transformValues: &mut [GLfloat];
    transformValues = _allocator.alloc_array::<GLfloat>(&call.arg(8));
    let _a_GLfloat254_0 = (call.arg(8)).to_array();
    if let Some(_a_GLfloat254_0) = _a_GLfloat254_0 {
        for _jGLfloat254 in 0.._a_GLfloat254_0.values.len() {
    transformValues[_jGLfloat254] = (*_a_GLfloat254_0.values[_jGLfloat254]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues) };
}

pub fn retrace_glStencilThenCoverStrokePathInstancedNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut numPaths: GLsizei;
    numPaths = (call.arg(0)).to_i32().unwrap();

    let mut pathNameType: GLenum;
    pathNameType = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let paths: &mut [GLvoid];
    let paths = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut pathBase: GLuint;
    pathBase = (call.arg(3)).to_u32().unwrap();

    let mut reference: GLint;
    reference = (call.arg(4)).to_i32().unwrap();

    let mut mask: GLuint;
    mask = (call.arg(5)).to_u32().unwrap();

    let mut coverMode: GLenum;
    coverMode = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut transformType: GLenum;
    transformType = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let transformValues: &mut [GLfloat];
    transformValues = _allocator.alloc_array::<GLfloat>(&call.arg(8));
    let _a_GLfloat255_0 = (call.arg(8)).to_array();
    if let Some(_a_GLfloat255_0) = _a_GLfloat255_0 {
        for _jGLfloat255 in 0.._a_GLfloat255_0.values.len() {
    transformValues[_jGLfloat255] = (*_a_GLfloat255_0.values[_jGLfloat255]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues) };
}

pub fn retrace_glPathGlyphIndexRangeNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut fontTarget: GLenum;
    fontTarget = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let fontName: &mut [GLvoid];
    fontName = (GLvoid *)((call.arg(1)).to_string().unwrap());

    let mut fontStyle: GLbitfield;
    fontStyle = (call.arg(2)).to_u32().unwrap();

    let mut pathParameterTemplate: GLuint;
    pathParameterTemplate = (call.arg(3)).to_u32().unwrap();

    let mut emScale: GLfloat;
    emScale = (call.arg(4)).to_f32().unwrap();

    let baseAndCount: &mut [GLuint];
    baseAndCount = _allocator.alloc_array::<GLuint>(&call.arg(5));
    let _a_GLuint252_0 = (call.arg(5)).to_array();
    if let Some(_a_GLuint252_0) = _a_GLuint252_0 {
        for _jGLuint252 in 0.._a_GLuint252_0.values.len() {
    baseAndCount[_jGLuint252] = (*_a_GLuint252_0.values[_jGLuint252]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let _result = unsafe { gl::PathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount) };

}

pub fn retrace_glPathGlyphIndexArrayNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut firstPathName: GLuint;
    firstPathName = (call.arg(0)).to_u32().unwrap();

    let mut fontTarget: GLenum;
    fontTarget = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let fontName: &mut [GLvoid];
    fontName = (GLvoid *)((call.arg(2)).to_string().unwrap());

    let mut fontStyle: GLbitfield;
    fontStyle = (call.arg(3)).to_u32().unwrap();

    let mut firstGlyphIndex: GLuint;
    firstGlyphIndex = (call.arg(4)).to_u32().unwrap();

    let mut numGlyphs: GLsizei;
    numGlyphs = (call.arg(5)).to_i32().unwrap();

    let mut pathParameterTemplate: GLuint;
    pathParameterTemplate = (call.arg(6)).to_u32().unwrap();

    let mut emScale: GLfloat;
    emScale = (call.arg(7)).to_f32().unwrap();

    let _result = unsafe { gl::PathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale) };

}

pub fn retrace_glPathMemoryGlyphIndexArrayNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut firstPathName: GLuint;
    firstPathName = (call.arg(0)).to_u32().unwrap();

    let mut fontTarget: GLenum;
    fontTarget = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut fontSize: GLsizeiptr;
    fontSize = (call.arg(2)).to_i32().unwrap();

    let fontData: &mut [void];
    let fontData = (call.arg(3)).to_pointer().unwrap() as *mut c_void;

    let mut faceIndex: GLsizei;
    faceIndex = (call.arg(4)).to_i32().unwrap();

    let mut firstGlyphIndex: GLuint;
    firstGlyphIndex = (call.arg(5)).to_u32().unwrap();

    let mut numGlyphs: GLsizei;
    numGlyphs = (call.arg(6)).to_i32().unwrap();

    let mut pathParameterTemplate: GLuint;
    pathParameterTemplate = (call.arg(7)).to_u32().unwrap();

    let mut emScale: GLfloat;
    emScale = (call.arg(8)).to_f32().unwrap();

    let _result = unsafe { gl::PathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale) };

}

pub fn retrace_glProgramPathFragmentInputGenNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut genMode: GLenum;
    genMode = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut components: GLint;
    components = (call.arg(3)).to_i32().unwrap();

    let coeffs: &mut [GLfloat];
    coeffs = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat256_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat256_0) = _a_GLfloat256_0 {
        for _jGLfloat256 in 0.._a_GLfloat256_0.values.len() {
    coeffs[_jGLfloat256] = (*_a_GLfloat256_0.values[_jGLfloat256]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs) };
}

pub fn retrace_glPixelDataRangeNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut length: GLsizei;
    length = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::PixelDataRangeNV(target, length, pointer) };
}

pub fn retrace_glFlushPixelDataRangeNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::FlushPixelDataRangeNV(target) };
}

pub fn retrace_glPointParameteriNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PointParameteriNV(pname, param) };
}

pub fn retrace_glPointParameterivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint256_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint256_0) = _a_GLint256_0 {
        for _jGLint256 in 0.._a_GLint256_0.values.len() {
    params[_jGLint256] = (*_a_GLint256_0.values[_jGLint256]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PointParameterivNV(pname, params) };
}

pub fn retrace_glPresentFrameKeyedNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut video_slot: GLuint;
    video_slot = (call.arg(0)).to_u32().unwrap();

    let mut minPresentTime: GLuint64EXT;
    minPresentTime = (call.arg(1)).to_u32().unwrap();

    let mut beginPresentTimeId: GLuint;
    beginPresentTimeId = (call.arg(2)).to_u32().unwrap();

    let mut presentDurationId: GLuint;
    presentDurationId = (call.arg(3)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut target0: GLenum;
    target0 = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut fill0: GLuint;
    fill0 = (call.arg(6)).to_u32().unwrap();

    let mut key0: GLuint;
    key0 = (call.arg(7)).to_u32().unwrap();

    let mut target1: GLenum;
    target1 = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut fill1: GLuint;
    fill1 = (call.arg(9)).to_u32().unwrap();

    let mut key1: GLuint;
    key1 = (call.arg(10)).to_u32().unwrap();

    unsafe { gl::PresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, _type, target0, fill0, key0, target1, fill1, key1) };
}

pub fn retrace_glPresentFrameDualFillNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut video_slot: GLuint;
    video_slot = (call.arg(0)).to_u32().unwrap();

    let mut minPresentTime: GLuint64EXT;
    minPresentTime = (call.arg(1)).to_u32().unwrap();

    let mut beginPresentTimeId: GLuint;
    beginPresentTimeId = (call.arg(2)).to_u32().unwrap();

    let mut presentDurationId: GLuint;
    presentDurationId = (call.arg(3)).to_u32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut target0: GLenum;
    target0 = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut fill0: GLuint;
    fill0 = (call.arg(6)).to_u32().unwrap();

    let mut target1: GLenum;
    target1 = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut fill1: GLuint;
    fill1 = (call.arg(8)).to_u32().unwrap();

    let mut target2: GLenum;
    target2 = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let mut fill2: GLuint;
    fill2 = (call.arg(10)).to_u32().unwrap();

    let mut target3: GLenum;
    target3 = (call.arg(11)).to_u32().unwrap().try_into().unwrap();

    let mut fill3: GLuint;
    fill3 = (call.arg(12)).to_u32().unwrap();

    unsafe { gl::PresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, _type, target0, fill0, target1, fill1, target2, fill2, target3, fill3) };
}

pub fn retrace_glPrimitiveRestartNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PrimitiveRestartNV() };
}

pub fn retrace_glPrimitiveRestartIndexNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::PrimitiveRestartIndexNV(index) };
}

pub fn retrace_glReadBufferNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::ReadBufferNV(mode) };
}

pub fn retrace_glCombinerParameterfvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat257_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat257_0) = _a_GLfloat257_0 {
        for _jGLfloat257 in 0.._a_GLfloat257_0.values.len() {
    params[_jGLfloat257] = (*_a_GLfloat257_0.values[_jGLfloat257]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::CombinerParameterfvNV(pname, params) };
}

pub fn retrace_glCombinerParameterfNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::CombinerParameterfNV(pname, param) };
}

pub fn retrace_glCombinerParameterivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint257_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint257_0) = _a_GLint257_0 {
        for _jGLint257 in 0.._a_GLint257_0.values.len() {
    params[_jGLint257] = (*_a_GLint257_0.values[_jGLint257]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::CombinerParameterivNV(pname, params) };
}

pub fn retrace_glCombinerParameteriNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::CombinerParameteriNV(pname, param) };
}

pub fn retrace_glCombinerInputNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stage: GLenum;
    stage = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut portion: GLenum;
    portion = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut variable: GLenum;
    variable = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut input: GLenum;
    input = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut mapping: GLenum;
    mapping = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut componentUsage: GLenum;
    componentUsage = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::CombinerInputNV(stage, portion, variable, input, mapping, componentUsage) };
}

pub fn retrace_glCombinerOutputNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stage: GLenum;
    stage = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut portion: GLenum;
    portion = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut abOutput: GLenum;
    abOutput = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut cdOutput: GLenum;
    cdOutput = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut sumOutput: GLenum;
    sumOutput = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let mut scale: GLenum;
    scale = (call.arg(5)).to_u32().unwrap().try_into().unwrap();

    let mut bias: GLenum;
    bias = (call.arg(6)).to_u32().unwrap().try_into().unwrap();

    let mut abDotProduct: GLboolean;
    abDotProduct = (call.arg(7)).to_u32().unwrap() as u8;

    let mut cdDotProduct: GLboolean;
    cdDotProduct = (call.arg(8)).to_u32().unwrap() as u8;

    let mut muxSum: GLboolean;
    muxSum = (call.arg(9)).to_u32().unwrap() as u8;

    unsafe { gl::CombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum) };
}

pub fn retrace_glFinalCombinerInputNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut variable: GLenum;
    variable = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut input: GLenum;
    input = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut mapping: GLenum;
    mapping = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut componentUsage: GLenum;
    componentUsage = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::FinalCombinerInputNV(variable, input, mapping, componentUsage) };
}

pub fn retrace_glCombinerStageParameterfvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stage: GLenum;
    stage = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat258_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat258_0) = _a_GLfloat258_0 {
        for _jGLfloat258 in 0.._a_GLfloat258_0.values.len() {
    params[_jGLfloat258] = (*_a_GLfloat258_0.values[_jGLfloat258]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::CombinerStageParameterfvNV(stage, pname, params) };
}

pub fn retrace_glMakeBufferResidentNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut access: GLenum;
    access = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::MakeBufferResidentNV(target, access) };
}

pub fn retrace_glMakeBufferNonResidentNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::MakeBufferNonResidentNV(target) };
}

pub fn retrace_glMakeNamedBufferResidentNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut access: GLenum;
    access = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::MakeNamedBufferResidentNV(buffer, access) };
}

pub fn retrace_glMakeNamedBufferNonResidentNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut buffer: GLuint;
    buffer = (call.arg(0)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::MakeNamedBufferNonResidentNV(buffer) };
}

pub fn retrace_glUniformui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut value: GLuint64EXT;
    value = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::Uniformui64NV(location, value) };
}

pub fn retrace_glUniformui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut location: GLint;
    GLint program = _getActiveProgram();
    location = (call.arg(0)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let value: &mut [GLuint64EXT];
    value = _allocator.alloc_array::<GLuint64EXT>(&call.arg(2));
    let _a_GLuint64EXT16_0 = (call.arg(2)).to_array();
    if let Some(_a_GLuint64EXT16_0) = _a_GLuint64EXT16_0 {
        for _jGLuint64EXT16 in 0.._a_GLuint64EXT16_0.values.len() {
    value[_jGLuint64EXT16] = (*_a_GLuint64EXT16_0.values[_jGLuint64EXT16]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Uniformui64vNV(location, count, value) };
}

pub fn retrace_glProgramUniformui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut value: GLuint64EXT;
    value = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::ProgramUniformui64NV(program, location, value) };
}

pub fn retrace_glProgramUniformui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut location: GLint;
    location = (call.arg(1)).to_i32().unwrap();
    location = _location_map[program].lookupUniformLocation(location);

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let value: &mut [GLuint64EXT];
    value = _allocator.alloc_array::<GLuint64EXT>(&call.arg(3));
    let _a_GLuint64EXT17_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint64EXT17_0) = _a_GLuint64EXT17_0 {
        for _jGLuint64EXT17 in 0.._a_GLuint64EXT17_0.values.len() {
    value[_jGLuint64EXT17] = (*_a_GLuint64EXT17_0.values[_jGLuint64EXT17]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramUniformui64vNV(program, location, count, value) };
}

pub fn retrace_glTextureBarrierNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::TextureBarrierNV() };
}

pub fn retrace_glTexImage2DMultisampleCoverageNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coverageSamples: GLsizei;
    coverageSamples = (call.arg(1)).to_i32().unwrap();

    let mut colorSamples: GLsizei;
    colorSamples = (call.arg(2)).to_i32().unwrap();

    let mut internalFormat: GLint;
    internalFormat = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut fixedSampleLocations: GLboolean;
    fixedSampleLocations = (call.arg(6)).to_u32().unwrap() as u8;

    unsafe { gl::TexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations) };
}

pub fn retrace_glTexImage3DMultisampleCoverageNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut coverageSamples: GLsizei;
    coverageSamples = (call.arg(1)).to_i32().unwrap();

    let mut colorSamples: GLsizei;
    colorSamples = (call.arg(2)).to_i32().unwrap();

    let mut internalFormat: GLint;
    internalFormat = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(6)).to_i32().unwrap();

    let mut fixedSampleLocations: GLboolean;
    fixedSampleLocations = (call.arg(7)).to_u32().unwrap() as u8;

    unsafe { gl::TexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations) };
}

pub fn retrace_glTextureImage2DMultisampleNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(2)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalFormat: GLint;
    internalFormat = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut fixedSampleLocations: GLboolean;
    fixedSampleLocations = (call.arg(6)).to_u32().unwrap() as u8;

    unsafe { gl::TextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations) };
}

pub fn retrace_glTextureImage3DMultisampleNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut samples: GLsizei;
    samples = (call.arg(2)).to_i32().unwrap();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    let mut internalFormat: GLint;
    internalFormat = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(5)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(6)).to_i32().unwrap();

    let mut fixedSampleLocations: GLboolean;
    fixedSampleLocations = (call.arg(7)).to_u32().unwrap() as u8;

    unsafe { gl::TextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations) };
}

pub fn retrace_glTextureImage2DMultisampleCoverageNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut coverageSamples: GLsizei;
    coverageSamples = (call.arg(2)).to_i32().unwrap();

    let mut colorSamples: GLsizei;
    colorSamples = (call.arg(3)).to_i32().unwrap();

    let mut internalFormat: GLint;
    internalFormat = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut fixedSampleLocations: GLboolean;
    fixedSampleLocations = (call.arg(7)).to_u32().unwrap() as u8;

    unsafe { gl::TextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations) };
}

pub fn retrace_glTextureImage3DMultisampleCoverageNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut texture: GLuint;
    texture = (call.arg(0)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut coverageSamples: GLsizei;
    coverageSamples = (call.arg(2)).to_i32().unwrap();

    let mut colorSamples: GLsizei;
    colorSamples = (call.arg(3)).to_i32().unwrap();

    let mut internalFormat: GLint;
    internalFormat = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut fixedSampleLocations: GLboolean;
    fixedSampleLocations = (call.arg(8)).to_u32().unwrap() as u8;

    unsafe { gl::TextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations) };
}

pub fn retrace_glBeginTransformFeedbackNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut primitiveMode: GLenum;
    primitiveMode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BeginTransformFeedbackNV(primitiveMode) };
}

pub fn retrace_glEndTransformFeedbackNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::EndTransformFeedbackNV() };
}

pub fn retrace_glTransformFeedbackAttribsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut count: GLsizei;
    count = (call.arg(0)).to_i32().unwrap();

    let attribs: &mut [GLint];
    attribs = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint258_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint258_0) = _a_GLint258_0 {
        for _jGLint258 in 0.._a_GLint258_0.values.len() {
    attribs[_jGLint258] = (*_a_GLint258_0.values[_jGLint258]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut bufferMode: GLenum;
    bufferMode = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::TransformFeedbackAttribsNV(count, attribs, bufferMode) };
}

pub fn retrace_glBindBufferRangeNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    let mut size: GLsizeiptr;
    size = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::BindBufferRangeNV(target, index, buffer, offset, size) };
}

pub fn retrace_glBindBufferOffsetNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    let mut offset: GLintptr;
    offset = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::BindBufferOffsetNV(target, index, buffer, offset) };
}

pub fn retrace_glBindBufferBaseNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut buffer: GLuint;
    buffer = (call.arg(2)).to_u32().unwrap();
    buffer = _buffer_map[buffer];

    unsafe { gl::BindBufferBaseNV(target, index, buffer) };
}

pub fn retrace_glTransformFeedbackVaryingsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let locations: &mut [GLint];
    locations = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint259_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint259_0) = _a_GLint259_0 {
        for _jGLint259 in 0.._a_GLint259_0.values.len() {
    locations[_jGLint259] = (*_a_GLint259_0.values[_jGLint259]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut bufferMode: GLenum;
    bufferMode = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::TransformFeedbackVaryingsNV(program, count, locations, bufferMode) };
}

pub fn retrace_glActiveVaryingNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(1)).to_string().unwrap());

    unsafe { gl::ActiveVaryingNV(program, name) };
}

pub fn retrace_glGetVaryingLocationNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let name: &mut [GLchar];
    name = (GLchar *)((call.arg(1)).to_string().unwrap());

    let _result = unsafe { gl::GetVaryingLocationNV(program, name) };

    let _origResult: GLint;
    _origResult = (*call.ret).to_i32().unwrap();
    _location_map[program][_origResult] = _result;
}

pub fn retrace_glTransformFeedbackStreamAttribsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut count: GLsizei;
    count = (call.arg(0)).to_i32().unwrap();

    let attribs: &mut [GLint];
    attribs = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint260_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint260_0) = _a_GLint260_0 {
        for _jGLint260 in 0.._a_GLint260_0.values.len() {
    attribs[_jGLint260] = (*_a_GLint260_0.values[_jGLint260]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut nbuffers: GLsizei;
    nbuffers = (call.arg(2)).to_i32().unwrap();

    let bufstreams: &mut [GLint];
    bufstreams = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint261_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint261_0) = _a_GLint261_0 {
        for _jGLint261 in 0.._a_GLint261_0.values.len() {
    bufstreams[_jGLint261] = (*_a_GLint261_0.values[_jGLint261]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let mut bufferMode: GLenum;
    bufferMode = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::TransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode) };
}

pub fn retrace_glBindTransformFeedbackNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _feedback_map[id];

    unsafe { gl::BindTransformFeedbackNV(target, id) };
}

pub fn retrace_glDeleteTransformFeedbacksNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint253_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint253_0) = _a_GLuint253_0 {
        for _jGLuint253 in 0.._a_GLuint253_0.values.len() {
    ids[_jGLuint253] = (*_a_GLuint253_0.values[_jGLuint253]).to_u32().unwrap();
    ids[_jGLuint253] = _feedback_map[ids[_jGLuint253]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteTransformFeedbacksNV(n, ids) };
}

pub fn retrace_glGenTransformFeedbacksNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let ids: &mut [GLuint];
    ids = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenTransformFeedbacksNV(n, ids) };
    let _aGLuint255 = (call.arg(1)).to_array();
    if (_aGLuint255) {
        for _jGLuint255 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint255.values[_jGLuint255]).to_u32().unwrap();
    _feedback_map[_origResult] = ids[_jGLuint255];
        }
    }
}

pub fn retrace_glPauseTransformFeedbackNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::PauseTransformFeedbackNV() };
}

pub fn retrace_glResumeTransformFeedbackNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::ResumeTransformFeedbackNV() };
}

pub fn retrace_glDrawTransformFeedbackNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _feedback_map[id];

    unsafe { gl::DrawTransformFeedbackNV(mode, id) };
}

pub fn retrace_glVDPAUInitNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let vdpDevice: &mut [GLvoid];
    memset(&vdpDevice, 0, sizeof vdpDevice); // FIXME

    let getProcAddress: &mut [GLvoid];
    memset(&getProcAddress, 0, sizeof getProcAddress); // FIXME

    if (1) {
    }
    unsafe { gl::VDPAUInitNV(vdpDevice, getProcAddress) };
}

pub fn retrace_glVDPAUFiniNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::VDPAUFiniNV() };
}

pub fn retrace_glVDPAURegisterVideoSurfaceNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let vdpSurface: &mut [GLvoid];
    memset(&vdpSurface, 0, sizeof vdpSurface); // FIXME

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut numTextureNames: GLsizei;
    numTextureNames = (call.arg(2)).to_i32().unwrap();

    let textureNames: &mut [GLuint];
    textureNames = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint256_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint256_0) = _a_GLuint256_0 {
        for _jGLuint256 in 0.._a_GLuint256_0.values.len() {
    textureNames[_jGLuint256] = (*_a_GLuint256_0.values[_jGLuint256]).to_u32().unwrap();
    textureNames[_jGLuint256] = _texture_map[textureNames[_jGLuint256]];
        }
    }
    let params = params.as_mut_ptr();

    if (1) {
    }
    let _result = unsafe { gl::VDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames) };

}

pub fn retrace_glVDPAURegisterOutputSurfaceNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let vdpSurface: &mut [GLvoid];
    memset(&vdpSurface, 0, sizeof vdpSurface); // FIXME

    let mut target: GLenum;
    target = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut numTextureNames: GLsizei;
    numTextureNames = (call.arg(2)).to_i32().unwrap();

    let textureNames: &mut [GLuint];
    textureNames = _allocator.alloc_array::<GLuint>(&call.arg(3));
    let _a_GLuint257_0 = (call.arg(3)).to_array();
    if let Some(_a_GLuint257_0) = _a_GLuint257_0 {
        for _jGLuint257 in 0.._a_GLuint257_0.values.len() {
    textureNames[_jGLuint257] = (*_a_GLuint257_0.values[_jGLuint257]).to_u32().unwrap();
    textureNames[_jGLuint257] = _texture_map[textureNames[_jGLuint257]];
        }
    }
    let params = params.as_mut_ptr();

    if (1) {
    }
    let _result = unsafe { gl::VDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames) };

}

pub fn retrace_glVDPAUUnregisterSurfaceNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut surface: GLvdpauSurfaceNV;
    surface = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::VDPAUUnregisterSurfaceNV(surface) };
}

pub fn retrace_glVDPAUGetSurfaceivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut surface: GLvdpauSurfaceNV;
    surface = (call.arg(0)).to_i32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut bufSize: GLsizei;
    bufSize = (call.arg(2)).to_i32().unwrap();

    let length: &mut [GLsizei];
    length = _allocator.alloc_array::<GLsizei>(&call.arg(3));

    let values: &mut [GLint];
    values = _allocator.alloc_array::<GLint>(&call.arg(4));

    unsafe { gl::VDPAUGetSurfaceivNV(surface, pname, bufSize, length, values) };
    let _aPGLsizei37 = (call.arg(3)).to_array();
    if (_aPGLsizei37) {
    }
    let _aGLint263 = (call.arg(4)).to_array();
    if (_aGLint263) {
        for _jGLint263 in 0..length {
        }
    }
}

pub fn retrace_glVDPAUSurfaceAccessNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut surface: GLvdpauSurfaceNV;
    surface = (call.arg(0)).to_i32().unwrap();

    let mut access: GLenum;
    access = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::VDPAUSurfaceAccessNV(surface, access) };
}

pub fn retrace_glVDPAUMapSurfacesNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut numSurfaces: GLsizei;
    numSurfaces = (call.arg(0)).to_i32().unwrap();

    let surfaces: &mut [GLvdpauSurfaceNV];
    surfaces = _allocator.alloc_array::<GLvdpauSurfaceNV>(&call.arg(1));
    let _a_GLvdpauSurfaceNV1_0 = (call.arg(1)).to_array();
    if let Some(_a_GLvdpauSurfaceNV1_0) = _a_GLvdpauSurfaceNV1_0 {
        for _jGLvdpauSurfaceNV1 in 0.._a_GLvdpauSurfaceNV1_0.values.len() {
    surfaces[_jGLvdpauSurfaceNV1] = (*_a_GLvdpauSurfaceNV1_0.values[_jGLvdpauSurfaceNV1]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VDPAUMapSurfacesNV(numSurfaces, surfaces) };
}

pub fn retrace_glVDPAUUnmapSurfacesNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut numSurface: GLsizei;
    numSurface = (call.arg(0)).to_i32().unwrap();

    let surfaces: &mut [GLvdpauSurfaceNV];
    surfaces = _allocator.alloc_array::<GLvdpauSurfaceNV>(&call.arg(1));
    let _a_GLvdpauSurfaceNV2_0 = (call.arg(1)).to_array();
    if let Some(_a_GLvdpauSurfaceNV2_0) = _a_GLvdpauSurfaceNV2_0 {
        for _jGLvdpauSurfaceNV2 in 0.._a_GLvdpauSurfaceNV2_0.values.len() {
    surfaces[_jGLvdpauSurfaceNV2] = (*_a_GLvdpauSurfaceNV2_0.values[_jGLvdpauSurfaceNV2]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VDPAUUnmapSurfacesNV(numSurface, surfaces) };
}

pub fn retrace_glFlushVertexArrayRangeNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::FlushVertexArrayRangeNV() };
}

pub fn retrace_glVertexArrayRangeNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut length: GLsizei;
    length = (call.arg(0)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::VertexArrayRangeNV(length, pointer) };
}

pub fn retrace_glVertexAttribL1i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint64EXT;
    x = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::VertexAttribL1i64NV(index, x) };
}

pub fn retrace_glVertexAttribL2i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint64EXT;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint64EXT;
    y = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::VertexAttribL2i64NV(index, x, y) };
}

pub fn retrace_glVertexAttribL3i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint64EXT;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint64EXT;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint64EXT;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexAttribL3i64NV(index, x, y, z) };
}

pub fn retrace_glVertexAttribL4i64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint64EXT;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint64EXT;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint64EXT;
    z = (call.arg(3)).to_i32().unwrap();

    let mut w: GLint64EXT;
    w = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexAttribL4i64NV(index, x, y, z, w) };
}

pub fn retrace_glVertexAttribL1i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint64EXT];
    v = _allocator.alloc_array::<GLint64EXT>(&call.arg(1));
    let _a_PGLint64EXT_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLint64EXT_0.values[0]).to_i32().unwrap();

    unsafe { gl::VertexAttribL1i64vNV(index, v) };
}

pub fn retrace_glVertexAttribL2i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint64EXT];
    v = _allocator.alloc_array::<GLint64EXT>(&call.arg(1));
    let _a_GLint64EXT12_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint64EXT12_0) = _a_GLint64EXT12_0 {
        for _jGLint64EXT12 in 0.._a_GLint64EXT12_0.values.len() {
    v[_jGLint64EXT12] = (*_a_GLint64EXT12_0.values[_jGLint64EXT12]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL2i64vNV(index, v) };
}

pub fn retrace_glVertexAttribL3i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint64EXT];
    v = _allocator.alloc_array::<GLint64EXT>(&call.arg(1));
    let _a_GLint64EXT13_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint64EXT13_0) = _a_GLint64EXT13_0 {
        for _jGLint64EXT13 in 0.._a_GLint64EXT13_0.values.len() {
    v[_jGLint64EXT13] = (*_a_GLint64EXT13_0.values[_jGLint64EXT13]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL3i64vNV(index, v) };
}

pub fn retrace_glVertexAttribL4i64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint64EXT];
    v = _allocator.alloc_array::<GLint64EXT>(&call.arg(1));
    let _a_GLint64EXT14_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint64EXT14_0) = _a_GLint64EXT14_0 {
        for _jGLint64EXT14 in 0.._a_GLint64EXT14_0.values.len() {
    v[_jGLint64EXT14] = (*_a_GLint64EXT14_0.values[_jGLint64EXT14]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL4i64vNV(index, v) };
}

pub fn retrace_glVertexAttribL1ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint64EXT;
    x = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexAttribL1ui64NV(index, x) };
}

pub fn retrace_glVertexAttribL2ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint64EXT;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint64EXT;
    y = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::VertexAttribL2ui64NV(index, x, y) };
}

pub fn retrace_glVertexAttribL3ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint64EXT;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint64EXT;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLuint64EXT;
    z = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::VertexAttribL3ui64NV(index, x, y, z) };
}

pub fn retrace_glVertexAttribL4ui64NV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint64EXT;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint64EXT;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLuint64EXT;
    z = (call.arg(3)).to_u32().unwrap();

    let mut w: GLuint64EXT;
    w = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexAttribL4ui64NV(index, x, y, z, w) };
}

pub fn retrace_glVertexAttribL1ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint64EXT];
    v = _allocator.alloc_array::<GLuint64EXT>(&call.arg(1));
    let _a_PGLuint64EXT1_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLuint64EXT1_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexAttribL1ui64vNV(index, v) };
}

pub fn retrace_glVertexAttribL2ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint64EXT];
    v = _allocator.alloc_array::<GLuint64EXT>(&call.arg(1));
    let _a_GLuint64EXT18_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint64EXT18_0) = _a_GLuint64EXT18_0 {
        for _jGLuint64EXT18 in 0.._a_GLuint64EXT18_0.values.len() {
    v[_jGLuint64EXT18] = (*_a_GLuint64EXT18_0.values[_jGLuint64EXT18]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL2ui64vNV(index, v) };
}

pub fn retrace_glVertexAttribL3ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint64EXT];
    v = _allocator.alloc_array::<GLuint64EXT>(&call.arg(1));
    let _a_GLuint64EXT19_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint64EXT19_0) = _a_GLuint64EXT19_0 {
        for _jGLuint64EXT19 in 0.._a_GLuint64EXT19_0.values.len() {
    v[_jGLuint64EXT19] = (*_a_GLuint64EXT19_0.values[_jGLuint64EXT19]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL3ui64vNV(index, v) };
}

pub fn retrace_glVertexAttribL4ui64vNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint64EXT];
    v = _allocator.alloc_array::<GLuint64EXT>(&call.arg(1));
    let _a_GLuint64EXT20_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint64EXT20_0) = _a_GLuint64EXT20_0 {
        for _jGLuint64EXT20 in 0.._a_GLuint64EXT20_0.values.len() {
    v[_jGLuint64EXT20] = (*_a_GLuint64EXT20_0.values[_jGLuint64EXT20]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribL4ui64vNV(index, v) };
}

pub fn retrace_glVertexAttribLFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexAttribLFormatNV(index, size, _type, stride) };
}

pub fn retrace_glBufferAddressRangeNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut address: GLuint64EXT;
    address = (call.arg(2)).to_u32().unwrap();

    let mut length: GLsizeiptr;
    length = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::BufferAddressRangeNV(pname, index, address, length) };
}

pub fn retrace_glVertexFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::VertexFormatNV(size, _type, stride) };
}

pub fn retrace_glNormalFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::NormalFormatNV(_type, stride) };
}

pub fn retrace_glColorFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ColorFormatNV(size, _type, stride) };
}

pub fn retrace_glIndexFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::IndexFormatNV(_type, stride) };
}

pub fn retrace_glTexCoordFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TexCoordFormatNV(size, _type, stride) };
}

pub fn retrace_glEdgeFlagFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut stride: GLsizei;
    stride = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::EdgeFlagFormatNV(stride) };
}

pub fn retrace_glSecondaryColorFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::SecondaryColorFormatNV(size, _type, stride) };
}

pub fn retrace_glFogCoordFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::FogCoordFormatNV(_type, stride) };
}

pub fn retrace_glVertexAttribFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut normalized: GLboolean;
    normalized = (call.arg(3)).to_u32().unwrap() as u8;

    let mut stride: GLsizei;
    stride = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexAttribFormatNV(index, size, _type, normalized, stride) };
}

pub fn retrace_glVertexAttribIFormatNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexAttribIFormatNV(index, size, _type, stride) };
}

pub fn retrace_glBindProgramNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut program: GLuint;
    program = (call.arg(1)).to_u32().unwrap();
    program = _programARB_map[program];

    unsafe { gl::BindProgramNV(target, program) };
}

pub fn retrace_glDeleteProgramsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let programs: &mut [GLuint];
    programs = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint258_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint258_0) = _a_GLuint258_0 {
        for _jGLuint258 in 0.._a_GLuint258_0.values.len() {
    programs[_jGLuint258] = (*_a_GLuint258_0.values[_jGLuint258]).to_u32().unwrap();
    programs[_jGLuint258] = _programARB_map[programs[_jGLuint258]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteProgramsNV(n, programs) };
}

pub fn retrace_glExecuteProgramNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _programARB_map[id];

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat259_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat259_0) = _a_GLfloat259_0 {
        for _jGLfloat259 in 0.._a_GLfloat259_0.values.len() {
    params[_jGLfloat259] = (*_a_GLfloat259_0.values[_jGLfloat259]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ExecuteProgramNV(target, id, params) };
}

pub fn retrace_glGenProgramsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let programs: &mut [GLuint];
    programs = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenProgramsNV(n, programs) };
    let _aGLuint260 = (call.arg(1)).to_array();
    if (_aGLuint260) {
        for _jGLuint260 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint260.values[_jGLuint260]).to_u32().unwrap();
    _programARB_map[_origResult] = programs[_jGLuint260];
        }
    }
}

pub fn retrace_glLoadProgramNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut id: GLuint;
    id = (call.arg(1)).to_u32().unwrap();
    id = _programARB_map[id];

    let mut len: GLsizei;
    len = (call.arg(2)).to_i32().unwrap();

    let program: &mut [GLubyte];
    program = (GLubyte *)((call.arg(3)).to_string().unwrap());

    unsafe { gl::LoadProgramNV(target, id, len, program) };
        let error_position: GLint = -1;
        gl::GetIntegerv(gl::PIXEL_PACK_BUFFER_BINDING, &error_position);
        if error_position != -1 {
            let error_string = gl::GetString(gl::PROGRAM_ERROR_STRING_ARB);
            println!("error in position {}: {}", error_position, error_string);
        }
}

pub fn retrace_glProgramParameter4dNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(2)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(3)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(4)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(5)).to_f64().unwrap();

    unsafe { gl::ProgramParameter4dNV(target, index, x, y, z, w) };
}

pub fn retrace_glProgramParameter4dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble134_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble134_0) = _a_GLdouble134_0 {
        for _jGLdouble134 in 0.._a_GLdouble134_0.values.len() {
    v[_jGLdouble134] = (*_a_GLdouble134_0.values[_jGLdouble134]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramParameter4dvNV(target, index, v) };
}

pub fn retrace_glProgramParameter4fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(2)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(3)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(4)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::ProgramParameter4fNV(target, index, x, y, z, w) };
}

pub fn retrace_glProgramParameter4fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat260_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat260_0) = _a_GLfloat260_0 {
        for _jGLfloat260 in 0.._a_GLfloat260_0.values.len() {
    v[_jGLfloat260] = (*_a_GLfloat260_0.values[_jGLfloat260]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramParameter4fvNV(target, index, v) };
}

pub fn retrace_glProgramParameters4dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble135_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble135_0) = _a_GLdouble135_0 {
        for _jGLdouble135 in 0.._a_GLdouble135_0.values.len() {
    v[_jGLdouble135] = (*_a_GLdouble135_0.values[_jGLdouble135]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramParameters4dvNV(target, index, count, v) };
}

pub fn retrace_glProgramParameters4fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut index: GLuint;
    index = (call.arg(1)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat261_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat261_0) = _a_GLfloat261_0 {
        for _jGLfloat261 in 0.._a_GLfloat261_0.values.len() {
    v[_jGLfloat261] = (*_a_GLfloat261_0.values[_jGLfloat261]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ProgramParameters4fvNV(target, index, count, v) };
}

pub fn retrace_glRequestResidentProgramsNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let programs: &mut [GLuint];
    programs = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint261_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint261_0) = _a_GLuint261_0 {
        for _jGLuint261 in 0.._a_GLuint261_0.values.len() {
    programs[_jGLuint261] = (*_a_GLuint261_0.values[_jGLuint261]).to_u32().unwrap();
    programs[_jGLuint261] = _programARB_map[programs[_jGLuint261]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::RequestResidentProgramsNV(n, programs) };
}

pub fn retrace_glTrackMatrixNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut address: GLuint;
    address = (call.arg(1)).to_u32().unwrap();

    let mut matrix: GLenum;
    matrix = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut transform: GLenum;
    transform = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::TrackMatrixNV(target, address, matrix, transform) };
}

pub fn retrace_glVertexAttribPointerNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(4), true));

    unsafe { gl::VertexAttribPointerNV(index, size, _type, stride, pointer) };
}

pub fn retrace_glVertexAttrib1dNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    unsafe { gl::VertexAttrib1dNV(index, x) };
}

pub fn retrace_glVertexAttrib1dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_PGLdouble13_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLdouble13_0.values[0]).to_f64().unwrap();

    unsafe { gl::VertexAttrib1dvNV(index, v) };
}

pub fn retrace_glVertexAttrib1fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::VertexAttrib1fNV(index, x) };
}

pub fn retrace_glVertexAttrib1fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_PGLfloat22_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLfloat22_0.values[0]).to_f32().unwrap();

    unsafe { gl::VertexAttrib1fvNV(index, v) };
}

pub fn retrace_glVertexAttrib1sNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::VertexAttrib1sNV(index, x) };
}

pub fn retrace_glVertexAttrib1svNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_PGLshort7_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLshort7_0.values[0]).to_i32().unwrap();

    unsafe { gl::VertexAttrib1svNV(index, v) };
}

pub fn retrace_glVertexAttrib2dNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    unsafe { gl::VertexAttrib2dNV(index, x, y) };
}

pub fn retrace_glVertexAttrib2dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble136_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble136_0) = _a_GLdouble136_0 {
        for _jGLdouble136 in 0.._a_GLdouble136_0.values.len() {
    v[_jGLdouble136] = (*_a_GLdouble136_0.values[_jGLdouble136]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib2dvNV(index, v) };
}

pub fn retrace_glVertexAttrib2fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::VertexAttrib2fNV(index, x, y) };
}

pub fn retrace_glVertexAttrib2fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat262_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat262_0) = _a_GLfloat262_0 {
        for _jGLfloat262 in 0.._a_GLfloat262_0.values.len() {
    v[_jGLfloat262] = (*_a_GLfloat262_0.values[_jGLfloat262]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib2fvNV(index, v) };
}

pub fn retrace_glVertexAttrib2sNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::VertexAttrib2sNV(index, x, y) };
}

pub fn retrace_glVertexAttrib2svNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort46_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort46_0) = _a_GLshort46_0 {
        for _jGLshort46 in 0.._a_GLshort46_0.values.len() {
    v[_jGLshort46] = (*_a_GLshort46_0.values[_jGLshort46]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib2svNV(index, v) };
}

pub fn retrace_glVertexAttrib3dNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    unsafe { gl::VertexAttrib3dNV(index, x, y, z) };
}

pub fn retrace_glVertexAttrib3dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble137_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble137_0) = _a_GLdouble137_0 {
        for _jGLdouble137 in 0.._a_GLdouble137_0.values.len() {
    v[_jGLdouble137] = (*_a_GLdouble137_0.values[_jGLdouble137]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib3dvNV(index, v) };
}

pub fn retrace_glVertexAttrib3fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::VertexAttrib3fNV(index, x, y, z) };
}

pub fn retrace_glVertexAttrib3fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat263_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat263_0) = _a_GLfloat263_0 {
        for _jGLfloat263 in 0.._a_GLfloat263_0.values.len() {
    v[_jGLfloat263] = (*_a_GLfloat263_0.values[_jGLfloat263]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib3fvNV(index, v) };
}

pub fn retrace_glVertexAttrib3sNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexAttrib3sNV(index, x, y, z) };
}

pub fn retrace_glVertexAttrib3svNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort47_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort47_0) = _a_GLshort47_0 {
        for _jGLshort47 in 0.._a_GLshort47_0.values.len() {
    v[_jGLshort47] = (*_a_GLshort47_0.values[_jGLshort47]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib3svNV(index, v) };
}

pub fn retrace_glVertexAttrib4dNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLdouble;
    x = (call.arg(1)).to_f64().unwrap();

    let mut y: GLdouble;
    y = (call.arg(2)).to_f64().unwrap();

    let mut z: GLdouble;
    z = (call.arg(3)).to_f64().unwrap();

    let mut w: GLdouble;
    w = (call.arg(4)).to_f64().unwrap();

    unsafe { gl::VertexAttrib4dNV(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(1));
    let _a_GLdouble138_0 = (call.arg(1)).to_array();
    if let Some(_a_GLdouble138_0) = _a_GLdouble138_0 {
        for _jGLdouble138 in 0.._a_GLdouble138_0.values.len() {
    v[_jGLdouble138] = (*_a_GLdouble138_0.values[_jGLdouble138]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4dvNV(index, v) };
}

pub fn retrace_glVertexAttrib4fNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::VertexAttrib4fNV(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat264_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat264_0) = _a_GLfloat264_0 {
        for _jGLfloat264 in 0.._a_GLfloat264_0.values.len() {
    v[_jGLfloat264] = (*_a_GLfloat264_0.values[_jGLfloat264]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4fvNV(index, v) };
}

pub fn retrace_glVertexAttrib4sNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLshort;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(3)).to_i32().unwrap();

    let mut w: GLshort;
    w = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexAttrib4sNV(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4svNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort48_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort48_0) = _a_GLshort48_0 {
        for _jGLshort48 in 0.._a_GLshort48_0.values.len() {
    v[_jGLshort48] = (*_a_GLshort48_0.values[_jGLshort48]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4svNV(index, v) };
}

pub fn retrace_glVertexAttrib4ubNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLubyte;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLubyte;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLubyte;
    z = (call.arg(3)).to_u32().unwrap();

    let mut w: GLubyte;
    w = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexAttrib4ubNV(index, x, y, z, w) };
}

pub fn retrace_glVertexAttrib4ubvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte22_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte22_0) = _a_GLubyte22_0 {
        for _jGLubyte22 in 0.._a_GLubyte22_0.values.len() {
    v[_jGLubyte22] = (*_a_GLubyte22_0.values[_jGLubyte22]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttrib4ubvNV(index, v) };
}

pub fn retrace_glVertexAttribs1dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble139_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble139_0) = _a_GLdouble139_0 {
        for _jGLdouble139 in 0.._a_GLdouble139_0.values.len() {
    v[_jGLdouble139] = (*_a_GLdouble139_0.values[_jGLdouble139]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs1dvNV(index, count, v) };
}

pub fn retrace_glVertexAttribs1fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat265_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat265_0) = _a_GLfloat265_0 {
        for _jGLfloat265 in 0.._a_GLfloat265_0.values.len() {
    v[_jGLfloat265] = (*_a_GLfloat265_0.values[_jGLfloat265]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs1fvNV(index, count, v) };
}

pub fn retrace_glVertexAttribs1svNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(2));
    let _a_GLshort49_0 = (call.arg(2)).to_array();
    if let Some(_a_GLshort49_0) = _a_GLshort49_0 {
        for _jGLshort49 in 0.._a_GLshort49_0.values.len() {
    v[_jGLshort49] = (*_a_GLshort49_0.values[_jGLshort49]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs1svNV(index, count, v) };
}

pub fn retrace_glVertexAttribs2dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble140_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble140_0) = _a_GLdouble140_0 {
        for _jGLdouble140 in 0.._a_GLdouble140_0.values.len() {
    v[_jGLdouble140] = (*_a_GLdouble140_0.values[_jGLdouble140]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs2dvNV(index, count, v) };
}

pub fn retrace_glVertexAttribs2fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat266_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat266_0) = _a_GLfloat266_0 {
        for _jGLfloat266 in 0.._a_GLfloat266_0.values.len() {
    v[_jGLfloat266] = (*_a_GLfloat266_0.values[_jGLfloat266]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs2fvNV(index, count, v) };
}

pub fn retrace_glVertexAttribs2svNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(2));
    let _a_GLshort50_0 = (call.arg(2)).to_array();
    if let Some(_a_GLshort50_0) = _a_GLshort50_0 {
        for _jGLshort50 in 0.._a_GLshort50_0.values.len() {
    v[_jGLshort50] = (*_a_GLshort50_0.values[_jGLshort50]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs2svNV(index, count, v) };
}

pub fn retrace_glVertexAttribs3dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble141_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble141_0) = _a_GLdouble141_0 {
        for _jGLdouble141 in 0.._a_GLdouble141_0.values.len() {
    v[_jGLdouble141] = (*_a_GLdouble141_0.values[_jGLdouble141]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs3dvNV(index, count, v) };
}

pub fn retrace_glVertexAttribs3fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat267_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat267_0) = _a_GLfloat267_0 {
        for _jGLfloat267 in 0.._a_GLfloat267_0.values.len() {
    v[_jGLfloat267] = (*_a_GLfloat267_0.values[_jGLfloat267]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs3fvNV(index, count, v) };
}

pub fn retrace_glVertexAttribs3svNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(2));
    let _a_GLshort51_0 = (call.arg(2)).to_array();
    if let Some(_a_GLshort51_0) = _a_GLshort51_0 {
        for _jGLshort51 in 0.._a_GLshort51_0.values.len() {
    v[_jGLshort51] = (*_a_GLshort51_0.values[_jGLshort51]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs3svNV(index, count, v) };
}

pub fn retrace_glVertexAttribs4dvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLdouble];
    v = _allocator.alloc_array::<GLdouble>(&call.arg(2));
    let _a_GLdouble142_0 = (call.arg(2)).to_array();
    if let Some(_a_GLdouble142_0) = _a_GLdouble142_0 {
        for _jGLdouble142 in 0.._a_GLdouble142_0.values.len() {
    v[_jGLdouble142] = (*_a_GLdouble142_0.values[_jGLdouble142]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs4dvNV(index, count, v) };
}

pub fn retrace_glVertexAttribs4fvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat268_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat268_0) = _a_GLfloat268_0 {
        for _jGLfloat268 in 0.._a_GLfloat268_0.values.len() {
    v[_jGLfloat268] = (*_a_GLfloat268_0.values[_jGLfloat268]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs4fvNV(index, count, v) };
}

pub fn retrace_glVertexAttribs4svNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(2));
    let _a_GLshort52_0 = (call.arg(2)).to_array();
    if let Some(_a_GLshort52_0) = _a_GLshort52_0 {
        for _jGLshort52 in 0.._a_GLshort52_0.values.len() {
    v[_jGLshort52] = (*_a_GLshort52_0.values[_jGLshort52]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs4svNV(index, count, v) };
}

pub fn retrace_glVertexAttribs4ubvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(2));
    let _a_GLubyte23_0 = (call.arg(2)).to_array();
    if let Some(_a_GLubyte23_0) = _a_GLubyte23_0 {
        for _jGLubyte23 in 0.._a_GLubyte23_0.values.len() {
    v[_jGLubyte23] = (*_a_GLubyte23_0.values[_jGLubyte23]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribs4ubvNV(index, count, v) };
}

pub fn retrace_glVertexAttribI1iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::VertexAttribI1iEXT(index, x) };
}

pub fn retrace_glVertexAttribI2iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::VertexAttribI2iEXT(index, x, y) };
}

pub fn retrace_glVertexAttribI3iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::VertexAttribI3iEXT(index, x, y, z) };
}

pub fn retrace_glVertexAttribI4iEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLint;
    x = (call.arg(1)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(2)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(3)).to_i32().unwrap();

    let mut w: GLint;
    w = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::VertexAttribI4iEXT(index, x, y, z, w) };
}

pub fn retrace_glVertexAttribI1uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(1)).to_u32().unwrap();

    unsafe { gl::VertexAttribI1uiEXT(index, x) };
}

pub fn retrace_glVertexAttribI2uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint;
    y = (call.arg(2)).to_u32().unwrap();

    unsafe { gl::VertexAttribI2uiEXT(index, x, y) };
}

pub fn retrace_glVertexAttribI3uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLuint;
    z = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::VertexAttribI3uiEXT(index, x, y, z) };
}

pub fn retrace_glVertexAttribI4uiEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLuint;
    x = (call.arg(1)).to_u32().unwrap();

    let mut y: GLuint;
    y = (call.arg(2)).to_u32().unwrap();

    let mut z: GLuint;
    z = (call.arg(3)).to_u32().unwrap();

    let mut w: GLuint;
    w = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::VertexAttribI4uiEXT(index, x, y, z, w) };
}

pub fn retrace_glVertexAttribI1ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_PGLint35_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLint35_0.values[0]).to_i32().unwrap();

    unsafe { gl::VertexAttribI1ivEXT(index, v) };
}

pub fn retrace_glVertexAttribI2ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint264_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint264_0) = _a_GLint264_0 {
        for _jGLint264 in 0.._a_GLint264_0.values.len() {
    v[_jGLint264] = (*_a_GLint264_0.values[_jGLint264]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI2ivEXT(index, v) };
}

pub fn retrace_glVertexAttribI3ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint265_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint265_0) = _a_GLint265_0 {
        for _jGLint265 in 0.._a_GLint265_0.values.len() {
    v[_jGLint265] = (*_a_GLint265_0.values[_jGLint265]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI3ivEXT(index, v) };
}

pub fn retrace_glVertexAttribI4ivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint266_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint266_0) = _a_GLint266_0 {
        for _jGLint266 in 0.._a_GLint266_0.values.len() {
    v[_jGLint266] = (*_a_GLint266_0.values[_jGLint266]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4ivEXT(index, v) };
}

pub fn retrace_glVertexAttribI1uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_PGLuint61_0 = (call.arg(1)).to_array().unwrap();
    v[0] = (_a_PGLuint61_0.values[0]).to_u32().unwrap();

    unsafe { gl::VertexAttribI1uivEXT(index, v) };
}

pub fn retrace_glVertexAttribI2uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint262_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint262_0) = _a_GLuint262_0 {
        for _jGLuint262 in 0.._a_GLuint262_0.values.len() {
    v[_jGLuint262] = (*_a_GLuint262_0.values[_jGLuint262]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI2uivEXT(index, v) };
}

pub fn retrace_glVertexAttribI3uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint263_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint263_0) = _a_GLuint263_0 {
        for _jGLuint263 in 0.._a_GLuint263_0.values.len() {
    v[_jGLuint263] = (*_a_GLuint263_0.values[_jGLuint263]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI3uivEXT(index, v) };
}

pub fn retrace_glVertexAttribI4uivEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLuint];
    v = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint264_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint264_0) = _a_GLuint264_0 {
        for _jGLuint264 in 0.._a_GLuint264_0.values.len() {
    v[_jGLuint264] = (*_a_GLuint264_0.values[_jGLuint264]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4uivEXT(index, v) };
}

pub fn retrace_glVertexAttribI4bvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLbyte];
    v = _allocator.alloc_array::<GLbyte>(&call.arg(1));
    let _a_GLbyte15_0 = (call.arg(1)).to_array();
    if let Some(_a_GLbyte15_0) = _a_GLbyte15_0 {
        for _jGLbyte15 in 0.._a_GLbyte15_0.values.len() {
    v[_jGLbyte15] = (*_a_GLbyte15_0.values[_jGLbyte15]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4bvEXT(index, v) };
}

pub fn retrace_glVertexAttribI4svEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLshort];
    v = _allocator.alloc_array::<GLshort>(&call.arg(1));
    let _a_GLshort53_0 = (call.arg(1)).to_array();
    if let Some(_a_GLshort53_0) = _a_GLshort53_0 {
        for _jGLshort53 in 0.._a_GLshort53_0.values.len() {
    v[_jGLshort53] = (*_a_GLshort53_0.values[_jGLshort53]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4svEXT(index, v) };
}

pub fn retrace_glVertexAttribI4ubvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLubyte];
    v = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte24_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte24_0) = _a_GLubyte24_0 {
        for _jGLubyte24 in 0.._a_GLubyte24_0.values.len() {
    v[_jGLubyte24] = (*_a_GLubyte24_0.values[_jGLubyte24]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4ubvEXT(index, v) };
}

pub fn retrace_glVertexAttribI4usvEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLushort];
    v = _allocator.alloc_array::<GLushort>(&call.arg(1));
    let _a_GLushort19_0 = (call.arg(1)).to_array();
    if let Some(_a_GLushort19_0) = _a_GLushort19_0 {
        for _jGLushort19 in 0.._a_GLushort19_0.values.len() {
    v[_jGLushort19] = (*_a_GLushort19_0.values[_jGLushort19]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VertexAttribI4usvEXT(index, v) };
}

pub fn retrace_glVertexAttribIPointerEXT(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut size: GLint;
    size = (call.arg(1)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(3)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    //TODO: NEED BOUNDED pointer = s(retrace::toPointer(call.arg(4), true));

    unsafe { gl::VertexAttribIPointerEXT(index, size, _type, stride, pointer) };
}

pub fn retrace_glBeginVideoCaptureNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut video_capture_slot: GLuint;
    video_capture_slot = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::BeginVideoCaptureNV(video_capture_slot) };
}

pub fn retrace_glBindVideoCaptureStreamBufferNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut video_capture_slot: GLuint;
    video_capture_slot = (call.arg(0)).to_u32().unwrap();

    let mut stream: GLuint;
    stream = (call.arg(1)).to_u32().unwrap();

    let mut frame_region: GLenum;
    frame_region = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut offset: GLintptrARB;
    offset = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::BindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset) };
}

pub fn retrace_glBindVideoCaptureStreamTextureNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut video_capture_slot: GLuint;
    video_capture_slot = (call.arg(0)).to_u32().unwrap();

    let mut stream: GLuint;
    stream = (call.arg(1)).to_u32().unwrap();

    let mut frame_region: GLenum;
    frame_region = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut target: GLenum;
    target = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(4)).to_u32().unwrap();

    unsafe { gl::BindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture) };
}

pub fn retrace_glEndVideoCaptureNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut video_capture_slot: GLuint;
    video_capture_slot = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::EndVideoCaptureNV(video_capture_slot) };
}

pub fn retrace_glVideoCaptureNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut video_capture_slot: GLuint;
    video_capture_slot = (call.arg(0)).to_u32().unwrap();

    let sequence_num: &mut [GLuint];
    sequence_num = _allocator.alloc_array::<GLuint>(&call.arg(1));

    let capture_time: &mut [GLuint64EXT];
    capture_time = _allocator.alloc_array::<GLuint64EXT>(&call.arg(2));

    let _result = unsafe { gl::VideoCaptureNV(video_capture_slot, sequence_num, capture_time) };

    let _aPGLuint38 = (call.arg(1)).to_array();
    if (_aPGLuint38) {
    }
    let _aPGLuint64EXT = (call.arg(2)).to_array();
    if (_aPGLuint64EXT) {
    }
}

pub fn retrace_glVideoCaptureStreamParameterivNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut video_capture_slot: GLuint;
    video_capture_slot = (call.arg(0)).to_u32().unwrap();

    let mut stream: GLuint;
    stream = (call.arg(1)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(3));
    let _a_GLint267_0 = (call.arg(3)).to_array();
    if let Some(_a_GLint267_0) = _a_GLint267_0 {
        for _jGLint267 in 0.._a_GLint267_0.values.len() {
    params[_jGLint267] = (*_a_GLint267_0.values[_jGLint267]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params) };
}

pub fn retrace_glVideoCaptureStreamParameterfvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut video_capture_slot: GLuint;
    video_capture_slot = (call.arg(0)).to_u32().unwrap();

    let mut stream: GLuint;
    stream = (call.arg(1)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat269_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat269_0) = _a_GLfloat269_0 {
        for _jGLfloat269 in 0.._a_GLfloat269_0.values.len() {
    params[_jGLfloat269] = (*_a_GLfloat269_0.values[_jGLfloat269]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params) };
}

pub fn retrace_glVideoCaptureStreamParameterdvNV(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut video_capture_slot: GLuint;
    video_capture_slot = (call.arg(0)).to_u32().unwrap();

    let mut stream: GLuint;
    stream = (call.arg(1)).to_u32().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLdouble];
    params = _allocator.alloc_array::<GLdouble>(&call.arg(3));
    let _a_GLdouble143_0 = (call.arg(3)).to_array();
    if let Some(_a_GLdouble143_0) = _a_GLdouble143_0 {
        for _jGLdouble143 in 0.._a_GLdouble143_0.values.len() {
    params[_jGLdouble143] = (*_a_GLdouble143_0.values[_jGLdouble143]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params) };
}

pub fn retrace_glBlendEquationSeparateOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut modeRGB: GLenum;
    modeRGB = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut modeAlpha: GLenum;
    modeAlpha = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationSeparateOES(modeRGB, modeAlpha) };
}

pub fn retrace_glBlendFuncSeparateOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut sfactorRGB: GLenum;
    sfactorRGB = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut dfactorRGB: GLenum;
    dfactorRGB = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut sfactorAlpha: GLenum;
    sfactorAlpha = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut dfactorAlpha: GLenum;
    dfactorAlpha = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendFuncSeparateOES(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha) };
}

pub fn retrace_glBlendEquationOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::BlendEquationOES(mode) };
}

pub fn retrace_glDrawTexfOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLfloat;
    x = (call.arg(0)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(1)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(2)).to_f32().unwrap();

    let mut width: GLfloat;
    width = (call.arg(3)).to_f32().unwrap();

    let mut height: GLfloat;
    height = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::DrawTexfOES(x, y, z, width, height) };
}

pub fn retrace_glDrawTexfvOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let coords: &mut [GLfloat];
    coords = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat270_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat270_0) = _a_GLfloat270_0 {
        for _jGLfloat270 in 0.._a_GLfloat270_0.values.len() {
    coords[_jGLfloat270] = (*_a_GLfloat270_0.values[_jGLfloat270]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DrawTexfvOES(coords) };
}

pub fn retrace_glDrawTexiOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLint;
    z = (call.arg(2)).to_i32().unwrap();

    let mut width: GLint;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLint;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::DrawTexiOES(x, y, z, width, height) };
}

pub fn retrace_glDrawTexivOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let coords: &mut [GLint];
    coords = _allocator.alloc_array::<GLint>(&call.arg(0));
    let _a_GLint268_0 = (call.arg(0)).to_array();
    if let Some(_a_GLint268_0) = _a_GLint268_0 {
        for _jGLint268 in 0.._a_GLint268_0.values.len() {
    coords[_jGLint268] = (*_a_GLint268_0.values[_jGLint268]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DrawTexivOES(coords) };
}

pub fn retrace_glDrawTexsOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLshort;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLshort;
    y = (call.arg(1)).to_i32().unwrap();

    let mut z: GLshort;
    z = (call.arg(2)).to_i32().unwrap();

    let mut width: GLshort;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLshort;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::DrawTexsOES(x, y, z, width, height) };
}

pub fn retrace_glDrawTexsvOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let coords: &mut [GLshort];
    coords = _allocator.alloc_array::<GLshort>(&call.arg(0));
    let _a_GLshort54_0 = (call.arg(0)).to_array();
    if let Some(_a_GLshort54_0) = _a_GLshort54_0 {
        for _jGLshort54 in 0.._a_GLshort54_0.values.len() {
    coords[_jGLshort54] = (*_a_GLshort54_0.values[_jGLshort54]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DrawTexsvOES(coords) };
}

pub fn retrace_glBindRenderbufferOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(1)).to_u32().unwrap();
    renderbuffer = _renderbuffer_map[renderbuffer];

    unsafe { gl::BindRenderbufferOES(target, renderbuffer) };
}

pub fn retrace_glDeleteRenderbuffersOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let renderbuffers: &mut [GLuint];
    renderbuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint265_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint265_0) = _a_GLuint265_0 {
        for _jGLuint265 in 0.._a_GLuint265_0.values.len() {
    renderbuffers[_jGLuint265] = (*_a_GLuint265_0.values[_jGLuint265]).to_u32().unwrap();
    renderbuffers[_jGLuint265] = _renderbuffer_map[renderbuffers[_jGLuint265]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteRenderbuffersOES(n, renderbuffers) };
}

pub fn retrace_glGenRenderbuffersOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let renderbuffers: &mut [GLuint];
    renderbuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenRenderbuffersOES(n, renderbuffers) };
    let _aGLuint267 = (call.arg(1)).to_array();
    if (_aGLuint267) {
        for _jGLuint267 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint267.values[_jGLuint267]).to_u32().unwrap();
    _renderbuffer_map[_origResult] = renderbuffers[_jGLuint267];
        }
    }
}

pub fn retrace_glRenderbufferStorageOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::RenderbufferStorageOES(target, internalformat, width, height) };
}

pub fn retrace_glBindFramebufferOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut framebuffer: GLuint;
    framebuffer = (call.arg(1)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    unsafe { gl::BindFramebufferOES(target, framebuffer) };
}

pub fn retrace_glDeleteFramebuffersOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let framebuffers: &mut [GLuint];
    framebuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint268_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint268_0) = _a_GLuint268_0 {
        for _jGLuint268 in 0.._a_GLuint268_0.values.len() {
    framebuffers[_jGLuint268] = (*_a_GLuint268_0.values[_jGLuint268]).to_u32().unwrap();
    framebuffers[_jGLuint268] = _framebuffer_map[framebuffers[_jGLuint268]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteFramebuffersOES(n, framebuffers) };
}

pub fn retrace_glGenFramebuffersOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let framebuffers: &mut [GLuint];
    framebuffers = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenFramebuffersOES(n, framebuffers) };
    let _aGLuint270 = (call.arg(1)).to_array();
    if (_aGLuint270) {
        for _jGLuint270 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint270.values[_jGLuint270]).to_u32().unwrap();
    _framebuffer_map[_origResult] = framebuffers[_jGLuint270];
        }
    }
}

pub fn retrace_glCheckFramebufferStatusOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::CheckFramebufferStatusOES(target) };

}

pub fn retrace_glFramebufferTexture2DOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::FramebufferTexture2DOES(target, attachment, textarget, texture, level) };
}

pub fn retrace_glFramebufferRenderbufferOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffertarget: GLenum;
    renderbuffertarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut renderbuffer: GLuint;
    renderbuffer = (call.arg(3)).to_u32().unwrap();

    unsafe { gl::FramebufferRenderbufferOES(target, attachment, renderbuffertarget, renderbuffer) };
}

pub fn retrace_glGenerateMipmapOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::GenerateMipmapOES(target) };
}

pub fn retrace_glProgramBinaryOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut program: GLuint;
    program = (call.arg(0)).to_u32().unwrap();
if glretrace::supportsARBShaderObjects {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    let mut binaryFormat: GLenum;
    binaryFormat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let binary: &mut [GLvoid];
    let binary = (call.arg(2)).to_pointer().unwrap() as *mut c_void;

    let mut length: GLsizei;
    length = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::ProgramBinaryOES(program, binaryFormat, binary, length) };
        let link_status = 0;
        gl::GetProgramiv(program, gl::LINK_STATUS, &link_status);
        if link_status == 0 {
             println!("link failed");
        }
        let info_log_length = 0;
        gl::GetProgramiv(program, gl::INFO_LOG_LENGTH, &info_log_length);
        if info_log_length > 1 {
             let infoLog = vec![0i8; info_log_length].as_mut_ptr();
             gl::GetProgramInfoLog(program, info_log_length, std::ptr::null_mut(), infoLog);
        }
}

pub fn retrace_glMapBufferOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut access: GLenum;
    access = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let _result = unsafe { gl::MapBufferOES(target, access) };

    let length = 0;
    gl::GetBufferParameteriv(target, gl::BUFFER_SIZE, &length);
    retrace::addRegion(call, (*call.ret).toUIntPtr(), _result, length);
}

pub fn retrace_glUnmapBufferOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

        GLvoid *ptr = NULL;
            glGetBufferPointervOES(target, GL_BUFFER_MAP_POINTER_OES, &ptr);
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "failed to get mapped pointer\n";
        }
    let _result = unsafe { gl::UnmapBufferOES(target) };

}

pub fn retrace_glCurrentPaletteMatrixOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::CurrentPaletteMatrixOES(index) };
}

pub fn retrace_glLoadPaletteFromModelViewMatrixOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::LoadPaletteFromModelViewMatrixOES() };
}

pub fn retrace_glMatrixIndexPointerOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::MatrixIndexPointerOES(size, _type, stride, pointer) };
}

pub fn retrace_glWeightPointerOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLint;
    size = (call.arg(0)).to_i32().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(2)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::WeightPointerOES(size, _type, stride, pointer) };
}

pub fn retrace_glPointSizePointerOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let ptr: &mut [GLvoid];
    memset(&ptr, 0, sizeof ptr); // FIXME

    if (1) {
    }
    unsafe { gl::PointSizePointerOES(_type, stride, ptr) };
}

pub fn retrace_glQueryMatrixxOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mantissa: &mut [GLfixed];
    mantissa = _allocator.alloc_array::<GLfixed>(&call.arg(0));
    let _a_GLfixed19_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfixed19_0) = _a_GLfixed19_0 {
        for _jGLfixed19 in 0.._a_GLfixed19_0.values.len() {
    mantissa[_jGLfixed19] = (*_a_GLfixed19_0.values[_jGLfixed19]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let exponent: &mut [GLint];
    exponent = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint269_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint269_0) = _a_GLint269_0 {
        for _jGLint269 in 0.._a_GLint269_0.values.len() {
    exponent[_jGLint269] = (*_a_GLint269_0.values[_jGLint269]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let _result = unsafe { gl::QueryMatrixxOES(mantissa, exponent) };

}

pub fn retrace_glClearDepthfOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut depth: GLclampf;
    depth = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::ClearDepthfOES(depth) };
}

pub fn retrace_glClipPlanefOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut plane: GLenum;
    plane = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let equation: &mut [GLfloat];
    equation = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat271_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat271_0) = _a_GLfloat271_0 {
        for _jGLfloat271 in 0.._a_GLfloat271_0.values.len() {
    equation[_jGLfloat271] = (*_a_GLfloat271_0.values[_jGLfloat271]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ClipPlanefOES(plane, equation) };
}

pub fn retrace_glDepthRangefOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLclampf;
    n = (call.arg(0)).to_f32().unwrap();

    let mut f: GLclampf;
    f = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::DepthRangefOES(n, f) };
}

pub fn retrace_glFrustumfOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut l: GLfloat;
    l = (call.arg(0)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(1)).to_f32().unwrap();

    let mut b: GLfloat;
    b = (call.arg(2)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(3)).to_f32().unwrap();

    let mut n: GLfloat;
    n = (call.arg(4)).to_f32().unwrap();

    let mut f: GLfloat;
    f = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::FrustumfOES(l, r, b, t, n, f) };
}

pub fn retrace_glOrthofOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut l: GLfloat;
    l = (call.arg(0)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(1)).to_f32().unwrap();

    let mut b: GLfloat;
    b = (call.arg(2)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(3)).to_f32().unwrap();

    let mut n: GLfloat;
    n = (call.arg(4)).to_f32().unwrap();

    let mut f: GLfloat;
    f = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::OrthofOES(l, r, b, t, n, f) };
}

pub fn retrace_glTexImage3DOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(7)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(9)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexImage3DOES(target, level, internalformat, width, height, depth, border, format, _type, pixels) };
}

pub fn retrace_glTexSubImage3DOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    let pixels = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::TexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, _type, pixels) };
}

pub fn retrace_glCopyTexSubImage3DOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut x: GLint;
    x = (call.arg(5)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(6)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(7)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(8)).to_i32().unwrap();

    unsafe { gl::CopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height) };
}

pub fn retrace_glCompressedTexImage3DOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(6)).to_i32().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(7)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(8)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexImage3DOES(target, level, internalformat, width, height, depth, border, imageSize, data) };
}

pub fn retrace_glCompressedTexSubImage3DOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(5)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(6)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut imageSize: GLsizei;
    imageSize = (call.arg(9)).to_i32().unwrap();

    let data: &mut [GLvoid];
    let data = (call.arg(10)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::CompressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data) };
}

pub fn retrace_glFramebufferTexture3DOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut textarget: GLenum;
    textarget = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(3)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(4)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::FramebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset) };
}

pub fn retrace_glTexGenfOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::TexGenfOES(coord, pname, param) };
}

pub fn retrace_glTexGenfvOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat272_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat272_0) = _a_GLfloat272_0 {
        for _jGLfloat272 in 0.._a_GLfloat272_0.values.len() {
    params[_jGLfloat272] = (*_a_GLfloat272_0.values[_jGLfloat272]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexGenfvOES(coord, pname, params) };
}

pub fn retrace_glTexGeniOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TexGeniOES(coord, pname, param) };
}

pub fn retrace_glTexGenivOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint270_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint270_0) = _a_GLint270_0 {
        for _jGLint270 in 0.._a_GLint270_0.values.len() {
    params[_jGLint270] = (*_a_GLint270_0.values[_jGLint270]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexGenivOES(coord, pname, params) };
}

pub fn retrace_glTexGenxOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfixed;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::TexGenxOES(coord, pname, param) };
}

pub fn retrace_glTexGenxvOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut coord: GLenum;
    coord = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfixed];
    params = _allocator.alloc_array::<GLfixed>(&call.arg(2));
    let _a_GLfixed20_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfixed20_0) = _a_GLfixed20_0 {
        for _jGLfixed20 in 0.._a_GLfixed20_0.values.len() {
    params[_jGLfixed20] = (*_a_GLfixed20_0.values[_jGLfixed20]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexGenxvOES(coord, pname, params) };
}

pub fn retrace_glBindVertexArrayOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut array: GLuint;
    array = (call.arg(0)).to_u32().unwrap();
    array = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][array];

    unsafe { gl::BindVertexArrayOES(array) };
}

pub fn retrace_glDeleteVertexArraysOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let arrays: &mut [GLuint];
    arrays = _allocator.alloc_array::<GLuint>(&call.arg(1));
    let _a_GLuint271_0 = (call.arg(1)).to_array();
    if let Some(_a_GLuint271_0) = _a_GLuint271_0 {
        for _jGLuint271 in 0.._a_GLuint271_0.values.len() {
    arrays[_jGLuint271] = (*_a_GLuint271_0.values[_jGLuint271]).to_u32().unwrap();
    arrays[_jGLuint271] = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][arrays[_jGLuint271]];
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DeleteVertexArraysOES(n, arrays) };
}

pub fn retrace_glGenVertexArraysOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let arrays: &mut [GLuint];
    arrays = _allocator.alloc_array::<GLuint>(&call.arg(1));

    unsafe { gl::GenVertexArraysOES(n, arrays) };
    let _aGLuint273 = (call.arg(1)).to_array();
    if (_aGLuint273) {
        for _jGLuint273 in 0..length {
    let _origResult: GLuint;
    _origResult = (_aGLuint273.values[_jGLuint273]).to_u32().unwrap();
    _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][_origResult] = arrays[_jGLuint273];
        }
    }
}

pub fn retrace_glViewportArrayvOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLuint;
    first = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat273_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat273_0) = _a_GLfloat273_0 {
        for _jGLfloat273 in 0.._a_GLfloat273_0.values.len() {
    v[_jGLfloat273] = (*_a_GLfloat273_0.values[_jGLfloat273]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ViewportArrayvOES(first, count, v) };
}

pub fn retrace_glViewportIndexedfOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(3)).to_f32().unwrap();

    let mut h: GLfloat;
    h = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::ViewportIndexedfOES(index, x, y, w, h) };
}

pub fn retrace_glViewportIndexedfvOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat274_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat274_0) = _a_GLfloat274_0 {
        for _jGLfloat274 in 0.._a_GLfloat274_0.values.len() {
    v[_jGLfloat274] = (*_a_GLfloat274_0.values[_jGLfloat274]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ViewportIndexedfvOES(index, v) };
}

pub fn retrace_glScissorArrayvOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLuint;
    first = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint271_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint271_0) = _a_GLint271_0 {
        for _jGLint271 in 0.._a_GLint271_0.values.len() {
    v[_jGLint271] = (*_a_GLint271_0.values[_jGLint271]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ScissorArrayvOES(first, count, v) };
}

pub fn retrace_glScissorIndexedOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut left: GLint;
    left = (call.arg(1)).to_i32().unwrap();

    let mut bottom: GLint;
    bottom = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::ScissorIndexedOES(index, left, bottom, width, height) };
}

pub fn retrace_glScissorIndexedvOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let v: &mut [GLint];
    v = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint272_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint272_0) = _a_GLint272_0 {
        for _jGLint272 in 0.._a_GLint272_0.values.len() {
    v[_jGLint272] = (*_a_GLint272_0.values[_jGLint272]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ScissorIndexedvOES(index, v) };
}

pub fn retrace_glDepthRangeArrayfvOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut first: GLuint;
    first = (call.arg(0)).to_u32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(1)).to_i32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat275_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat275_0) = _a_GLfloat275_0 {
        for _jGLfloat275 in 0.._a_GLfloat275_0.values.len() {
    v[_jGLfloat275] = (*_a_GLfloat275_0.values[_jGLfloat275]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DepthRangeArrayfvOES(first, count, v) };
}

pub fn retrace_glDepthRangeIndexedfOES(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut index: GLuint;
    index = (call.arg(0)).to_u32().unwrap();

    let mut n: GLfloat;
    n = (call.arg(1)).to_f32().unwrap();

    let mut f: GLfloat;
    f = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::DepthRangeIndexedfOES(index, n, f) };
}

pub fn retrace_glFramebufferTextureMultiviewOVR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    let mut baseViewIndex: GLint;
    baseViewIndex = (call.arg(4)).to_i32().unwrap();

    let mut numViews: GLsizei;
    numViews = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::FramebufferTextureMultiviewOVR(target, attachment, texture, level, baseViewIndex, numViews) };
}

pub fn retrace_glNamedFramebufferTextureMultiviewOVR(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut framebuffer: GLuint;
    framebuffer = (call.arg(0)).to_u32().unwrap();
    framebuffer = _framebuffer_map[framebuffer];

    let mut attachment: GLenum;
    attachment = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut texture: GLuint;
    texture = (call.arg(2)).to_u32().unwrap();
    texture = _texture_map[texture];

    let mut level: GLint;
    level = (call.arg(3)).to_i32().unwrap();

    let mut baseViewIndex: GLint;
    baseViewIndex = (call.arg(4)).to_i32().unwrap();

    let mut numViews: GLsizei;
    numViews = (call.arg(5)).to_i32().unwrap();

    unsafe { gl::NamedFramebufferTextureMultiviewOVR(framebuffer, attachment, texture, level, baseViewIndex, numViews) };
}

pub fn retrace_glHintPGI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mode: GLint;
    mode = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::HintPGI(target, mode) };
}

pub fn retrace_glDetailTexFuncSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let points: &mut [GLfloat];
    points = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat276_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat276_0) = _a_GLfloat276_0 {
        for _jGLfloat276 in 0.._a_GLfloat276_0.values.len() {
    points[_jGLfloat276] = (*_a_GLfloat276_0.values[_jGLfloat276]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::DetailTexFuncSGIS(target, n, points) };
}

pub fn retrace_glFogFuncSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut n: GLsizei;
    n = (call.arg(0)).to_i32().unwrap();

    let points: &mut [GLfloat];
    points = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat277_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat277_0) = _a_GLfloat277_0 {
        for _jGLfloat277 in 0.._a_GLfloat277_0.values.len() {
    points[_jGLfloat277] = (*_a_GLfloat277_0.values[_jGLfloat277]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::FogFuncSGIS(n, points) };
}

pub fn retrace_glSampleMaskSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut value: GLclampf;
    value = (call.arg(0)).to_f32().unwrap();

    let mut invert: GLboolean;
    invert = (call.arg(1)).to_u32().unwrap() as u8;

    unsafe { gl::SampleMaskSGIS(value, invert) };
}

pub fn retrace_glSamplePatternSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pattern: GLenum;
    pattern = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::SamplePatternSGIS(pattern) };
}

pub fn retrace_glPixelTexGenParameteriSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::PixelTexGenParameteriSGIS(pname, param) };
}

pub fn retrace_glPixelTexGenParameterivSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint273_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint273_0) = _a_GLint273_0 {
        for _jGLint273 in 0.._a_GLint273_0.values.len() {
    params[_jGLint273] = (*_a_GLint273_0.values[_jGLint273]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PixelTexGenParameterivSGIS(pname, params) };
}

pub fn retrace_glPixelTexGenParameterfSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PixelTexGenParameterfSGIS(pname, param) };
}

pub fn retrace_glPixelTexGenParameterfvSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat278_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat278_0) = _a_GLfloat278_0 {
        for _jGLfloat278 in 0.._a_GLfloat278_0.values.len() {
    params[_jGLfloat278] = (*_a_GLfloat278_0.values[_jGLfloat278]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PixelTexGenParameterfvSGIS(pname, params) };
}

pub fn retrace_glPointParameterfSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::PointParameterfSGIS(pname, param) };
}

pub fn retrace_glPointParameterfvSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat279_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat279_0) = _a_GLfloat279_0 {
        for _jGLfloat279 in 0.._a_GLfloat279_0.values.len() {
    params[_jGLfloat279] = (*_a_GLfloat279_0.values[_jGLfloat279]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::PointParameterfvSGIS(pname, params) };
}

pub fn retrace_glSharpenTexFuncSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut n: GLsizei;
    n = (call.arg(1)).to_i32().unwrap();

    let points: &mut [GLfloat];
    points = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat280_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat280_0) = _a_GLfloat280_0 {
        for _jGLfloat280 in 0.._a_GLfloat280_0.values.len() {
    points[_jGLfloat280] = (*_a_GLfloat280_0.values[_jGLfloat280]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SharpenTexFuncSGIS(target, n, points) };
}

pub fn retrace_glTexImage4DSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(2)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(4)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(5)).to_i32().unwrap();

    let mut size4d: GLsizei;
    size4d = (call.arg(6)).to_i32().unwrap();

    let mut border: GLint;
    border = (call.arg(7)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(8)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(9)).to_u32().unwrap().try_into().unwrap();

    memset(&pixels, 0, sizeof pixels); // FIXME

    if (1) {
    }
    unsafe { gl::TexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, _type, pixels) };
}

pub fn retrace_glTexSubImage4DSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut level: GLint;
    level = (call.arg(1)).to_i32().unwrap();

    let mut xoffset: GLint;
    xoffset = (call.arg(2)).to_i32().unwrap();

    let mut yoffset: GLint;
    yoffset = (call.arg(3)).to_i32().unwrap();

    let mut zoffset: GLint;
    zoffset = (call.arg(4)).to_i32().unwrap();

    let mut woffset: GLint;
    woffset = (call.arg(5)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(6)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(7)).to_i32().unwrap();

    let mut depth: GLsizei;
    depth = (call.arg(8)).to_i32().unwrap();

    let mut size4d: GLsizei;
    size4d = (call.arg(9)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(10)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(11)).to_u32().unwrap().try_into().unwrap();

    memset(&pixels, 0, sizeof pixels); // FIXME

    if (1) {
    }
    unsafe { gl::TexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, _type, pixels) };
}

pub fn retrace_glTextureColorMaskSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut red: GLboolean;
    red = (call.arg(0)).to_u32().unwrap() as u8;

    let mut green: GLboolean;
    green = (call.arg(1)).to_u32().unwrap() as u8;

    let mut blue: GLboolean;
    blue = (call.arg(2)).to_u32().unwrap() as u8;

    let mut alpha: GLboolean;
    alpha = (call.arg(3)).to_u32().unwrap() as u8;

    unsafe { gl::TextureColorMaskSGIS(red, green, blue, alpha) };
}

pub fn retrace_glTexFilterFuncSGIS(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut filter: GLenum;
    filter = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut n: GLsizei;
    n = (call.arg(2)).to_i32().unwrap();

    let weights: &mut [GLfloat];
    weights = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat281_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat281_0) = _a_GLfloat281_0 {
        for _jGLfloat281 in 0.._a_GLfloat281_0.values.len() {
    weights[_jGLfloat281] = (*_a_GLfloat281_0.values[_jGLfloat281]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexFilterFuncSGIS(target, filter, n, weights) };
}

pub fn retrace_glAsyncMarkerSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut marker: GLuint;
    marker = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::AsyncMarkerSGIX(marker) };
}

pub fn retrace_glFinishAsyncSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let markerp: &mut [GLuint];
    markerp = _allocator.alloc_array::<GLuint>(&call.arg(0));

    let _result = unsafe { gl::FinishAsyncSGIX(markerp) };

    let _aPGLuint39 = (call.arg(0)).to_array();
    if (_aPGLuint39) {
    }
}

pub fn retrace_glPollAsyncSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let markerp: &mut [GLuint];
    markerp = _allocator.alloc_array::<GLuint>(&call.arg(0));

    let _result = unsafe { gl::PollAsyncSGIX(markerp) };

    let _aPGLuint40 = (call.arg(0)).to_array();
    if (_aPGLuint40) {
    }
}

pub fn retrace_glGenAsyncMarkersSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut range: GLsizei;
    range = (call.arg(0)).to_i32().unwrap();

    let _result = unsafe { gl::GenAsyncMarkersSGIX(range) };

}

pub fn retrace_glDeleteAsyncMarkersSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut marker: GLuint;
    marker = (call.arg(0)).to_u32().unwrap();

    let mut range: GLsizei;
    range = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::DeleteAsyncMarkersSGIX(marker, range) };
}

pub fn retrace_glFlushRasterSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::FlushRasterSGIX() };
}

pub fn retrace_glFragmentColorMaterialSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut mode: GLenum;
    mode = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::FragmentColorMaterialSGIX(face, mode) };
}

pub fn retrace_glFragmentLightfSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::FragmentLightfSGIX(light, pname, param) };
}

pub fn retrace_glFragmentLightfvSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat282_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat282_0) = _a_GLfloat282_0 {
        for _jGLfloat282 in 0.._a_GLfloat282_0.values.len() {
    params[_jGLfloat282] = (*_a_GLfloat282_0.values[_jGLfloat282]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::FragmentLightfvSGIX(light, pname, params) };
}

pub fn retrace_glFragmentLightiSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::FragmentLightiSGIX(light, pname, param) };
}

pub fn retrace_glFragmentLightivSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut light: GLenum;
    light = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint274_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint274_0) = _a_GLint274_0 {
        for _jGLint274 in 0.._a_GLint274_0.values.len() {
    params[_jGLint274] = (*_a_GLint274_0.values[_jGLint274]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::FragmentLightivSGIX(light, pname, params) };
}

pub fn retrace_glFragmentLightModelfSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::FragmentLightModelfSGIX(pname, param) };
}

pub fn retrace_glFragmentLightModelfvSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat283_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat283_0) = _a_GLfloat283_0 {
        for _jGLfloat283 in 0.._a_GLfloat283_0.values.len() {
    params[_jGLfloat283] = (*_a_GLfloat283_0.values[_jGLfloat283]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::FragmentLightModelfvSGIX(pname, params) };
}

pub fn retrace_glFragmentLightModeliSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::FragmentLightModeliSGIX(pname, param) };
}

pub fn retrace_glFragmentLightModelivSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint275_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint275_0) = _a_GLint275_0 {
        for _jGLint275 in 0.._a_GLint275_0.values.len() {
    params[_jGLint275] = (*_a_GLint275_0.values[_jGLint275]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::FragmentLightModelivSGIX(pname, params) };
}

pub fn retrace_glFragmentMaterialfSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::FragmentMaterialfSGIX(face, pname, param) };
}

pub fn retrace_glFragmentMaterialfvSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat284_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat284_0) = _a_GLfloat284_0 {
        for _jGLfloat284 in 0.._a_GLfloat284_0.values.len() {
    params[_jGLfloat284] = (*_a_GLfloat284_0.values[_jGLfloat284]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::FragmentMaterialfvSGIX(face, pname, params) };
}

pub fn retrace_glFragmentMaterialiSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::FragmentMaterialiSGIX(face, pname, param) };
}

pub fn retrace_glFragmentMaterialivSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut face: GLenum;
    face = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint276_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint276_0) = _a_GLint276_0 {
        for _jGLint276 in 0.._a_GLint276_0.values.len() {
    params[_jGLint276] = (*_a_GLint276_0.values[_jGLint276]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::FragmentMaterialivSGIX(face, pname, params) };
}

pub fn retrace_glLightEnviSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::LightEnviSGIX(pname, param) };
}

pub fn retrace_glFrameZoomSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLint;
    factor = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::FrameZoomSGIX(factor) };
}

pub fn retrace_glIglooInterfaceSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLvoid];
    memset(&params, 0, sizeof params); // FIXME

    if (1) {
    }
    unsafe { gl::IglooInterfaceSGIX(pname, params) };
}

pub fn retrace_glInstrumentsBufferSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut size: GLsizei;
    size = (call.arg(0)).to_i32().unwrap();

    let buffer: &mut [GLint];
    memset(&buffer, 0, sizeof buffer); // FIXME

    if (1) {
    }
    unsafe { gl::InstrumentsBufferSGIX(size, buffer) };
}

pub fn retrace_glPollInstrumentsSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let marker_p: &mut [GLint];
    marker_p = _allocator.alloc_array::<GLint>(&call.arg(0));

    let _result = unsafe { gl::PollInstrumentsSGIX(marker_p) };

    let _aPGLint28 = (call.arg(0)).to_array();
    if (_aPGLint28) {
    }
}

pub fn retrace_glReadInstrumentsSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut marker: GLint;
    marker = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::ReadInstrumentsSGIX(marker) };
}

pub fn retrace_glStartInstrumentsSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::StartInstrumentsSGIX() };
}

pub fn retrace_glStopInstrumentsSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut marker: GLint;
    marker = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::StopInstrumentsSGIX(marker) };
}

pub fn retrace_glListParameterfSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut list: GLuint;
    list = (call.arg(0)).to_u32().unwrap();
    list = _list_map[list];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(2)).to_f32().unwrap();

    unsafe { gl::ListParameterfSGIX(list, pname, param) };
}

pub fn retrace_glListParameterfvSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut list: GLuint;
    list = (call.arg(0)).to_u32().unwrap();
    list = _list_map[list];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat285_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat285_0) = _a_GLfloat285_0 {
        for _jGLfloat285 in 0.._a_GLfloat285_0.values.len() {
    params[_jGLfloat285] = (*_a_GLfloat285_0.values[_jGLfloat285]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ListParameterfvSGIX(list, pname, params) };
}

pub fn retrace_glListParameteriSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut list: GLuint;
    list = (call.arg(0)).to_u32().unwrap();
    list = _list_map[list];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(2)).to_i32().unwrap();

    unsafe { gl::ListParameteriSGIX(list, pname, param) };
}

pub fn retrace_glListParameterivSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut list: GLuint;
    list = (call.arg(0)).to_u32().unwrap();
    list = _list_map[list];

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint277_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint277_0) = _a_GLint277_0 {
        for _jGLint277 in 0.._a_GLint277_0.values.len() {
    params[_jGLint277] = (*_a_GLint277_0.values[_jGLint277]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ListParameterivSGIX(list, pname, params) };
}

pub fn retrace_glPixelTexGenSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    unsafe { gl::PixelTexGenSGIX(mode) };
}

pub fn retrace_glDeformationMap3dSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut u1: GLdouble;
    u1 = (call.arg(1)).to_f64().unwrap();

    let mut u2: GLdouble;
    u2 = (call.arg(2)).to_f64().unwrap();

    let mut ustride: GLint;
    ustride = (call.arg(3)).to_i32().unwrap();

    let mut uorder: GLint;
    uorder = (call.arg(4)).to_i32().unwrap();

    let mut v1: GLdouble;
    v1 = (call.arg(5)).to_f64().unwrap();

    let mut v2: GLdouble;
    v2 = (call.arg(6)).to_f64().unwrap();

    let mut vstride: GLint;
    vstride = (call.arg(7)).to_i32().unwrap();

    let mut vorder: GLint;
    vorder = (call.arg(8)).to_i32().unwrap();

    let mut w1: GLdouble;
    w1 = (call.arg(9)).to_f64().unwrap();

    let mut w2: GLdouble;
    w2 = (call.arg(10)).to_f64().unwrap();

    let mut wstride: GLint;
    wstride = (call.arg(11)).to_i32().unwrap();

    let mut worder: GLint;
    worder = (call.arg(12)).to_i32().unwrap();

    let points: &mut [GLdouble];
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    }
    unsafe { gl::DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points) };
}

pub fn retrace_glDeformationMap3fSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut u1: GLfloat;
    u1 = (call.arg(1)).to_f32().unwrap();

    let mut u2: GLfloat;
    u2 = (call.arg(2)).to_f32().unwrap();

    let mut ustride: GLint;
    ustride = (call.arg(3)).to_i32().unwrap();

    let mut uorder: GLint;
    uorder = (call.arg(4)).to_i32().unwrap();

    let mut v1: GLfloat;
    v1 = (call.arg(5)).to_f32().unwrap();

    let mut v2: GLfloat;
    v2 = (call.arg(6)).to_f32().unwrap();

    let mut vstride: GLint;
    vstride = (call.arg(7)).to_i32().unwrap();

    let mut vorder: GLint;
    vorder = (call.arg(8)).to_i32().unwrap();

    let mut w1: GLfloat;
    w1 = (call.arg(9)).to_f32().unwrap();

    let mut w2: GLfloat;
    w2 = (call.arg(10)).to_f32().unwrap();

    let mut wstride: GLint;
    wstride = (call.arg(11)).to_i32().unwrap();

    let mut worder: GLint;
    worder = (call.arg(12)).to_i32().unwrap();

    let points: &mut [GLfloat];
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    }
    unsafe { gl::DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points) };
}

pub fn retrace_glDeformSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLbitfield;
    mask = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::DeformSGIX(mask) };
}

pub fn retrace_glLoadIdentityDeformationMapSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mask: GLbitfield;
    mask = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::LoadIdentityDeformationMapSGIX(mask) };
}

pub fn retrace_glReferencePlaneSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let equation: &mut [GLdouble];
    equation = _allocator.alloc_array::<GLdouble>(&call.arg(0));
    let _a_GLdouble144_0 = (call.arg(0)).to_array();
    if let Some(_a_GLdouble144_0) = _a_GLdouble144_0 {
        for _jGLdouble144 in 0.._a_GLdouble144_0.values.len() {
    equation[_jGLdouble144] = (*_a_GLdouble144_0.values[_jGLdouble144]).to_f64().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ReferencePlaneSGIX(equation) };
}

pub fn retrace_glSpriteParameterfSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLfloat;
    param = (call.arg(1)).to_f32().unwrap();

    unsafe { gl::SpriteParameterfSGIX(pname, param) };
}

pub fn retrace_glSpriteParameterfvSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat286_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat286_0) = _a_GLfloat286_0 {
        for _jGLfloat286 in 0.._a_GLfloat286_0.values.len() {
    params[_jGLfloat286] = (*_a_GLfloat286_0.values[_jGLfloat286]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SpriteParameterfvSGIX(pname, params) };
}

pub fn retrace_glSpriteParameteriSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut param: GLint;
    param = (call.arg(1)).to_i32().unwrap();

    unsafe { gl::SpriteParameteriSGIX(pname, param) };
}

pub fn retrace_glSpriteParameterivSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut pname: GLenum;
    pname = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(1));
    let _a_GLint278_0 = (call.arg(1)).to_array();
    if let Some(_a_GLint278_0) = _a_GLint278_0 {
        for _jGLint278 in 0.._a_GLint278_0.values.len() {
    params[_jGLint278] = (*_a_GLint278_0.values[_jGLint278]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::SpriteParameterivSGIX(pname, params) };
}

pub fn retrace_glTagSampleBufferSGIX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::TagSampleBufferSGIX() };
}

pub fn retrace_glColorTableSGI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut format: GLenum;
    format = (call.arg(3)).to_u32().unwrap().try_into().unwrap();

    let mut _type: GLenum;
    _type = (call.arg(4)).to_u32().unwrap().try_into().unwrap();

    let table: &mut [GLvoid];
    let table = (call.arg(5)).to_pointer().unwrap() as *mut c_void;

    unsafe { gl::ColorTableSGI(target, internalformat, width, format, _type, table) };
}

pub fn retrace_glColorTableParameterfvSGI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLfloat];
    params = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat287_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat287_0) = _a_GLfloat287_0 {
        for _jGLfloat287 in 0.._a_GLfloat287_0.values.len() {
    params[_jGLfloat287] = (*_a_GLfloat287_0.values[_jGLfloat287]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ColorTableParameterfvSGI(target, pname, params) };
}

pub fn retrace_glColorTableParameterivSGI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut pname: GLenum;
    pname = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let params: &mut [GLint];
    params = _allocator.alloc_array::<GLint>(&call.arg(2));
    let _a_GLint279_0 = (call.arg(2)).to_array();
    if let Some(_a_GLint279_0) = _a_GLint279_0 {
        for _jGLint279 in 0.._a_GLint279_0.values.len() {
    params[_jGLint279] = (*_a_GLint279_0.values[_jGLint279]).to_i32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ColorTableParameterivSGI(target, pname, params) };
}

pub fn retrace_glCopyColorTableSGI(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut target: GLenum;
    target = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut internalformat: GLenum;
    internalformat = (call.arg(1)).to_u32().unwrap().try_into().unwrap();

    let mut x: GLint;
    x = (call.arg(2)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(3)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(4)).to_i32().unwrap();

    unsafe { gl::CopyColorTableSGI(target, internalformat, x, y, width) };
}

pub fn retrace_glFinishTextureSUNX(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    unsafe { gl::FinishTextureSUNX() };
}

pub fn retrace_glGlobalAlphaFactorbSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLbyte;
    factor = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::GlobalAlphaFactorbSUN(factor) };
}

pub fn retrace_glGlobalAlphaFactorsSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLshort;
    factor = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::GlobalAlphaFactorsSUN(factor) };
}

pub fn retrace_glGlobalAlphaFactoriSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLint;
    factor = (call.arg(0)).to_i32().unwrap();

    unsafe { gl::GlobalAlphaFactoriSUN(factor) };
}

pub fn retrace_glGlobalAlphaFactorfSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLfloat;
    factor = (call.arg(0)).to_f32().unwrap();

    unsafe { gl::GlobalAlphaFactorfSUN(factor) };
}

pub fn retrace_glGlobalAlphaFactordSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLdouble;
    factor = (call.arg(0)).to_f64().unwrap();

    unsafe { gl::GlobalAlphaFactordSUN(factor) };
}

pub fn retrace_glGlobalAlphaFactorubSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLubyte;
    factor = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::GlobalAlphaFactorubSUN(factor) };
}

pub fn retrace_glGlobalAlphaFactorusSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLushort;
    factor = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::GlobalAlphaFactorusSUN(factor) };
}

pub fn retrace_glGlobalAlphaFactoruiSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut factor: GLuint;
    factor = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::GlobalAlphaFactoruiSUN(factor) };
}

pub fn retrace_glDrawMeshArraysSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut mode: GLenum;
    mode = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut first: GLint;
    first = (call.arg(1)).to_i32().unwrap();

    let mut count: GLsizei;
    count = (call.arg(2)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::DrawMeshArraysSUN(mode, first, count, width) };
}

pub fn retrace_glReplacementCodeuiSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut code: GLuint;
    code = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::ReplacementCodeuiSUN(code) };
}

pub fn retrace_glReplacementCodeusSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut code: GLushort;
    code = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::ReplacementCodeusSUN(code) };
}

pub fn retrace_glReplacementCodeubSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut code: GLubyte;
    code = (call.arg(0)).to_u32().unwrap();

    unsafe { gl::ReplacementCodeubSUN(code) };
}

pub fn retrace_glReplacementCodeuivSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let code: &mut [GLuint];
    memset(&code, 0, sizeof code); // FIXME

    if (1) {
    }
    unsafe { gl::ReplacementCodeuivSUN(code) };
}

pub fn retrace_glReplacementCodeusvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let code: &mut [GLushort];
    memset(&code, 0, sizeof code); // FIXME

    if (1) {
    }
    unsafe { gl::ReplacementCodeusvSUN(code) };
}

pub fn retrace_glReplacementCodeubvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let code: &mut [GLubyte];
    memset(&code, 0, sizeof code); // FIXME

    if (1) {
    }
    unsafe { gl::ReplacementCodeubvSUN(code) };
}

pub fn retrace_glReplacementCodePointerSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut _type: GLenum;
    _type = (call.arg(0)).to_u32().unwrap().try_into().unwrap();

    let mut stride: GLsizei;
    stride = (call.arg(1)).to_i32().unwrap();

    let pointer: &mut [GLvoid];
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    }
    unsafe { gl::ReplacementCodePointerSUN(_type, stride, pointer) };
}

pub fn retrace_glColor4ubVertex2fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut r: GLubyte;
    r = (call.arg(0)).to_u32().unwrap();

    let mut g: GLubyte;
    g = (call.arg(1)).to_u32().unwrap();

    let mut b: GLubyte;
    b = (call.arg(2)).to_u32().unwrap();

    let mut a: GLubyte;
    a = (call.arg(3)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(4)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::Color4ubVertex2fSUN(r, g, b, a, x, y) };
}

pub fn retrace_glColor4ubVertex2fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let c: &mut [GLubyte];
    c = _allocator.alloc_array::<GLubyte>(&call.arg(0));
    let _a_GLubyte25_0 = (call.arg(0)).to_array();
    if let Some(_a_GLubyte25_0) = _a_GLubyte25_0 {
        for _jGLubyte25 in 0.._a_GLubyte25_0.values.len() {
    c[_jGLubyte25] = (*_a_GLubyte25_0.values[_jGLubyte25]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat288_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat288_0) = _a_GLfloat288_0 {
        for _jGLfloat288 in 0.._a_GLfloat288_0.values.len() {
    v[_jGLfloat288] = (*_a_GLfloat288_0.values[_jGLfloat288]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4ubVertex2fvSUN(c, v) };
}

pub fn retrace_glColor4ubVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut r: GLubyte;
    r = (call.arg(0)).to_u32().unwrap();

    let mut g: GLubyte;
    g = (call.arg(1)).to_u32().unwrap();

    let mut b: GLubyte;
    b = (call.arg(2)).to_u32().unwrap();

    let mut a: GLubyte;
    a = (call.arg(3)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(4)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(5)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(6)).to_f32().unwrap();

    unsafe { gl::Color4ubVertex3fSUN(r, g, b, a, x, y, z) };
}

pub fn retrace_glColor4ubVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let c: &mut [GLubyte];
    c = _allocator.alloc_array::<GLubyte>(&call.arg(0));
    let _a_GLubyte26_0 = (call.arg(0)).to_array();
    if let Some(_a_GLubyte26_0) = _a_GLubyte26_0 {
        for _jGLubyte26 in 0.._a_GLubyte26_0.values.len() {
    c[_jGLubyte26] = (*_a_GLubyte26_0.values[_jGLubyte26]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat289_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat289_0) = _a_GLfloat289_0 {
        for _jGLfloat289 in 0.._a_GLfloat289_0.values.len() {
    v[_jGLfloat289] = (*_a_GLfloat289_0.values[_jGLfloat289]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4ubVertex3fvSUN(c, v) };
}

pub fn retrace_glColor3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut r: GLfloat;
    r = (call.arg(0)).to_f32().unwrap();

    let mut g: GLfloat;
    g = (call.arg(1)).to_f32().unwrap();

    let mut b: GLfloat;
    b = (call.arg(2)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(3)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(4)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::Color3fVertex3fSUN(r, g, b, x, y, z) };
}

pub fn retrace_glColor3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let c: &mut [GLfloat];
    c = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat290_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat290_0) = _a_GLfloat290_0 {
        for _jGLfloat290 in 0.._a_GLfloat290_0.values.len() {
    c[_jGLfloat290] = (*_a_GLfloat290_0.values[_jGLfloat290]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat291_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat291_0) = _a_GLfloat291_0 {
        for _jGLfloat291 in 0.._a_GLfloat291_0.values.len() {
    v[_jGLfloat291] = (*_a_GLfloat291_0.values[_jGLfloat291]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color3fVertex3fvSUN(c, v) };
}

pub fn retrace_glNormal3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut nx: GLfloat;
    nx = (call.arg(0)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(1)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(2)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(3)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(4)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::Normal3fVertex3fSUN(nx, ny, nz, x, y, z) };
}

pub fn retrace_glNormal3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let n: &mut [GLfloat];
    n = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat292_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat292_0) = _a_GLfloat292_0 {
        for _jGLfloat292 in 0.._a_GLfloat292_0.values.len() {
    n[_jGLfloat292] = (*_a_GLfloat292_0.values[_jGLfloat292]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat293_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat293_0) = _a_GLfloat293_0 {
        for _jGLfloat293 in 0.._a_GLfloat293_0.values.len() {
    v[_jGLfloat293] = (*_a_GLfloat293_0.values[_jGLfloat293]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Normal3fVertex3fvSUN(n, v) };
}

pub fn retrace_glColor4fNormal3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut r: GLfloat;
    r = (call.arg(0)).to_f32().unwrap();

    let mut g: GLfloat;
    g = (call.arg(1)).to_f32().unwrap();

    let mut b: GLfloat;
    b = (call.arg(2)).to_f32().unwrap();

    let mut a: GLfloat;
    a = (call.arg(3)).to_f32().unwrap();

    let mut nx: GLfloat;
    nx = (call.arg(4)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(5)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(6)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(7)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(8)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(9)).to_f32().unwrap();

    unsafe { gl::Color4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z) };
}

pub fn retrace_glColor4fNormal3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let c: &mut [GLfloat];
    c = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat294_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat294_0) = _a_GLfloat294_0 {
        for _jGLfloat294 in 0.._a_GLfloat294_0.values.len() {
    c[_jGLfloat294] = (*_a_GLfloat294_0.values[_jGLfloat294]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let n: &mut [GLfloat];
    n = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat295_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat295_0) = _a_GLfloat295_0 {
        for _jGLfloat295 in 0.._a_GLfloat295_0.values.len() {
    n[_jGLfloat295] = (*_a_GLfloat295_0.values[_jGLfloat295]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat296_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat296_0) = _a_GLfloat296_0 {
        for _jGLfloat296 in 0.._a_GLfloat296_0.values.len() {
    v[_jGLfloat296] = (*_a_GLfloat296_0.values[_jGLfloat296]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::Color4fNormal3fVertex3fvSUN(c, n, v) };
}

pub fn retrace_glTexCoord2fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(1)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(2)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(3)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(4)).to_f32().unwrap();

    unsafe { gl::TexCoord2fVertex3fSUN(s, t, x, y, z) };
}

pub fn retrace_glTexCoord2fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let tc: &mut [GLfloat];
    tc = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat297_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat297_0) = _a_GLfloat297_0 {
        for _jGLfloat297 in 0.._a_GLfloat297_0.values.len() {
    tc[_jGLfloat297] = (*_a_GLfloat297_0.values[_jGLfloat297]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat298_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat298_0) = _a_GLfloat298_0 {
        for _jGLfloat298 in 0.._a_GLfloat298_0.values.len() {
    v[_jGLfloat298] = (*_a_GLfloat298_0.values[_jGLfloat298]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord2fVertex3fvSUN(tc, v) };
}

pub fn retrace_glTexCoord4fVertex4fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(1)).to_f32().unwrap();

    let mut p: GLfloat;
    p = (call.arg(2)).to_f32().unwrap();

    let mut q: GLfloat;
    q = (call.arg(3)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(4)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(5)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(6)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(7)).to_f32().unwrap();

    unsafe { gl::TexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w) };
}

pub fn retrace_glTexCoord4fVertex4fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let tc: &mut [GLfloat];
    tc = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat299_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat299_0) = _a_GLfloat299_0 {
        for _jGLfloat299 in 0.._a_GLfloat299_0.values.len() {
    tc[_jGLfloat299] = (*_a_GLfloat299_0.values[_jGLfloat299]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat300_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat300_0) = _a_GLfloat300_0 {
        for _jGLfloat300 in 0.._a_GLfloat300_0.values.len() {
    v[_jGLfloat300] = (*_a_GLfloat300_0.values[_jGLfloat300]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord4fVertex4fvSUN(tc, v) };
}

pub fn retrace_glTexCoord2fColor4ubVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(1)).to_f32().unwrap();

    let mut r: GLubyte;
    r = (call.arg(2)).to_u32().unwrap();

    let mut g: GLubyte;
    g = (call.arg(3)).to_u32().unwrap();

    let mut b: GLubyte;
    b = (call.arg(4)).to_u32().unwrap();

    let mut a: GLubyte;
    a = (call.arg(5)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(6)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(7)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(8)).to_f32().unwrap();

    unsafe { gl::TexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z) };
}

pub fn retrace_glTexCoord2fColor4ubVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let tc: &mut [GLfloat];
    tc = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat301_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat301_0) = _a_GLfloat301_0 {
        for _jGLfloat301 in 0.._a_GLfloat301_0.values.len() {
    tc[_jGLfloat301] = (*_a_GLfloat301_0.values[_jGLfloat301]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let c: &mut [GLubyte];
    c = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte27_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte27_0) = _a_GLubyte27_0 {
        for _jGLubyte27 in 0.._a_GLubyte27_0.values.len() {
    c[_jGLubyte27] = (*_a_GLubyte27_0.values[_jGLubyte27]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat302_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat302_0) = _a_GLfloat302_0 {
        for _jGLfloat302 in 0.._a_GLfloat302_0.values.len() {
    v[_jGLfloat302] = (*_a_GLfloat302_0.values[_jGLfloat302]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord2fColor4ubVertex3fvSUN(tc, c, v) };
}

pub fn retrace_glTexCoord2fColor3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(1)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(2)).to_f32().unwrap();

    let mut g: GLfloat;
    g = (call.arg(3)).to_f32().unwrap();

    let mut b: GLfloat;
    b = (call.arg(4)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(5)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(6)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(7)).to_f32().unwrap();

    unsafe { gl::TexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z) };
}

pub fn retrace_glTexCoord2fColor3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let tc: &mut [GLfloat];
    tc = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat303_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat303_0) = _a_GLfloat303_0 {
        for _jGLfloat303 in 0.._a_GLfloat303_0.values.len() {
    tc[_jGLfloat303] = (*_a_GLfloat303_0.values[_jGLfloat303]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let c: &mut [GLfloat];
    c = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat304_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat304_0) = _a_GLfloat304_0 {
        for _jGLfloat304 in 0.._a_GLfloat304_0.values.len() {
    c[_jGLfloat304] = (*_a_GLfloat304_0.values[_jGLfloat304]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat305_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat305_0) = _a_GLfloat305_0 {
        for _jGLfloat305 in 0.._a_GLfloat305_0.values.len() {
    v[_jGLfloat305] = (*_a_GLfloat305_0.values[_jGLfloat305]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord2fColor3fVertex3fvSUN(tc, c, v) };
}

pub fn retrace_glTexCoord2fNormal3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(1)).to_f32().unwrap();

    let mut nx: GLfloat;
    nx = (call.arg(2)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(3)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(4)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(5)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(6)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(7)).to_f32().unwrap();

    unsafe { gl::TexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z) };
}

pub fn retrace_glTexCoord2fNormal3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let tc: &mut [GLfloat];
    tc = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat306_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat306_0) = _a_GLfloat306_0 {
        for _jGLfloat306 in 0.._a_GLfloat306_0.values.len() {
    tc[_jGLfloat306] = (*_a_GLfloat306_0.values[_jGLfloat306]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let n: &mut [GLfloat];
    n = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat307_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat307_0) = _a_GLfloat307_0 {
        for _jGLfloat307 in 0.._a_GLfloat307_0.values.len() {
    n[_jGLfloat307] = (*_a_GLfloat307_0.values[_jGLfloat307]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat308_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat308_0) = _a_GLfloat308_0 {
        for _jGLfloat308 in 0.._a_GLfloat308_0.values.len() {
    v[_jGLfloat308] = (*_a_GLfloat308_0.values[_jGLfloat308]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord2fNormal3fVertex3fvSUN(tc, n, v) };
}

pub fn retrace_glTexCoord2fColor4fNormal3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(1)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(2)).to_f32().unwrap();

    let mut g: GLfloat;
    g = (call.arg(3)).to_f32().unwrap();

    let mut b: GLfloat;
    b = (call.arg(4)).to_f32().unwrap();

    let mut a: GLfloat;
    a = (call.arg(5)).to_f32().unwrap();

    let mut nx: GLfloat;
    nx = (call.arg(6)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(7)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(8)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(9)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(10)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(11)).to_f32().unwrap();

    unsafe { gl::TexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z) };
}

pub fn retrace_glTexCoord2fColor4fNormal3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let tc: &mut [GLfloat];
    tc = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat309_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat309_0) = _a_GLfloat309_0 {
        for _jGLfloat309 in 0.._a_GLfloat309_0.values.len() {
    tc[_jGLfloat309] = (*_a_GLfloat309_0.values[_jGLfloat309]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let c: &mut [GLfloat];
    c = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat310_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat310_0) = _a_GLfloat310_0 {
        for _jGLfloat310 in 0.._a_GLfloat310_0.values.len() {
    c[_jGLfloat310] = (*_a_GLfloat310_0.values[_jGLfloat310]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let n: &mut [GLfloat];
    n = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat311_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat311_0) = _a_GLfloat311_0 {
        for _jGLfloat311 in 0.._a_GLfloat311_0.values.len() {
    n[_jGLfloat311] = (*_a_GLfloat311_0.values[_jGLfloat311]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat312_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat312_0) = _a_GLfloat312_0 {
        for _jGLfloat312 in 0.._a_GLfloat312_0.values.len() {
    v[_jGLfloat312] = (*_a_GLfloat312_0.values[_jGLfloat312]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v) };
}

pub fn retrace_glTexCoord4fColor4fNormal3fVertex4fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut s: GLfloat;
    s = (call.arg(0)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(1)).to_f32().unwrap();

    let mut p: GLfloat;
    p = (call.arg(2)).to_f32().unwrap();

    let mut q: GLfloat;
    q = (call.arg(3)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(4)).to_f32().unwrap();

    let mut g: GLfloat;
    g = (call.arg(5)).to_f32().unwrap();

    let mut b: GLfloat;
    b = (call.arg(6)).to_f32().unwrap();

    let mut a: GLfloat;
    a = (call.arg(7)).to_f32().unwrap();

    let mut nx: GLfloat;
    nx = (call.arg(8)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(9)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(10)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(11)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(12)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(13)).to_f32().unwrap();

    let mut w: GLfloat;
    w = (call.arg(14)).to_f32().unwrap();

    unsafe { gl::TexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w) };
}

pub fn retrace_glTexCoord4fColor4fNormal3fVertex4fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let tc: &mut [GLfloat];
    tc = _allocator.alloc_array::<GLfloat>(&call.arg(0));
    let _a_GLfloat313_0 = (call.arg(0)).to_array();
    if let Some(_a_GLfloat313_0) = _a_GLfloat313_0 {
        for _jGLfloat313 in 0.._a_GLfloat313_0.values.len() {
    tc[_jGLfloat313] = (*_a_GLfloat313_0.values[_jGLfloat313]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let c: &mut [GLfloat];
    c = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat314_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat314_0) = _a_GLfloat314_0 {
        for _jGLfloat314 in 0.._a_GLfloat314_0.values.len() {
    c[_jGLfloat314] = (*_a_GLfloat314_0.values[_jGLfloat314]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let n: &mut [GLfloat];
    n = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat315_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat315_0) = _a_GLfloat315_0 {
        for _jGLfloat315 in 0.._a_GLfloat315_0.values.len() {
    n[_jGLfloat315] = (*_a_GLfloat315_0.values[_jGLfloat315]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat316_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat316_0) = _a_GLfloat316_0 {
        for _jGLfloat316 in 0.._a_GLfloat316_0.values.len() {
    v[_jGLfloat316] = (*_a_GLfloat316_0.values[_jGLfloat316]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v) };
}

pub fn retrace_glReplacementCodeuiVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut rc: GLuint;
    rc = (call.arg(0)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(1)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(2)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(3)).to_f32().unwrap();

    unsafe { gl::ReplacementCodeuiVertex3fSUN(rc, x, y, z) };
}

pub fn retrace_glReplacementCodeuiVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let rc: &mut [GLuint];
    rc = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_PGLuint62_0 = (call.arg(0)).to_array().unwrap();
    rc[0] = (_a_PGLuint62_0.values[0]).to_u32().unwrap();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat317_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat317_0) = _a_GLfloat317_0 {
        for _jGLfloat317 in 0.._a_GLfloat317_0.values.len() {
    v[_jGLfloat317] = (*_a_GLfloat317_0.values[_jGLfloat317]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ReplacementCodeuiVertex3fvSUN(rc, v) };
}

pub fn retrace_glReplacementCodeuiColor4ubVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut rc: GLuint;
    rc = (call.arg(0)).to_u32().unwrap();

    let mut r: GLubyte;
    r = (call.arg(1)).to_u32().unwrap();

    let mut g: GLubyte;
    g = (call.arg(2)).to_u32().unwrap();

    let mut b: GLubyte;
    b = (call.arg(3)).to_u32().unwrap();

    let mut a: GLubyte;
    a = (call.arg(4)).to_u32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(5)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(6)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(7)).to_f32().unwrap();

    unsafe { gl::ReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z) };
}

pub fn retrace_glReplacementCodeuiColor4ubVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let rc: &mut [GLuint];
    rc = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_PGLuint63_0 = (call.arg(0)).to_array().unwrap();
    rc[0] = (_a_PGLuint63_0.values[0]).to_u32().unwrap();

    let c: &mut [GLubyte];
    c = _allocator.alloc_array::<GLubyte>(&call.arg(1));
    let _a_GLubyte28_0 = (call.arg(1)).to_array();
    if let Some(_a_GLubyte28_0) = _a_GLubyte28_0 {
        for _jGLubyte28 in 0.._a_GLubyte28_0.values.len() {
    c[_jGLubyte28] = (*_a_GLubyte28_0.values[_jGLubyte28]).to_u32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat318_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat318_0) = _a_GLfloat318_0 {
        for _jGLfloat318 in 0.._a_GLfloat318_0.values.len() {
    v[_jGLfloat318] = (*_a_GLfloat318_0.values[_jGLfloat318]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v) };
}

pub fn retrace_glReplacementCodeuiColor3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut rc: GLuint;
    rc = (call.arg(0)).to_u32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(1)).to_f32().unwrap();

    let mut g: GLfloat;
    g = (call.arg(2)).to_f32().unwrap();

    let mut b: GLfloat;
    b = (call.arg(3)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(4)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(5)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(6)).to_f32().unwrap();

    unsafe { gl::ReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z) };
}

pub fn retrace_glReplacementCodeuiColor3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let rc: &mut [GLuint];
    rc = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_PGLuint65_0 = (call.arg(0)).to_array().unwrap();
    rc[0] = (_a_PGLuint65_0.values[0]).to_u32().unwrap();

    let c: &mut [GLfloat];
    c = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat319_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat319_0) = _a_GLfloat319_0 {
        for _jGLfloat319 in 0.._a_GLfloat319_0.values.len() {
    c[_jGLfloat319] = (*_a_GLfloat319_0.values[_jGLfloat319]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat320_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat320_0) = _a_GLfloat320_0 {
        for _jGLfloat320 in 0.._a_GLfloat320_0.values.len() {
    v[_jGLfloat320] = (*_a_GLfloat320_0.values[_jGLfloat320]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ReplacementCodeuiColor3fVertex3fvSUN(rc, c, v) };
}

pub fn retrace_glReplacementCodeuiNormal3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut rc: GLuint;
    rc = (call.arg(0)).to_u32().unwrap();

    let mut nx: GLfloat;
    nx = (call.arg(1)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(2)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(3)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(4)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(5)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(6)).to_f32().unwrap();

    unsafe { gl::ReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z) };
}

pub fn retrace_glReplacementCodeuiNormal3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let rc: &mut [GLuint];
    rc = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_PGLuint66_0 = (call.arg(0)).to_array().unwrap();
    rc[0] = (_a_PGLuint66_0.values[0]).to_u32().unwrap();

    let n: &mut [GLfloat];
    n = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat321_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat321_0) = _a_GLfloat321_0 {
        for _jGLfloat321 in 0.._a_GLfloat321_0.values.len() {
    n[_jGLfloat321] = (*_a_GLfloat321_0.values[_jGLfloat321]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat322_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat322_0) = _a_GLfloat322_0 {
        for _jGLfloat322 in 0.._a_GLfloat322_0.values.len() {
    v[_jGLfloat322] = (*_a_GLfloat322_0.values[_jGLfloat322]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v) };
}

pub fn retrace_glReplacementCodeuiColor4fNormal3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut rc: GLuint;
    rc = (call.arg(0)).to_u32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(1)).to_f32().unwrap();

    let mut g: GLfloat;
    g = (call.arg(2)).to_f32().unwrap();

    let mut b: GLfloat;
    b = (call.arg(3)).to_f32().unwrap();

    let mut a: GLfloat;
    a = (call.arg(4)).to_f32().unwrap();

    let mut nx: GLfloat;
    nx = (call.arg(5)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(6)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(7)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(8)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(9)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(10)).to_f32().unwrap();

    unsafe { gl::ReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z) };
}

pub fn retrace_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let rc: &mut [GLuint];
    rc = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_PGLuint67_0 = (call.arg(0)).to_array().unwrap();
    rc[0] = (_a_PGLuint67_0.values[0]).to_u32().unwrap();

    let c: &mut [GLfloat];
    c = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat323_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat323_0) = _a_GLfloat323_0 {
        for _jGLfloat323 in 0.._a_GLfloat323_0.values.len() {
    c[_jGLfloat323] = (*_a_GLfloat323_0.values[_jGLfloat323]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let n: &mut [GLfloat];
    n = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat324_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat324_0) = _a_GLfloat324_0 {
        for _jGLfloat324 in 0.._a_GLfloat324_0.values.len() {
    n[_jGLfloat324] = (*_a_GLfloat324_0.values[_jGLfloat324]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat325_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat325_0) = _a_GLfloat325_0 {
        for _jGLfloat325 in 0.._a_GLfloat325_0.values.len() {
    v[_jGLfloat325] = (*_a_GLfloat325_0.values[_jGLfloat325]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v) };
}

pub fn retrace_glReplacementCodeuiTexCoord2fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut rc: GLuint;
    rc = (call.arg(0)).to_u32().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(2)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(3)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(4)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(5)).to_f32().unwrap();

    unsafe { gl::ReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z) };
}

pub fn retrace_glReplacementCodeuiTexCoord2fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let rc: &mut [GLuint];
    rc = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_PGLuint68_0 = (call.arg(0)).to_array().unwrap();
    rc[0] = (_a_PGLuint68_0.values[0]).to_u32().unwrap();

    let tc: &mut [GLfloat];
    tc = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat326_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat326_0) = _a_GLfloat326_0 {
        for _jGLfloat326 in 0.._a_GLfloat326_0.values.len() {
    tc[_jGLfloat326] = (*_a_GLfloat326_0.values[_jGLfloat326]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat327_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat327_0) = _a_GLfloat327_0 {
        for _jGLfloat327 in 0.._a_GLfloat327_0.values.len() {
    v[_jGLfloat327] = (*_a_GLfloat327_0.values[_jGLfloat327]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v) };
}

pub fn retrace_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut rc: GLuint;
    rc = (call.arg(0)).to_u32().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(2)).to_f32().unwrap();

    let mut nx: GLfloat;
    nx = (call.arg(3)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(4)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(5)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(6)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(7)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(8)).to_f32().unwrap();

    unsafe { gl::ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z) };
}

pub fn retrace_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let rc: &mut [GLuint];
    rc = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_PGLuint69_0 = (call.arg(0)).to_array().unwrap();
    rc[0] = (_a_PGLuint69_0.values[0]).to_u32().unwrap();

    let tc: &mut [GLfloat];
    tc = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat328_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat328_0) = _a_GLfloat328_0 {
        for _jGLfloat328 in 0.._a_GLfloat328_0.values.len() {
    tc[_jGLfloat328] = (*_a_GLfloat328_0.values[_jGLfloat328]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let n: &mut [GLfloat];
    n = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat329_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat329_0) = _a_GLfloat329_0 {
        for _jGLfloat329 in 0.._a_GLfloat329_0.values.len() {
    n[_jGLfloat329] = (*_a_GLfloat329_0.values[_jGLfloat329]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat330_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat330_0) = _a_GLfloat330_0 {
        for _jGLfloat330 in 0.._a_GLfloat330_0.values.len() {
    v[_jGLfloat330] = (*_a_GLfloat330_0.values[_jGLfloat330]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v) };
}

pub fn retrace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut rc: GLuint;
    rc = (call.arg(0)).to_u32().unwrap();

    let mut s: GLfloat;
    s = (call.arg(1)).to_f32().unwrap();

    let mut t: GLfloat;
    t = (call.arg(2)).to_f32().unwrap();

    let mut r: GLfloat;
    r = (call.arg(3)).to_f32().unwrap();

    let mut g: GLfloat;
    g = (call.arg(4)).to_f32().unwrap();

    let mut b: GLfloat;
    b = (call.arg(5)).to_f32().unwrap();

    let mut a: GLfloat;
    a = (call.arg(6)).to_f32().unwrap();

    let mut nx: GLfloat;
    nx = (call.arg(7)).to_f32().unwrap();

    let mut ny: GLfloat;
    ny = (call.arg(8)).to_f32().unwrap();

    let mut nz: GLfloat;
    nz = (call.arg(9)).to_f32().unwrap();

    let mut x: GLfloat;
    x = (call.arg(10)).to_f32().unwrap();

    let mut y: GLfloat;
    y = (call.arg(11)).to_f32().unwrap();

    let mut z: GLfloat;
    z = (call.arg(12)).to_f32().unwrap();

    unsafe { gl::ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z) };
}

pub fn retrace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let rc: &mut [GLuint];
    rc = _allocator.alloc_array::<GLuint>(&call.arg(0));
    let _a_PGLuint70_0 = (call.arg(0)).to_array().unwrap();
    rc[0] = (_a_PGLuint70_0.values[0]).to_u32().unwrap();

    let tc: &mut [GLfloat];
    tc = _allocator.alloc_array::<GLfloat>(&call.arg(1));
    let _a_GLfloat331_0 = (call.arg(1)).to_array();
    if let Some(_a_GLfloat331_0) = _a_GLfloat331_0 {
        for _jGLfloat331 in 0.._a_GLfloat331_0.values.len() {
    tc[_jGLfloat331] = (*_a_GLfloat331_0.values[_jGLfloat331]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let c: &mut [GLfloat];
    c = _allocator.alloc_array::<GLfloat>(&call.arg(2));
    let _a_GLfloat332_0 = (call.arg(2)).to_array();
    if let Some(_a_GLfloat332_0) = _a_GLfloat332_0 {
        for _jGLfloat332 in 0.._a_GLfloat332_0.values.len() {
    c[_jGLfloat332] = (*_a_GLfloat332_0.values[_jGLfloat332]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let n: &mut [GLfloat];
    n = _allocator.alloc_array::<GLfloat>(&call.arg(3));
    let _a_GLfloat333_0 = (call.arg(3)).to_array();
    if let Some(_a_GLfloat333_0) = _a_GLfloat333_0 {
        for _jGLfloat333 in 0.._a_GLfloat333_0.values.len() {
    n[_jGLfloat333] = (*_a_GLfloat333_0.values[_jGLfloat333]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    let v: &mut [GLfloat];
    v = _allocator.alloc_array::<GLfloat>(&call.arg(4));
    let _a_GLfloat334_0 = (call.arg(4)).to_array();
    if let Some(_a_GLfloat334_0) = _a_GLfloat334_0 {
        for _jGLfloat334 in 0.._a_GLfloat334_0.values.len() {
    v[_jGLfloat334] = (*_a_GLfloat334_0.values[_jGLfloat334]).to_f32().unwrap();
        }
    }
    let params = params.as_mut_ptr();

    unsafe { gl::ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v) };
}

pub fn retrace_glAddSwapHintRectWIN(&mut self, call: &mut Call) {
    let mut _allocator = ScopedAllocator::new();
    let _ = &_allocator;
    let mut x: GLint;
    x = (call.arg(0)).to_i32().unwrap();

    let mut y: GLint;
    y = (call.arg(1)).to_i32().unwrap();

    let mut width: GLsizei;
    width = (call.arg(2)).to_i32().unwrap();

    let mut height: GLsizei;
    height = (call.arg(3)).to_i32().unwrap();

    unsafe { gl::AddSwapHintRectWIN(x, y, width, height) };
}

}

static glretrace::gl_callbacks: [(&'static str, Callback); 2947] = [
    ("glCullFace", &retrace_glCullFace),
    ("glFrontFace", &retrace_glFrontFace),
    ("glHint", &retrace_glHint),
    ("glLineWidth", &retrace_glLineWidth),
    ("glPointSize", &retrace_glPointSize),
    ("glPolygonMode", &retrace_glPolygonMode),
    ("glScissor", &retrace_glScissor),
    ("glTexParameterf", &retrace_glTexParameterf),
    ("glTexParameterfv", &retrace_glTexParameterfv),
    ("glTexParameteri", &retrace_glTexParameteri),
    ("glTexParameteriv", &retrace_glTexParameteriv),
    ("glTexImage1D", &retrace_glTexImage1D),
    ("glTexImage2D", &retrace_glTexImage2D),
    ("glDrawBuffer", &retrace_glDrawBuffer),
    ("glClear", &retrace_glClear),
    ("glClearColor", &retrace_glClearColor),
    ("glClearStencil", &retrace_glClearStencil),
    ("glClearDepth", &retrace_glClearDepth),
    ("glStencilMask", &retrace_glStencilMask),
    ("glColorMask", &retrace_glColorMask),
    ("glDepthMask", &retrace_glDepthMask),
    ("glDisable", &retrace_glDisable),
    ("glEnable", &retrace_glEnable),
    ("glFinish", &retrace_glFinish),
    ("glFlush", &retrace_glFlush),
    ("glBlendFunc", &retrace_glBlendFunc),
    ("glLogicOp", &retrace_glLogicOp),
    ("glStencilFunc", &retrace_glStencilFunc),
    ("glStencilOp", &retrace_glStencilOp),
    ("glDepthFunc", &retrace_glDepthFunc),
    ("glPixelStoref", &retrace_glPixelStoref),
    ("glPixelStorei", &retrace_glPixelStorei),
    ("glReadBuffer", &retrace_glReadBuffer),
    ("glReadPixels", &retrace_glReadPixels),
    ("glGetBooleanv", &retrace::ignore),
    ("glGetDoublev", &retrace::ignore),
    ("glGetError", &retrace::ignore),
    ("glGetFloatv", &retrace::ignore),
    ("glGetIntegerv", &retrace::ignore),
    ("glGetString", &retrace::ignore),
    ("glGetTexImage", &retrace_glGetTexImage),
    ("glGetTexParameterfv", &retrace::ignore),
    ("glGetTexParameteriv", &retrace::ignore),
    ("glGetTexLevelParameterfv", &retrace::ignore),
    ("glGetTexLevelParameteriv", &retrace::ignore),
    ("glIsEnabled", &retrace::ignore),
    ("glDepthRange", &retrace_glDepthRange),
    ("glViewport", &retrace_glViewport),
    ("glNewList", &retrace_glNewList),
    ("glEndList", &retrace_glEndList),
    ("glCallList", &retrace_glCallList),
    ("glCallLists", &retrace_glCallLists),
    ("glDeleteLists", &retrace_glDeleteLists),
    ("glGenLists", &retrace_glGenLists),
    ("glListBase", &retrace_glListBase),
    ("glBegin", &retrace_glBegin),
    ("glBitmap", &retrace_glBitmap),
    ("glColor3b", &retrace_glColor3b),
    ("glColor3bv", &retrace_glColor3bv),
    ("glColor3d", &retrace_glColor3d),
    ("glColor3dv", &retrace_glColor3dv),
    ("glColor3f", &retrace_glColor3f),
    ("glColor3fv", &retrace_glColor3fv),
    ("glColor3i", &retrace_glColor3i),
    ("glColor3iv", &retrace_glColor3iv),
    ("glColor3s", &retrace_glColor3s),
    ("glColor3sv", &retrace_glColor3sv),
    ("glColor3ub", &retrace_glColor3ub),
    ("glColor3ubv", &retrace_glColor3ubv),
    ("glColor3ui", &retrace_glColor3ui),
    ("glColor3uiv", &retrace_glColor3uiv),
    ("glColor3us", &retrace_glColor3us),
    ("glColor3usv", &retrace_glColor3usv),
    ("glColor4b", &retrace_glColor4b),
    ("glColor4bv", &retrace_glColor4bv),
    ("glColor4d", &retrace_glColor4d),
    ("glColor4dv", &retrace_glColor4dv),
    ("glColor4f", &retrace_glColor4f),
    ("glColor4fv", &retrace_glColor4fv),
    ("glColor4i", &retrace_glColor4i),
    ("glColor4iv", &retrace_glColor4iv),
    ("glColor4s", &retrace_glColor4s),
    ("glColor4sv", &retrace_glColor4sv),
    ("glColor4ub", &retrace_glColor4ub),
    ("glColor4ubv", &retrace_glColor4ubv),
    ("glColor4ui", &retrace_glColor4ui),
    ("glColor4uiv", &retrace_glColor4uiv),
    ("glColor4us", &retrace_glColor4us),
    ("glColor4usv", &retrace_glColor4usv),
    ("glEdgeFlag", &retrace_glEdgeFlag),
    ("glEdgeFlagv", &retrace_glEdgeFlagv),
    ("glEnd", &retrace_glEnd),
    ("glIndexd", &retrace_glIndexd),
    ("glIndexdv", &retrace_glIndexdv),
    ("glIndexf", &retrace_glIndexf),
    ("glIndexfv", &retrace_glIndexfv),
    ("glIndexi", &retrace_glIndexi),
    ("glIndexiv", &retrace_glIndexiv),
    ("glIndexs", &retrace_glIndexs),
    ("glIndexsv", &retrace_glIndexsv),
    ("glNormal3b", &retrace_glNormal3b),
    ("glNormal3bv", &retrace_glNormal3bv),
    ("glNormal3d", &retrace_glNormal3d),
    ("glNormal3dv", &retrace_glNormal3dv),
    ("glNormal3f", &retrace_glNormal3f),
    ("glNormal3fv", &retrace_glNormal3fv),
    ("glNormal3i", &retrace_glNormal3i),
    ("glNormal3iv", &retrace_glNormal3iv),
    ("glNormal3s", &retrace_glNormal3s),
    ("glNormal3sv", &retrace_glNormal3sv),
    ("glRasterPos2d", &retrace_glRasterPos2d),
    ("glRasterPos2dv", &retrace_glRasterPos2dv),
    ("glRasterPos2f", &retrace_glRasterPos2f),
    ("glRasterPos2fv", &retrace_glRasterPos2fv),
    ("glRasterPos2i", &retrace_glRasterPos2i),
    ("glRasterPos2iv", &retrace_glRasterPos2iv),
    ("glRasterPos2s", &retrace_glRasterPos2s),
    ("glRasterPos2sv", &retrace_glRasterPos2sv),
    ("glRasterPos3d", &retrace_glRasterPos3d),
    ("glRasterPos3dv", &retrace_glRasterPos3dv),
    ("glRasterPos3f", &retrace_glRasterPos3f),
    ("glRasterPos3fv", &retrace_glRasterPos3fv),
    ("glRasterPos3i", &retrace_glRasterPos3i),
    ("glRasterPos3iv", &retrace_glRasterPos3iv),
    ("glRasterPos3s", &retrace_glRasterPos3s),
    ("glRasterPos3sv", &retrace_glRasterPos3sv),
    ("glRasterPos4d", &retrace_glRasterPos4d),
    ("glRasterPos4dv", &retrace_glRasterPos4dv),
    ("glRasterPos4f", &retrace_glRasterPos4f),
    ("glRasterPos4fv", &retrace_glRasterPos4fv),
    ("glRasterPos4i", &retrace_glRasterPos4i),
    ("glRasterPos4iv", &retrace_glRasterPos4iv),
    ("glRasterPos4s", &retrace_glRasterPos4s),
    ("glRasterPos4sv", &retrace_glRasterPos4sv),
    ("glRectd", &retrace_glRectd),
    ("glRectdv", &retrace_glRectdv),
    ("glRectf", &retrace_glRectf),
    ("glRectfv", &retrace_glRectfv),
    ("glRecti", &retrace_glRecti),
    ("glRectiv", &retrace_glRectiv),
    ("glRects", &retrace_glRects),
    ("glRectsv", &retrace_glRectsv),
    ("glTexCoord1d", &retrace_glTexCoord1d),
    ("glTexCoord1dv", &retrace_glTexCoord1dv),
    ("glTexCoord1f", &retrace_glTexCoord1f),
    ("glTexCoord1fv", &retrace_glTexCoord1fv),
    ("glTexCoord1i", &retrace_glTexCoord1i),
    ("glTexCoord1iv", &retrace_glTexCoord1iv),
    ("glTexCoord1s", &retrace_glTexCoord1s),
    ("glTexCoord1sv", &retrace_glTexCoord1sv),
    ("glTexCoord2d", &retrace_glTexCoord2d),
    ("glTexCoord2dv", &retrace_glTexCoord2dv),
    ("glTexCoord2f", &retrace_glTexCoord2f),
    ("glTexCoord2fv", &retrace_glTexCoord2fv),
    ("glTexCoord2i", &retrace_glTexCoord2i),
    ("glTexCoord2iv", &retrace_glTexCoord2iv),
    ("glTexCoord2s", &retrace_glTexCoord2s),
    ("glTexCoord2sv", &retrace_glTexCoord2sv),
    ("glTexCoord3d", &retrace_glTexCoord3d),
    ("glTexCoord3dv", &retrace_glTexCoord3dv),
    ("glTexCoord3f", &retrace_glTexCoord3f),
    ("glTexCoord3fv", &retrace_glTexCoord3fv),
    ("glTexCoord3i", &retrace_glTexCoord3i),
    ("glTexCoord3iv", &retrace_glTexCoord3iv),
    ("glTexCoord3s", &retrace_glTexCoord3s),
    ("glTexCoord3sv", &retrace_glTexCoord3sv),
    ("glTexCoord4d", &retrace_glTexCoord4d),
    ("glTexCoord4dv", &retrace_glTexCoord4dv),
    ("glTexCoord4f", &retrace_glTexCoord4f),
    ("glTexCoord4fv", &retrace_glTexCoord4fv),
    ("glTexCoord4i", &retrace_glTexCoord4i),
    ("glTexCoord4iv", &retrace_glTexCoord4iv),
    ("glTexCoord4s", &retrace_glTexCoord4s),
    ("glTexCoord4sv", &retrace_glTexCoord4sv),
    ("glVertex2d", &retrace_glVertex2d),
    ("glVertex2dv", &retrace_glVertex2dv),
    ("glVertex2f", &retrace_glVertex2f),
    ("glVertex2fv", &retrace_glVertex2fv),
    ("glVertex2i", &retrace_glVertex2i),
    ("glVertex2iv", &retrace_glVertex2iv),
    ("glVertex2s", &retrace_glVertex2s),
    ("glVertex2sv", &retrace_glVertex2sv),
    ("glVertex3d", &retrace_glVertex3d),
    ("glVertex3dv", &retrace_glVertex3dv),
    ("glVertex3f", &retrace_glVertex3f),
    ("glVertex3fv", &retrace_glVertex3fv),
    ("glVertex3i", &retrace_glVertex3i),
    ("glVertex3iv", &retrace_glVertex3iv),
    ("glVertex3s", &retrace_glVertex3s),
    ("glVertex3sv", &retrace_glVertex3sv),
    ("glVertex4d", &retrace_glVertex4d),
    ("glVertex4dv", &retrace_glVertex4dv),
    ("glVertex4f", &retrace_glVertex4f),
    ("glVertex4fv", &retrace_glVertex4fv),
    ("glVertex4i", &retrace_glVertex4i),
    ("glVertex4iv", &retrace_glVertex4iv),
    ("glVertex4s", &retrace_glVertex4s),
    ("glVertex4sv", &retrace_glVertex4sv),
    ("glClipPlane", &retrace_glClipPlane),
    ("glColorMaterial", &retrace_glColorMaterial),
    ("glFogf", &retrace_glFogf),
    ("glFogfv", &retrace_glFogfv),
    ("glFogi", &retrace_glFogi),
    ("glFogiv", &retrace_glFogiv),
    ("glLightf", &retrace_glLightf),
    ("glLightfv", &retrace_glLightfv),
    ("glLighti", &retrace_glLighti),
    ("glLightiv", &retrace_glLightiv),
    ("glLightModelf", &retrace_glLightModelf),
    ("glLightModelfv", &retrace_glLightModelfv),
    ("glLightModeli", &retrace_glLightModeli),
    ("glLightModeliv", &retrace_glLightModeliv),
    ("glLineStipple", &retrace_glLineStipple),
    ("glMaterialf", &retrace_glMaterialf),
    ("glMaterialfv", &retrace_glMaterialfv),
    ("glMateriali", &retrace_glMateriali),
    ("glMaterialiv", &retrace_glMaterialiv),
    ("glPolygonStipple", &retrace_glPolygonStipple),
    ("glShadeModel", &retrace_glShadeModel),
    ("glTexEnvf", &retrace_glTexEnvf),
    ("glTexEnvfv", &retrace_glTexEnvfv),
    ("glTexEnvi", &retrace_glTexEnvi),
    ("glTexEnviv", &retrace_glTexEnviv),
    ("glTexGend", &retrace_glTexGend),
    ("glTexGendv", &retrace_glTexGendv),
    ("glTexGenf", &retrace_glTexGenf),
    ("glTexGenfv", &retrace_glTexGenfv),
    ("glTexGeni", &retrace_glTexGeni),
    ("glTexGeniv", &retrace_glTexGeniv),
    ("glFeedbackBuffer", &retrace_glFeedbackBuffer),
    ("glSelectBuffer", &retrace_glSelectBuffer),
    ("glRenderMode", &retrace_glRenderMode),
    ("glInitNames", &retrace_glInitNames),
    ("glLoadName", &retrace_glLoadName),
    ("glPassThrough", &retrace_glPassThrough),
    ("glPopName", &retrace_glPopName),
    ("glPushName", &retrace_glPushName),
    ("glClearAccum", &retrace_glClearAccum),
    ("glClearIndex", &retrace_glClearIndex),
    ("glIndexMask", &retrace_glIndexMask),
    ("glAccum", &retrace_glAccum),
    ("glPopAttrib", &retrace_glPopAttrib),
    ("glPushAttrib", &retrace_glPushAttrib),
    ("glMap1d", &retrace_glMap1d),
    ("glMap1f", &retrace_glMap1f),
    ("glMap2d", &retrace_glMap2d),
    ("glMap2f", &retrace_glMap2f),
    ("glMapGrid1d", &retrace_glMapGrid1d),
    ("glMapGrid1f", &retrace_glMapGrid1f),
    ("glMapGrid2d", &retrace_glMapGrid2d),
    ("glMapGrid2f", &retrace_glMapGrid2f),
    ("glEvalCoord1d", &retrace_glEvalCoord1d),
    ("glEvalCoord1dv", &retrace_glEvalCoord1dv),
    ("glEvalCoord1f", &retrace_glEvalCoord1f),
    ("glEvalCoord1fv", &retrace_glEvalCoord1fv),
    ("glEvalCoord2d", &retrace_glEvalCoord2d),
    ("glEvalCoord2dv", &retrace_glEvalCoord2dv),
    ("glEvalCoord2f", &retrace_glEvalCoord2f),
    ("glEvalCoord2fv", &retrace_glEvalCoord2fv),
    ("glEvalMesh1", &retrace_glEvalMesh1),
    ("glEvalPoint1", &retrace_glEvalPoint1),
    ("glEvalMesh2", &retrace_glEvalMesh2),
    ("glEvalPoint2", &retrace_glEvalPoint2),
    ("glAlphaFunc", &retrace_glAlphaFunc),
    ("glPixelZoom", &retrace_glPixelZoom),
    ("glPixelTransferf", &retrace_glPixelTransferf),
    ("glPixelTransferi", &retrace_glPixelTransferi),
    ("glPixelMapfv", &retrace_glPixelMapfv),
    ("glPixelMapuiv", &retrace_glPixelMapuiv),
    ("glPixelMapusv", &retrace_glPixelMapusv),
    ("glCopyPixels", &retrace_glCopyPixels),
    ("glDrawPixels", &retrace_glDrawPixels),
    ("glGetClipPlane", &retrace::ignore),
    ("glGetLightfv", &retrace::ignore),
    ("glGetLightiv", &retrace::ignore),
    ("glGetMapdv", &retrace::ignore),
    ("glGetMapfv", &retrace::ignore),
    ("glGetMapiv", &retrace::ignore),
    ("glGetMaterialfv", &retrace::ignore),
    ("glGetMaterialiv", &retrace::ignore),
    ("glGetPixelMapfv", &retrace_glGetPixelMapfv),
    ("glGetPixelMapuiv", &retrace_glGetPixelMapuiv),
    ("glGetPixelMapusv", &retrace_glGetPixelMapusv),
    ("glGetPolygonStipple", &retrace_glGetPolygonStipple),
    ("glGetTexEnvfv", &retrace::ignore),
    ("glGetTexEnviv", &retrace::ignore),
    ("glGetTexGendv", &retrace::ignore),
    ("glGetTexGenfv", &retrace::ignore),
    ("glGetTexGeniv", &retrace::ignore),
    ("glIsList", &retrace::ignore),
    ("glFrustum", &retrace_glFrustum),
    ("glLoadIdentity", &retrace_glLoadIdentity),
    ("glLoadMatrixf", &retrace_glLoadMatrixf),
    ("glLoadMatrixd", &retrace_glLoadMatrixd),
    ("glMatrixMode", &retrace_glMatrixMode),
    ("glMultMatrixf", &retrace_glMultMatrixf),
    ("glMultMatrixd", &retrace_glMultMatrixd),
    ("glOrtho", &retrace_glOrtho),
    ("glPopMatrix", &retrace_glPopMatrix),
    ("glPushMatrix", &retrace_glPushMatrix),
    ("glRotated", &retrace_glRotated),
    ("glRotatef", &retrace_glRotatef),
    ("glScaled", &retrace_glScaled),
    ("glScalef", &retrace_glScalef),
    ("glTranslated", &retrace_glTranslated),
    ("glTranslatef", &retrace_glTranslatef),
    ("glDrawArrays", &retrace_glDrawArrays),
    ("glDrawElements", &retrace_glDrawElements),
    ("glGetPointerv", &retrace::ignore),
    ("glPolygonOffset", &retrace_glPolygonOffset),
    ("glCopyTexImage1D", &retrace_glCopyTexImage1D),
    ("glCopyTexImage2D", &retrace_glCopyTexImage2D),
    ("glCopyTexSubImage1D", &retrace_glCopyTexSubImage1D),
    ("glCopyTexSubImage2D", &retrace_glCopyTexSubImage2D),
    ("glTexSubImage1D", &retrace_glTexSubImage1D),
    ("glTexSubImage2D", &retrace_glTexSubImage2D),
    ("glBindTexture", &retrace_glBindTexture),
    ("glDeleteTextures", &retrace_glDeleteTextures),
    ("glGenTextures", &retrace_glGenTextures),
    ("glIsTexture", &retrace::ignore),
    ("glArrayElement", &retrace_glArrayElement),
    ("glColorPointer", &retrace_glColorPointer),
    ("glDisableClientState", &retrace_glDisableClientState),
    ("glEdgeFlagPointer", &retrace_glEdgeFlagPointer),
    ("glEnableClientState", &retrace_glEnableClientState),
    ("glIndexPointer", &retrace_glIndexPointer),
    ("glInterleavedArrays", &retrace_glInterleavedArrays),
    ("glNormalPointer", &retrace_glNormalPointer),
    ("glTexCoordPointer", &retrace_glTexCoordPointer),
    ("glVertexPointer", &retrace_glVertexPointer),
    ("glAreTexturesResident", &retrace::ignore),
    ("glPrioritizeTextures", &retrace_glPrioritizeTextures),
    ("glIndexub", &retrace_glIndexub),
    ("glIndexubv", &retrace_glIndexubv),
    ("glPopClientAttrib", &retrace_glPopClientAttrib),
    ("glPushClientAttrib", &retrace_glPushClientAttrib),
    ("glBlendColor", &retrace_glBlendColor),
    ("glBlendEquation", &retrace_glBlendEquation),
    ("glDrawRangeElements", &retrace_glDrawRangeElements),
    ("glTexImage3D", &retrace_glTexImage3D),
    ("glTexSubImage3D", &retrace_glTexSubImage3D),
    ("glCopyTexSubImage3D", &retrace_glCopyTexSubImage3D),
    ("glColorTable", &retrace_glColorTable),
    ("glColorTableParameterfv", &retrace_glColorTableParameterfv),
    ("glColorTableParameteriv", &retrace_glColorTableParameteriv),
    ("glCopyColorTable", &retrace_glCopyColorTable),
    ("glGetColorTable", &retrace::ignore),
    ("glGetColorTableParameterfv", &retrace::ignore),
    ("glGetColorTableParameteriv", &retrace::ignore),
    ("glColorSubTable", &retrace_glColorSubTable),
    ("glCopyColorSubTable", &retrace_glCopyColorSubTable),
    ("glConvolutionFilter1D", &retrace_glConvolutionFilter1D),
    ("glConvolutionFilter2D", &retrace_glConvolutionFilter2D),
    ("glConvolutionParameterf", &retrace_glConvolutionParameterf),
    ("glConvolutionParameterfv", &retrace_glConvolutionParameterfv),
    ("glConvolutionParameteri", &retrace_glConvolutionParameteri),
    ("glConvolutionParameteriv", &retrace_glConvolutionParameteriv),
    ("glCopyConvolutionFilter1D", &retrace_glCopyConvolutionFilter1D),
    ("glCopyConvolutionFilter2D", &retrace_glCopyConvolutionFilter2D),
    ("glGetConvolutionFilter", &retrace_glGetConvolutionFilter),
    ("glGetConvolutionParameterfv", &retrace::ignore),
    ("glGetConvolutionParameteriv", &retrace::ignore),
    ("glGetSeparableFilter", &retrace_glGetSeparableFilter),
    ("glSeparableFilter2D", &retrace_glSeparableFilter2D),
    ("glGetHistogram", &retrace_glGetHistogram),
    ("glGetHistogramParameterfv", &retrace::ignore),
    ("glGetHistogramParameteriv", &retrace::ignore),
    ("glGetMinmax", &retrace_glGetMinmax),
    ("glGetMinmaxParameterfv", &retrace::ignore),
    ("glGetMinmaxParameteriv", &retrace::ignore),
    ("glHistogram", &retrace_glHistogram),
    ("glMinmax", &retrace_glMinmax),
    ("glResetHistogram", &retrace_glResetHistogram),
    ("glResetMinmax", &retrace_glResetMinmax),
    ("glActiveTexture", &retrace_glActiveTexture),
    ("glSampleCoverage", &retrace_glSampleCoverage),
    ("glCompressedTexImage3D", &retrace_glCompressedTexImage3D),
    ("glCompressedTexImage2D", &retrace_glCompressedTexImage2D),
    ("glCompressedTexImage1D", &retrace_glCompressedTexImage1D),
    ("glCompressedTexSubImage3D", &retrace_glCompressedTexSubImage3D),
    ("glCompressedTexSubImage2D", &retrace_glCompressedTexSubImage2D),
    ("glCompressedTexSubImage1D", &retrace_glCompressedTexSubImage1D),
    ("glGetCompressedTexImage", &retrace_glGetCompressedTexImage),
    ("glClientActiveTexture", &retrace_glClientActiveTexture),
    ("glMultiTexCoord1d", &retrace_glMultiTexCoord1d),
    ("glMultiTexCoord1dv", &retrace_glMultiTexCoord1dv),
    ("glMultiTexCoord1f", &retrace_glMultiTexCoord1f),
    ("glMultiTexCoord1fv", &retrace_glMultiTexCoord1fv),
    ("glMultiTexCoord1i", &retrace_glMultiTexCoord1i),
    ("glMultiTexCoord1iv", &retrace_glMultiTexCoord1iv),
    ("glMultiTexCoord1s", &retrace_glMultiTexCoord1s),
    ("glMultiTexCoord1sv", &retrace_glMultiTexCoord1sv),
    ("glMultiTexCoord2d", &retrace_glMultiTexCoord2d),
    ("glMultiTexCoord2dv", &retrace_glMultiTexCoord2dv),
    ("glMultiTexCoord2f", &retrace_glMultiTexCoord2f),
    ("glMultiTexCoord2fv", &retrace_glMultiTexCoord2fv),
    ("glMultiTexCoord2i", &retrace_glMultiTexCoord2i),
    ("glMultiTexCoord2iv", &retrace_glMultiTexCoord2iv),
    ("glMultiTexCoord2s", &retrace_glMultiTexCoord2s),
    ("glMultiTexCoord2sv", &retrace_glMultiTexCoord2sv),
    ("glMultiTexCoord3d", &retrace_glMultiTexCoord3d),
    ("glMultiTexCoord3dv", &retrace_glMultiTexCoord3dv),
    ("glMultiTexCoord3f", &retrace_glMultiTexCoord3f),
    ("glMultiTexCoord3fv", &retrace_glMultiTexCoord3fv),
    ("glMultiTexCoord3i", &retrace_glMultiTexCoord3i),
    ("glMultiTexCoord3iv", &retrace_glMultiTexCoord3iv),
    ("glMultiTexCoord3s", &retrace_glMultiTexCoord3s),
    ("glMultiTexCoord3sv", &retrace_glMultiTexCoord3sv),
    ("glMultiTexCoord4d", &retrace_glMultiTexCoord4d),
    ("glMultiTexCoord4dv", &retrace_glMultiTexCoord4dv),
    ("glMultiTexCoord4f", &retrace_glMultiTexCoord4f),
    ("glMultiTexCoord4fv", &retrace_glMultiTexCoord4fv),
    ("glMultiTexCoord4i", &retrace_glMultiTexCoord4i),
    ("glMultiTexCoord4iv", &retrace_glMultiTexCoord4iv),
    ("glMultiTexCoord4s", &retrace_glMultiTexCoord4s),
    ("glMultiTexCoord4sv", &retrace_glMultiTexCoord4sv),
    ("glLoadTransposeMatrixf", &retrace_glLoadTransposeMatrixf),
    ("glLoadTransposeMatrixd", &retrace_glLoadTransposeMatrixd),
    ("glMultTransposeMatrixf", &retrace_glMultTransposeMatrixf),
    ("glMultTransposeMatrixd", &retrace_glMultTransposeMatrixd),
    ("glBlendFuncSeparate", &retrace_glBlendFuncSeparate),
    ("glMultiDrawArrays", &retrace_glMultiDrawArrays),
    ("glMultiDrawElements", &retrace_glMultiDrawElements),
    ("glPointParameterf", &retrace_glPointParameterf),
    ("glPointParameterfv", &retrace_glPointParameterfv),
    ("glPointParameteri", &retrace_glPointParameteri),
    ("glPointParameteriv", &retrace_glPointParameteriv),
    ("glFogCoordf", &retrace_glFogCoordf),
    ("glFogCoordfv", &retrace_glFogCoordfv),
    ("glFogCoordd", &retrace_glFogCoordd),
    ("glFogCoorddv", &retrace_glFogCoorddv),
    ("glFogCoordPointer", &retrace_glFogCoordPointer),
    ("glSecondaryColor3b", &retrace_glSecondaryColor3b),
    ("glSecondaryColor3bv", &retrace_glSecondaryColor3bv),
    ("glSecondaryColor3d", &retrace_glSecondaryColor3d),
    ("glSecondaryColor3dv", &retrace_glSecondaryColor3dv),
    ("glSecondaryColor3f", &retrace_glSecondaryColor3f),
    ("glSecondaryColor3fv", &retrace_glSecondaryColor3fv),
    ("glSecondaryColor3i", &retrace_glSecondaryColor3i),
    ("glSecondaryColor3iv", &retrace_glSecondaryColor3iv),
    ("glSecondaryColor3s", &retrace_glSecondaryColor3s),
    ("glSecondaryColor3sv", &retrace_glSecondaryColor3sv),
    ("glSecondaryColor3ub", &retrace_glSecondaryColor3ub),
    ("glSecondaryColor3ubv", &retrace_glSecondaryColor3ubv),
    ("glSecondaryColor3ui", &retrace_glSecondaryColor3ui),
    ("glSecondaryColor3uiv", &retrace_glSecondaryColor3uiv),
    ("glSecondaryColor3us", &retrace_glSecondaryColor3us),
    ("glSecondaryColor3usv", &retrace_glSecondaryColor3usv),
    ("glSecondaryColorPointer", &retrace_glSecondaryColorPointer),
    ("glWindowPos2d", &retrace_glWindowPos2d),
    ("glWindowPos2dv", &retrace_glWindowPos2dv),
    ("glWindowPos2f", &retrace_glWindowPos2f),
    ("glWindowPos2fv", &retrace_glWindowPos2fv),
    ("glWindowPos2i", &retrace_glWindowPos2i),
    ("glWindowPos2iv", &retrace_glWindowPos2iv),
    ("glWindowPos2s", &retrace_glWindowPos2s),
    ("glWindowPos2sv", &retrace_glWindowPos2sv),
    ("glWindowPos3d", &retrace_glWindowPos3d),
    ("glWindowPos3dv", &retrace_glWindowPos3dv),
    ("glWindowPos3f", &retrace_glWindowPos3f),
    ("glWindowPos3fv", &retrace_glWindowPos3fv),
    ("glWindowPos3i", &retrace_glWindowPos3i),
    ("glWindowPos3iv", &retrace_glWindowPos3iv),
    ("glWindowPos3s", &retrace_glWindowPos3s),
    ("glWindowPos3sv", &retrace_glWindowPos3sv),
    ("glGenQueries", &retrace_glGenQueries),
    ("glDeleteQueries", &retrace_glDeleteQueries),
    ("glIsQuery", &retrace::ignore),
    ("glBeginQuery", &retrace_glBeginQuery),
    ("glEndQuery", &retrace_glEndQuery),
    ("glGetQueryiv", &retrace::ignore),
    ("glGetQueryObjectiv", &retrace_glGetQueryObjectiv),
    ("glGetQueryObjectuiv", &retrace_glGetQueryObjectuiv),
    ("glBindBuffer", &retrace_glBindBuffer),
    ("glDeleteBuffers", &retrace_glDeleteBuffers),
    ("glGenBuffers", &retrace_glGenBuffers),
    ("glIsBuffer", &retrace::ignore),
    ("glBufferData", &retrace_glBufferData),
    ("glBufferSubData", &retrace_glBufferSubData),
    ("glGetBufferSubData", &retrace::ignore),
    ("glMapBuffer", &retrace_glMapBuffer),
    ("glUnmapBuffer", &retrace_glUnmapBuffer),
    ("glGetBufferParameteriv", &retrace::ignore),
    ("glGetBufferPointerv", &retrace::ignore),
    ("glBlendEquationSeparate", &retrace_glBlendEquationSeparate),
    ("glDrawBuffers", &retrace_glDrawBuffers),
    ("glStencilOpSeparate", &retrace_glStencilOpSeparate),
    ("glStencilFuncSeparate", &retrace_glStencilFuncSeparate),
    ("glStencilMaskSeparate", &retrace_glStencilMaskSeparate),
    ("glAttachShader", &retrace_glAttachShader),
    ("glBindAttribLocation", &retrace_glBindAttribLocation),
    ("glCompileShader", &retrace_glCompileShader),
    ("glCreateProgram", &retrace_glCreateProgram),
    ("glCreateShader", &retrace_glCreateShader),
    ("glDeleteProgram", &retrace_glDeleteProgram),
    ("glDeleteShader", &retrace_glDeleteShader),
    ("glDetachShader", &retrace_glDetachShader),
    ("glDisableVertexAttribArray", &retrace_glDisableVertexAttribArray),
    ("glEnableVertexAttribArray", &retrace_glEnableVertexAttribArray),
    ("glGetActiveAttrib", &retrace::ignore),
    ("glGetActiveUniform", &retrace::ignore),
    ("glGetAttachedShaders", &retrace::ignore),
    ("glGetAttribLocation", &retrace_glGetAttribLocation),
    ("glGetProgramiv", &retrace::ignore),
    ("glGetProgramInfoLog", &retrace::ignore),
    ("glGetShaderiv", &retrace::ignore),
    ("glGetShaderInfoLog", &retrace::ignore),
    ("glGetShaderSource", &retrace::ignore),
    ("glGetUniformLocation", &retrace_glGetUniformLocation),
    ("glGetUniformfv", &retrace::ignore),
    ("glGetUniformiv", &retrace::ignore),
    ("glGetVertexAttribdv", &retrace::ignore),
    ("glGetVertexAttribfv", &retrace::ignore),
    ("glGetVertexAttribiv", &retrace::ignore),
    ("glGetVertexAttribPointerv", &retrace::ignore),
    ("glIsProgram", &retrace::ignore),
    ("glIsShader", &retrace::ignore),
    ("glLinkProgram", &retrace_glLinkProgram),
    ("glShaderSource", &retrace_glShaderSource),
    ("glUseProgram", &retrace_glUseProgram),
    ("glUniform1f", &retrace_glUniform1f),
    ("glUniform2f", &retrace_glUniform2f),
    ("glUniform3f", &retrace_glUniform3f),
    ("glUniform4f", &retrace_glUniform4f),
    ("glUniform1i", &retrace_glUniform1i),
    ("glUniform2i", &retrace_glUniform2i),
    ("glUniform3i", &retrace_glUniform3i),
    ("glUniform4i", &retrace_glUniform4i),
    ("glUniform1fv", &retrace_glUniform1fv),
    ("glUniform2fv", &retrace_glUniform2fv),
    ("glUniform3fv", &retrace_glUniform3fv),
    ("glUniform4fv", &retrace_glUniform4fv),
    ("glUniform1iv", &retrace_glUniform1iv),
    ("glUniform2iv", &retrace_glUniform2iv),
    ("glUniform3iv", &retrace_glUniform3iv),
    ("glUniform4iv", &retrace_glUniform4iv),
    ("glUniformMatrix2fv", &retrace_glUniformMatrix2fv),
    ("glUniformMatrix3fv", &retrace_glUniformMatrix3fv),
    ("glUniformMatrix4fv", &retrace_glUniformMatrix4fv),
    ("glValidateProgram", &retrace_glValidateProgram),
    ("glVertexAttrib1d", &retrace_glVertexAttrib1d),
    ("glVertexAttrib1dv", &retrace_glVertexAttrib1dv),
    ("glVertexAttrib1f", &retrace_glVertexAttrib1f),
    ("glVertexAttrib1fv", &retrace_glVertexAttrib1fv),
    ("glVertexAttrib1s", &retrace_glVertexAttrib1s),
    ("glVertexAttrib1sv", &retrace_glVertexAttrib1sv),
    ("glVertexAttrib2d", &retrace_glVertexAttrib2d),
    ("glVertexAttrib2dv", &retrace_glVertexAttrib2dv),
    ("glVertexAttrib2f", &retrace_glVertexAttrib2f),
    ("glVertexAttrib2fv", &retrace_glVertexAttrib2fv),
    ("glVertexAttrib2s", &retrace_glVertexAttrib2s),
    ("glVertexAttrib2sv", &retrace_glVertexAttrib2sv),
    ("glVertexAttrib3d", &retrace_glVertexAttrib3d),
    ("glVertexAttrib3dv", &retrace_glVertexAttrib3dv),
    ("glVertexAttrib3f", &retrace_glVertexAttrib3f),
    ("glVertexAttrib3fv", &retrace_glVertexAttrib3fv),
    ("glVertexAttrib3s", &retrace_glVertexAttrib3s),
    ("glVertexAttrib3sv", &retrace_glVertexAttrib3sv),
    ("glVertexAttrib4Nbv", &retrace_glVertexAttrib4Nbv),
    ("glVertexAttrib4Niv", &retrace_glVertexAttrib4Niv),
    ("glVertexAttrib4Nsv", &retrace_glVertexAttrib4Nsv),
    ("glVertexAttrib4Nub", &retrace_glVertexAttrib4Nub),
    ("glVertexAttrib4Nubv", &retrace_glVertexAttrib4Nubv),
    ("glVertexAttrib4Nuiv", &retrace_glVertexAttrib4Nuiv),
    ("glVertexAttrib4Nusv", &retrace_glVertexAttrib4Nusv),
    ("glVertexAttrib4bv", &retrace_glVertexAttrib4bv),
    ("glVertexAttrib4d", &retrace_glVertexAttrib4d),
    ("glVertexAttrib4dv", &retrace_glVertexAttrib4dv),
    ("glVertexAttrib4f", &retrace_glVertexAttrib4f),
    ("glVertexAttrib4fv", &retrace_glVertexAttrib4fv),
    ("glVertexAttrib4iv", &retrace_glVertexAttrib4iv),
    ("glVertexAttrib4s", &retrace_glVertexAttrib4s),
    ("glVertexAttrib4sv", &retrace_glVertexAttrib4sv),
    ("glVertexAttrib4ubv", &retrace_glVertexAttrib4ubv),
    ("glVertexAttrib4uiv", &retrace_glVertexAttrib4uiv),
    ("glVertexAttrib4usv", &retrace_glVertexAttrib4usv),
    ("glVertexAttribPointer", &retrace_glVertexAttribPointer),
    ("glUniformMatrix2x3fv", &retrace_glUniformMatrix2x3fv),
    ("glUniformMatrix3x2fv", &retrace_glUniformMatrix3x2fv),
    ("glUniformMatrix2x4fv", &retrace_glUniformMatrix2x4fv),
    ("glUniformMatrix4x2fv", &retrace_glUniformMatrix4x2fv),
    ("glUniformMatrix3x4fv", &retrace_glUniformMatrix3x4fv),
    ("glUniformMatrix4x3fv", &retrace_glUniformMatrix4x3fv),
    ("glColorMaski", &retrace_glColorMaski),
    ("glGetBooleani_v", &retrace::ignore),
    ("glGetIntegeri_v", &retrace::ignore),
    ("glEnablei", &retrace_glEnablei),
    ("glDisablei", &retrace_glDisablei),
    ("glIsEnabledi", &retrace::ignore),
    ("glBeginTransformFeedback", &retrace_glBeginTransformFeedback),
    ("glEndTransformFeedback", &retrace_glEndTransformFeedback),
    ("glBindBufferRange", &retrace_glBindBufferRange),
    ("glBindBufferBase", &retrace_glBindBufferBase),
    ("glTransformFeedbackVaryings", &retrace_glTransformFeedbackVaryings),
    ("glGetTransformFeedbackVarying", &retrace::ignore),
    ("glClampColor", &retrace_glClampColor),
    ("glBeginConditionalRender", &retrace_glBeginConditionalRender),
    ("glEndConditionalRender", &retrace_glEndConditionalRender),
    ("glVertexAttribIPointer", &retrace_glVertexAttribIPointer),
    ("glGetVertexAttribIiv", &retrace::ignore),
    ("glGetVertexAttribIuiv", &retrace::ignore),
    ("glVertexAttribI1i", &retrace_glVertexAttribI1i),
    ("glVertexAttribI2i", &retrace_glVertexAttribI2i),
    ("glVertexAttribI3i", &retrace_glVertexAttribI3i),
    ("glVertexAttribI4i", &retrace_glVertexAttribI4i),
    ("glVertexAttribI1ui", &retrace_glVertexAttribI1ui),
    ("glVertexAttribI2ui", &retrace_glVertexAttribI2ui),
    ("glVertexAttribI3ui", &retrace_glVertexAttribI3ui),
    ("glVertexAttribI4ui", &retrace_glVertexAttribI4ui),
    ("glVertexAttribI1iv", &retrace_glVertexAttribI1iv),
    ("glVertexAttribI2iv", &retrace_glVertexAttribI2iv),
    ("glVertexAttribI3iv", &retrace_glVertexAttribI3iv),
    ("glVertexAttribI4iv", &retrace_glVertexAttribI4iv),
    ("glVertexAttribI1uiv", &retrace_glVertexAttribI1uiv),
    ("glVertexAttribI2uiv", &retrace_glVertexAttribI2uiv),
    ("glVertexAttribI3uiv", &retrace_glVertexAttribI3uiv),
    ("glVertexAttribI4uiv", &retrace_glVertexAttribI4uiv),
    ("glVertexAttribI4bv", &retrace_glVertexAttribI4bv),
    ("glVertexAttribI4sv", &retrace_glVertexAttribI4sv),
    ("glVertexAttribI4ubv", &retrace_glVertexAttribI4ubv),
    ("glVertexAttribI4usv", &retrace_glVertexAttribI4usv),
    ("glGetUniformuiv", &retrace::ignore),
    ("glBindFragDataLocation", &retrace_glBindFragDataLocation),
    ("glGetFragDataLocation", &retrace::ignore),
    ("glUniform1ui", &retrace_glUniform1ui),
    ("glUniform2ui", &retrace_glUniform2ui),
    ("glUniform3ui", &retrace_glUniform3ui),
    ("glUniform4ui", &retrace_glUniform4ui),
    ("glUniform1uiv", &retrace_glUniform1uiv),
    ("glUniform2uiv", &retrace_glUniform2uiv),
    ("glUniform3uiv", &retrace_glUniform3uiv),
    ("glUniform4uiv", &retrace_glUniform4uiv),
    ("glTexParameterIiv", &retrace_glTexParameterIiv),
    ("glTexParameterIuiv", &retrace_glTexParameterIuiv),
    ("glGetTexParameterIiv", &retrace::ignore),
    ("glGetTexParameterIuiv", &retrace::ignore),
    ("glClearBufferiv", &retrace_glClearBufferiv),
    ("glClearBufferuiv", &retrace_glClearBufferuiv),
    ("glClearBufferfv", &retrace_glClearBufferfv),
    ("glClearBufferfi", &retrace_glClearBufferfi),
    ("glGetStringi", &retrace::ignore),
    ("glDrawArraysInstanced", &retrace_glDrawArraysInstanced),
    ("glDrawElementsInstanced", &retrace_glDrawElementsInstanced),
    ("glTexBuffer", &retrace_glTexBuffer),
    ("glPrimitiveRestartIndex", &retrace_glPrimitiveRestartIndex),
    ("glGetInteger64i_v", &retrace::ignore),
    ("glGetBufferParameteri64v", &retrace::ignore),
    ("glFramebufferTexture", &retrace_glFramebufferTexture),
    ("glVertexAttribDivisor", &retrace_glVertexAttribDivisor),
    ("glMinSampleShading", &retrace_glMinSampleShading),
    ("glBlendEquationi", &retrace_glBlendEquationi),
    ("glBlendEquationSeparatei", &retrace_glBlendEquationSeparatei),
    ("glBlendFunci", &retrace_glBlendFunci),
    ("glBlendFuncSeparatei", &retrace_glBlendFuncSeparatei),
    ("glGetnCompressedTexImage", &retrace_glGetnCompressedTexImage),
    ("glGetnTexImage", &retrace_glGetnTexImage),
    ("glGetnUniformdv", &retrace::ignore),
    ("glGetnMapdv", &retrace::ignore),
    ("glGetnMapfv", &retrace::ignore),
    ("glGetnMapiv", &retrace::ignore),
    ("glGetnPixelMapfv", &retrace_glGetnPixelMapfv),
    ("glGetnPixelMapuiv", &retrace_glGetnPixelMapuiv),
    ("glGetnPixelMapusv", &retrace_glGetnPixelMapusv),
    ("glGetnPolygonStipple", &retrace_glGetnPolygonStipple),
    ("glGetnColorTable", &retrace::ignore),
    ("glGetnConvolutionFilter", &retrace_glGetnConvolutionFilter),
    ("glGetnSeparableFilter", &retrace_glGetnSeparableFilter),
    ("glGetnHistogram", &retrace_glGetnHistogram),
    ("glGetnMinmax", &retrace_glGetnMinmax),
    ("glSpecializeShader", &retrace_glSpecializeShader),
    ("glMultiDrawArraysIndirectCount", &retrace_glMultiDrawArraysIndirectCount),
    ("glMultiDrawElementsIndirectCount", &retrace_glMultiDrawElementsIndirectCount),
    ("glClipPlanef", &retrace_glClipPlanef),
    ("glFrustumf", &retrace_glFrustumf),
    ("glGetClipPlanef", &retrace::ignore),
    ("glOrthof", &retrace_glOrthof),
    ("glAlphaFuncx", &retrace_glAlphaFuncx),
    ("glClearColorx", &retrace_glClearColorx),
    ("glClearDepthx", &retrace_glClearDepthx),
    ("glClipPlanex", &retrace_glClipPlanex),
    ("glColor4x", &retrace_glColor4x),
    ("glDepthRangex", &retrace_glDepthRangex),
    ("glFogx", &retrace_glFogx),
    ("glFogxv", &retrace_glFogxv),
    ("glFrustumx", &retrace_glFrustumx),
    ("glGetClipPlanex", &retrace::ignore),
    ("glGetFixedv", &retrace::ignore),
    ("glGetLightxv", &retrace::ignore),
    ("glGetMaterialxv", &retrace::ignore),
    ("glGetTexEnvxv", &retrace::ignore),
    ("glGetTexParameterxv", &retrace::ignore),
    ("glLightModelx", &retrace_glLightModelx),
    ("glLightModelxv", &retrace_glLightModelxv),
    ("glLightx", &retrace_glLightx),
    ("glLightxv", &retrace_glLightxv),
    ("glLineWidthx", &retrace_glLineWidthx),
    ("glLoadMatrixx", &retrace_glLoadMatrixx),
    ("glMaterialx", &retrace_glMaterialx),
    ("glMaterialxv", &retrace_glMaterialxv),
    ("glMultMatrixx", &retrace_glMultMatrixx),
    ("glMultiTexCoord4x", &retrace_glMultiTexCoord4x),
    ("glNormal3x", &retrace_glNormal3x),
    ("glOrthox", &retrace_glOrthox),
    ("glPointParameterx", &retrace_glPointParameterx),
    ("glPointParameterxv", &retrace_glPointParameterxv),
    ("glPointSizex", &retrace_glPointSizex),
    ("glPolygonOffsetx", &retrace_glPolygonOffsetx),
    ("glRotatex", &retrace_glRotatex),
    ("glSampleCoveragex", &retrace_glSampleCoveragex),
    ("glScalex", &retrace_glScalex),
    ("glTexEnvx", &retrace_glTexEnvx),
    ("glTexEnvxv", &retrace_glTexEnvxv),
    ("glTexParameterx", &retrace_glTexParameterx),
    ("glTexParameterxv", &retrace_glTexParameterxv),
    ("glTranslatex", &retrace_glTranslatex),
    ("glBlendBarrier", &retrace_glBlendBarrier),
    ("glPrimitiveBoundingBox", &retrace_glPrimitiveBoundingBox),
    ("glTbufferMask3DFX", &retrace_glTbufferMask3DFX),
    ("glDebugMessageEnableAMD", &retrace_glDebugMessageEnableAMD),
    ("glDebugMessageInsertAMD", &retrace_glDebugMessageInsertAMD),
    ("glDebugMessageCallbackAMD", &retrace::ignore),
    ("glGetDebugMessageLogAMD", &retrace::ignore),
    ("glBlendFuncIndexedAMD", &retrace_glBlendFuncIndexedAMD),
    ("glBlendFuncSeparateIndexedAMD", &retrace_glBlendFuncSeparateIndexedAMD),
    ("glBlendEquationIndexedAMD", &retrace_glBlendEquationIndexedAMD),
    ("glBlendEquationSeparateIndexedAMD", &retrace_glBlendEquationSeparateIndexedAMD),
    ("glVertexAttribParameteriAMD", &retrace_glVertexAttribParameteriAMD),
    ("glMultiDrawArraysIndirectAMD", &retrace_glMultiDrawArraysIndirectAMD),
    ("glMultiDrawElementsIndirectAMD", &retrace_glMultiDrawElementsIndirectAMD),
    ("glGenNamesAMD", &retrace_glGenNamesAMD),
    ("glDeleteNamesAMD", &retrace_glDeleteNamesAMD),
    ("glIsNameAMD", &retrace::ignore),
    ("glQueryObjectParameteruiAMD", &retrace_glQueryObjectParameteruiAMD),
    ("glGetPerfMonitorGroupsAMD", &retrace::ignore),
    ("glGetPerfMonitorCountersAMD", &retrace::ignore),
    ("glGetPerfMonitorGroupStringAMD", &retrace::ignore),
    ("glGetPerfMonitorCounterStringAMD", &retrace::ignore),
    ("glGetPerfMonitorCounterInfoAMD", &retrace::ignore),
    ("glGenPerfMonitorsAMD", &retrace_glGenPerfMonitorsAMD),
    ("glDeletePerfMonitorsAMD", &retrace_glDeletePerfMonitorsAMD),
    ("glSelectPerfMonitorCountersAMD", &retrace_glSelectPerfMonitorCountersAMD),
    ("glBeginPerfMonitorAMD", &retrace_glBeginPerfMonitorAMD),
    ("glEndPerfMonitorAMD", &retrace_glEndPerfMonitorAMD),
    ("glGetPerfMonitorCounterDataAMD", &retrace::ignore),
    ("glSetMultisamplefvAMD", &retrace_glSetMultisamplefvAMD),
    ("glTexStorageSparseAMD", &retrace_glTexStorageSparseAMD),
    ("glTextureStorageSparseAMD", &retrace_glTextureStorageSparseAMD),
    ("glStencilOpValueAMD", &retrace_glStencilOpValueAMD),
    ("glTessellationFactorAMD", &retrace_glTessellationFactorAMD),
    ("glTessellationModeAMD", &retrace_glTessellationModeAMD),
    ("glBlitFramebufferANGLE", &retrace_glBlitFramebufferANGLE),
    ("glRenderbufferStorageMultisampleANGLE", &retrace_glRenderbufferStorageMultisampleANGLE),
    ("glDrawArraysInstancedANGLE", &retrace_glDrawArraysInstancedANGLE),
    ("glDrawElementsInstancedANGLE", &retrace_glDrawElementsInstancedANGLE),
    ("glVertexAttribDivisorANGLE", &retrace_glVertexAttribDivisorANGLE),
    ("glGenQueriesANGLE", &retrace_glGenQueriesANGLE),
    ("glDeleteQueriesANGLE", &retrace_glDeleteQueriesANGLE),
    ("glIsQueryANGLE", &retrace::ignore),
    ("glBeginQueryANGLE", &retrace_glBeginQueryANGLE),
    ("glEndQueryANGLE", &retrace_glEndQueryANGLE),
    ("glQueryCounterANGLE", &retrace_glQueryCounterANGLE),
    ("glGetQueryivANGLE", &retrace::ignore),
    ("glGetQueryObjectivANGLE", &retrace_glGetQueryObjectivANGLE),
    ("glGetQueryObjectuivANGLE", &retrace_glGetQueryObjectuivANGLE),
    ("glGetQueryObjecti64vANGLE", &retrace_glGetQueryObjecti64vANGLE),
    ("glGetQueryObjectui64vANGLE", &retrace_glGetQueryObjectui64vANGLE),
    ("glGetTranslatedShaderSourceANGLE", &retrace::ignore),
    ("glCopyTextureLevelsAPPLE", &retrace_glCopyTextureLevelsAPPLE),
    ("glElementPointerAPPLE", &retrace_glElementPointerAPPLE),
    ("glDrawElementArrayAPPLE", &retrace_glDrawElementArrayAPPLE),
    ("glDrawRangeElementArrayAPPLE", &retrace_glDrawRangeElementArrayAPPLE),
    ("glMultiDrawElementArrayAPPLE", &retrace_glMultiDrawElementArrayAPPLE),
    ("glMultiDrawRangeElementArrayAPPLE", &retrace_glMultiDrawRangeElementArrayAPPLE),
    ("glGenFencesAPPLE", &retrace_glGenFencesAPPLE),
    ("glDeleteFencesAPPLE", &retrace_glDeleteFencesAPPLE),
    ("glSetFenceAPPLE", &retrace_glSetFenceAPPLE),
    ("glIsFenceAPPLE", &retrace::ignore),
    ("glTestFenceAPPLE", &retrace_glTestFenceAPPLE),
    ("glFinishFenceAPPLE", &retrace_glFinishFenceAPPLE),
    ("glTestObjectAPPLE", &retrace_glTestObjectAPPLE),
    ("glFinishObjectAPPLE", &retrace_glFinishObjectAPPLE),
    ("glBufferParameteriAPPLE", &retrace_glBufferParameteriAPPLE),
    ("glFlushMappedBufferRangeAPPLE", &retrace_glFlushMappedBufferRangeAPPLE),
    ("glFlushRenderAPPLE", &retrace_glFlushRenderAPPLE),
    ("glFinishRenderAPPLE", &retrace_glFinishRenderAPPLE),
    ("glSwapAPPLE", &retrace_glSwapAPPLE),
    ("glRenderbufferStorageMultisampleAPPLE", &retrace_glRenderbufferStorageMultisampleAPPLE),
    ("glResolveMultisampleFramebufferAPPLE", &retrace_glResolveMultisampleFramebufferAPPLE),
    ("glObjectPurgeableAPPLE", &retrace_glObjectPurgeableAPPLE),
    ("glObjectUnpurgeableAPPLE", &retrace_glObjectUnpurgeableAPPLE),
    ("glGetObjectParameterivAPPLE", &retrace::ignore),
    ("glPointSizePointerAPPLE", &retrace_glPointSizePointerAPPLE),
    ("glVertexPointSizefAPPLE", &retrace_glVertexPointSizefAPPLE),
    ("glFenceSyncAPPLE", &retrace_glFenceSyncAPPLE),
    ("glIsSyncAPPLE", &retrace::ignore),
    ("glDeleteSyncAPPLE", &retrace_glDeleteSyncAPPLE),
    ("glClientWaitSyncAPPLE", &retrace_glClientWaitSyncAPPLE),
    ("glWaitSyncAPPLE", &retrace_glWaitSyncAPPLE),
    ("glGetInteger64vAPPLE", &retrace::ignore),
    ("glGetSyncivAPPLE", &retrace::ignore),
    ("glTextureRangeAPPLE", &retrace_glTextureRangeAPPLE),
    ("glGetTexParameterPointervAPPLE", &retrace::ignore),
    ("glBindVertexArrayAPPLE", &retrace_glBindVertexArrayAPPLE),
    ("glDeleteVertexArraysAPPLE", &retrace_glDeleteVertexArraysAPPLE),
    ("glGenVertexArraysAPPLE", &retrace_glGenVertexArraysAPPLE),
    ("glIsVertexArrayAPPLE", &retrace::ignore),
    ("glVertexArrayRangeAPPLE", &retrace_glVertexArrayRangeAPPLE),
    ("glFlushVertexArrayRangeAPPLE", &retrace_glFlushVertexArrayRangeAPPLE),
    ("glVertexArrayParameteriAPPLE", &retrace_glVertexArrayParameteriAPPLE),
    ("glEnableVertexAttribAPPLE", &retrace_glEnableVertexAttribAPPLE),
    ("glDisableVertexAttribAPPLE", &retrace_glDisableVertexAttribAPPLE),
    ("glIsVertexAttribEnabledAPPLE", &retrace::ignore),
    ("glMapVertexAttrib1dAPPLE", &retrace_glMapVertexAttrib1dAPPLE),
    ("glMapVertexAttrib1fAPPLE", &retrace_glMapVertexAttrib1fAPPLE),
    ("glMapVertexAttrib2dAPPLE", &retrace_glMapVertexAttrib2dAPPLE),
    ("glMapVertexAttrib2fAPPLE", &retrace_glMapVertexAttrib2fAPPLE),
    ("glReleaseShaderCompiler", &retrace_glReleaseShaderCompiler),
    ("glShaderBinary", &retrace_glShaderBinary),
    ("glGetShaderPrecisionFormat", &retrace::ignore),
    ("glDepthRangef", &retrace_glDepthRangef),
    ("glClearDepthf", &retrace_glClearDepthf),
    ("glMemoryBarrierByRegion", &retrace_glMemoryBarrierByRegion),
    ("glPrimitiveBoundingBoxARB", &retrace_glPrimitiveBoundingBoxARB),
    ("glDrawArraysInstancedBaseInstance", &retrace_glDrawArraysInstancedBaseInstance),
    ("glDrawElementsInstancedBaseInstance", &retrace_glDrawElementsInstancedBaseInstance),
    ("glDrawElementsInstancedBaseVertexBaseInstance", &retrace_glDrawElementsInstancedBaseVertexBaseInstance),
    ("glGetTextureHandleARB", &retrace_glGetTextureHandleARB),
    ("glGetTextureSamplerHandleARB", &retrace_glGetTextureSamplerHandleARB),
    ("glMakeTextureHandleResidentARB", &retrace_glMakeTextureHandleResidentARB),
    ("glMakeTextureHandleNonResidentARB", &retrace_glMakeTextureHandleNonResidentARB),
    ("glGetImageHandleARB", &retrace_glGetImageHandleARB),
    ("glMakeImageHandleResidentARB", &retrace_glMakeImageHandleResidentARB),
    ("glMakeImageHandleNonResidentARB", &retrace_glMakeImageHandleNonResidentARB),
    ("glUniformHandleui64ARB", &retrace_glUniformHandleui64ARB),
    ("glUniformHandleui64vARB", &retrace_glUniformHandleui64vARB),
    ("glProgramUniformHandleui64ARB", &retrace_glProgramUniformHandleui64ARB),
    ("glProgramUniformHandleui64vARB", &retrace_glProgramUniformHandleui64vARB),
    ("glIsTextureHandleResidentARB", &retrace::ignore),
    ("glIsImageHandleResidentARB", &retrace::ignore),
    ("glVertexAttribL1ui64ARB", &retrace_glVertexAttribL1ui64ARB),
    ("glVertexAttribL1ui64vARB", &retrace_glVertexAttribL1ui64vARB),
    ("glGetVertexAttribLui64vARB", &retrace::ignore),
    ("glBindFragDataLocationIndexed", &retrace_glBindFragDataLocationIndexed),
    ("glGetFragDataIndex", &retrace::ignore),
    ("glBufferStorage", &retrace_glBufferStorage),
    ("glCreateSyncFromCLeventARB", &retrace::ignore),
    ("glClearBufferData", &retrace_glClearBufferData),
    ("glClearBufferSubData", &retrace_glClearBufferSubData),
    ("glClearTexImage", &retrace_glClearTexImage),
    ("glClearTexSubImage", &retrace_glClearTexSubImage),
    ("glClipControl", &retrace_glClipControl),
    ("glClampColorARB", &retrace_glClampColorARB),
    ("glDispatchCompute", &retrace_glDispatchCompute),
    ("glDispatchComputeIndirect", &retrace_glDispatchComputeIndirect),
    ("glDispatchComputeGroupSizeARB", &retrace_glDispatchComputeGroupSizeARB),
    ("glCopyBufferSubData", &retrace_glCopyBufferSubData),
    ("glCopyImageSubData", &retrace_glCopyImageSubData),
    ("glDebugMessageControlARB", &retrace_glDebugMessageControlARB),
    ("glDebugMessageInsertARB", &retrace_glDebugMessageInsertARB),
    ("glDebugMessageCallbackARB", &retrace::ignore),
    ("glGetDebugMessageLogARB", &retrace::ignore),
    ("glCreateTransformFeedbacks", &retrace_glCreateTransformFeedbacks),
    ("glTransformFeedbackBufferBase", &retrace_glTransformFeedbackBufferBase),
    ("glTransformFeedbackBufferRange", &retrace_glTransformFeedbackBufferRange),
    ("glGetTransformFeedbackiv", &retrace::ignore),
    ("glGetTransformFeedbacki_v", &retrace::ignore),
    ("glGetTransformFeedbacki64_v", &retrace::ignore),
    ("glCreateBuffers", &retrace_glCreateBuffers),
    ("glNamedBufferStorage", &retrace_glNamedBufferStorage),
    ("glNamedBufferData", &retrace_glNamedBufferData),
    ("glNamedBufferSubData", &retrace_glNamedBufferSubData),
    ("glCopyNamedBufferSubData", &retrace_glCopyNamedBufferSubData),
    ("glClearNamedBufferData", &retrace_glClearNamedBufferData),
    ("glClearNamedBufferSubData", &retrace_glClearNamedBufferSubData),
    ("glMapNamedBuffer", &retrace_glMapNamedBuffer),
    ("glMapNamedBufferRange", &retrace_glMapNamedBufferRange),
    ("glUnmapNamedBuffer", &retrace_glUnmapNamedBuffer),
    ("glFlushMappedNamedBufferRange", &retrace_glFlushMappedNamedBufferRange),
    ("glGetNamedBufferParameteriv", &retrace::ignore),
    ("glGetNamedBufferParameteri64v", &retrace::ignore),
    ("glGetNamedBufferPointerv", &retrace::ignore),
    ("glGetNamedBufferSubData", &retrace::ignore),
    ("glCreateFramebuffers", &retrace_glCreateFramebuffers),
    ("glNamedFramebufferRenderbuffer", &retrace_glNamedFramebufferRenderbuffer),
    ("glNamedFramebufferParameteri", &retrace_glNamedFramebufferParameteri),
    ("glNamedFramebufferTexture", &retrace_glNamedFramebufferTexture),
    ("glNamedFramebufferTextureLayer", &retrace_glNamedFramebufferTextureLayer),
    ("glNamedFramebufferDrawBuffer", &retrace_glNamedFramebufferDrawBuffer),
    ("glNamedFramebufferDrawBuffers", &retrace_glNamedFramebufferDrawBuffers),
    ("glNamedFramebufferReadBuffer", &retrace_glNamedFramebufferReadBuffer),
    ("glInvalidateNamedFramebufferData", &retrace_glInvalidateNamedFramebufferData),
    ("glInvalidateNamedFramebufferSubData", &retrace_glInvalidateNamedFramebufferSubData),
    ("glClearNamedFramebufferiv", &retrace_glClearNamedFramebufferiv),
    ("glClearNamedFramebufferuiv", &retrace_glClearNamedFramebufferuiv),
    ("glClearNamedFramebufferfv", &retrace_glClearNamedFramebufferfv),
    ("glClearNamedFramebufferfi", &retrace_glClearNamedFramebufferfi),
    ("glBlitNamedFramebuffer", &retrace_glBlitNamedFramebuffer),
    ("glCheckNamedFramebufferStatus", &retrace_glCheckNamedFramebufferStatus),
    ("glGetNamedFramebufferParameteriv", &retrace::ignore),
    ("glGetNamedFramebufferAttachmentParameteriv", &retrace::ignore),
    ("glCreateRenderbuffers", &retrace_glCreateRenderbuffers),
    ("glNamedRenderbufferStorage", &retrace_glNamedRenderbufferStorage),
    ("glNamedRenderbufferStorageMultisample", &retrace_glNamedRenderbufferStorageMultisample),
    ("glGetNamedRenderbufferParameteriv", &retrace::ignore),
    ("glCreateTextures", &retrace_glCreateTextures),
    ("glTextureBuffer", &retrace_glTextureBuffer),
    ("glTextureBufferRange", &retrace_glTextureBufferRange),
    ("glTextureStorage1D", &retrace_glTextureStorage1D),
    ("glTextureStorage2D", &retrace_glTextureStorage2D),
    ("glTextureStorage3D", &retrace_glTextureStorage3D),
    ("glTextureStorage2DMultisample", &retrace_glTextureStorage2DMultisample),
    ("glTextureStorage3DMultisample", &retrace_glTextureStorage3DMultisample),
    ("glTextureSubImage1D", &retrace_glTextureSubImage1D),
    ("glTextureSubImage2D", &retrace_glTextureSubImage2D),
    ("glTextureSubImage3D", &retrace_glTextureSubImage3D),
    ("glCompressedTextureSubImage1D", &retrace_glCompressedTextureSubImage1D),
    ("glCompressedTextureSubImage2D", &retrace_glCompressedTextureSubImage2D),
    ("glCompressedTextureSubImage3D", &retrace_glCompressedTextureSubImage3D),
    ("glCopyTextureSubImage1D", &retrace_glCopyTextureSubImage1D),
    ("glCopyTextureSubImage2D", &retrace_glCopyTextureSubImage2D),
    ("glCopyTextureSubImage3D", &retrace_glCopyTextureSubImage3D),
    ("glTextureParameterf", &retrace_glTextureParameterf),
    ("glTextureParameterfv", &retrace_glTextureParameterfv),
    ("glTextureParameteri", &retrace_glTextureParameteri),
    ("glTextureParameterIiv", &retrace_glTextureParameterIiv),
    ("glTextureParameterIuiv", &retrace_glTextureParameterIuiv),
    ("glTextureParameteriv", &retrace_glTextureParameteriv),
    ("glGenerateTextureMipmap", &retrace_glGenerateTextureMipmap),
    ("glBindTextureUnit", &retrace_glBindTextureUnit),
    ("glGetTextureImage", &retrace_glGetTextureImage),
    ("glGetCompressedTextureImage", &retrace_glGetCompressedTextureImage),
    ("glGetTextureLevelParameterfv", &retrace::ignore),
    ("glGetTextureLevelParameteriv", &retrace::ignore),
    ("glGetTextureParameterfv", &retrace::ignore),
    ("glGetTextureParameterIiv", &retrace::ignore),
    ("glGetTextureParameterIuiv", &retrace::ignore),
    ("glGetTextureParameteriv", &retrace::ignore),
    ("glCreateVertexArrays", &retrace_glCreateVertexArrays),
    ("glDisableVertexArrayAttrib", &retrace_glDisableVertexArrayAttrib),
    ("glEnableVertexArrayAttrib", &retrace_glEnableVertexArrayAttrib),
    ("glVertexArrayElementBuffer", &retrace_glVertexArrayElementBuffer),
    ("glVertexArrayVertexBuffer", &retrace_glVertexArrayVertexBuffer),
    ("glVertexArrayVertexBuffers", &retrace_glVertexArrayVertexBuffers),
    ("glVertexArrayAttribBinding", &retrace_glVertexArrayAttribBinding),
    ("glVertexArrayAttribFormat", &retrace_glVertexArrayAttribFormat),
    ("glVertexArrayAttribIFormat", &retrace_glVertexArrayAttribIFormat),
    ("glVertexArrayAttribLFormat", &retrace_glVertexArrayAttribLFormat),
    ("glVertexArrayBindingDivisor", &retrace_glVertexArrayBindingDivisor),
    ("glGetVertexArrayiv", &retrace::ignore),
    ("glGetVertexArrayIndexediv", &retrace::ignore),
    ("glGetVertexArrayIndexed64iv", &retrace::ignore),
    ("glCreateSamplers", &retrace_glCreateSamplers),
    ("glCreateProgramPipelines", &retrace_glCreateProgramPipelines),
    ("glCreateQueries", &retrace_glCreateQueries),
    ("glGetQueryBufferObjecti64v", &retrace_glGetQueryBufferObjecti64v),
    ("glGetQueryBufferObjectiv", &retrace_glGetQueryBufferObjectiv),
    ("glGetQueryBufferObjectui64v", &retrace_glGetQueryBufferObjectui64v),
    ("glGetQueryBufferObjectuiv", &retrace_glGetQueryBufferObjectuiv),
    ("glDrawBuffersARB", &retrace_glDrawBuffersARB),
    ("glBlendEquationiARB", &retrace_glBlendEquationiARB),
    ("glBlendEquationSeparateiARB", &retrace_glBlendEquationSeparateiARB),
    ("glBlendFunciARB", &retrace_glBlendFunciARB),
    ("glBlendFuncSeparateiARB", &retrace_glBlendFuncSeparateiARB),
    ("glDrawElementsBaseVertex", &retrace_glDrawElementsBaseVertex),
    ("glDrawRangeElementsBaseVertex", &retrace_glDrawRangeElementsBaseVertex),
    ("glDrawElementsInstancedBaseVertex", &retrace_glDrawElementsInstancedBaseVertex),
    ("glMultiDrawElementsBaseVertex", &retrace_glMultiDrawElementsBaseVertex),
    ("glDrawArraysIndirect", &retrace_glDrawArraysIndirect),
    ("glDrawElementsIndirect", &retrace_glDrawElementsIndirect),
    ("glDrawArraysInstancedARB", &retrace_glDrawArraysInstancedARB),
    ("glDrawElementsInstancedARB", &retrace_glDrawElementsInstancedARB),
    ("glFramebufferParameteri", &retrace_glFramebufferParameteri),
    ("glGetFramebufferParameteriv", &retrace::ignore),
    ("glIsRenderbuffer", &retrace::ignore),
    ("glBindRenderbuffer", &retrace_glBindRenderbuffer),
    ("glDeleteRenderbuffers", &retrace_glDeleteRenderbuffers),
    ("glGenRenderbuffers", &retrace_glGenRenderbuffers),
    ("glRenderbufferStorage", &retrace_glRenderbufferStorage),
    ("glGetRenderbufferParameteriv", &retrace::ignore),
    ("glIsFramebuffer", &retrace::ignore),
    ("glBindFramebuffer", &retrace_glBindFramebuffer),
    ("glDeleteFramebuffers", &retrace_glDeleteFramebuffers),
    ("glGenFramebuffers", &retrace_glGenFramebuffers),
    ("glCheckFramebufferStatus", &retrace_glCheckFramebufferStatus),
    ("glFramebufferTexture1D", &retrace_glFramebufferTexture1D),
    ("glFramebufferTexture2D", &retrace_glFramebufferTexture2D),
    ("glFramebufferTexture3D", &retrace_glFramebufferTexture3D),
    ("glFramebufferRenderbuffer", &retrace_glFramebufferRenderbuffer),
    ("glGetFramebufferAttachmentParameteriv", &retrace::ignore),
    ("glGenerateMipmap", &retrace_glGenerateMipmap),
    ("glBlitFramebuffer", &retrace_glBlitFramebuffer),
    ("glRenderbufferStorageMultisample", &retrace_glRenderbufferStorageMultisample),
    ("glFramebufferTextureLayer", &retrace_glFramebufferTextureLayer),
    ("glProgramParameteriARB", &retrace_glProgramParameteriARB),
    ("glFramebufferTextureARB", &retrace_glFramebufferTextureARB),
    ("glFramebufferTextureLayerARB", &retrace_glFramebufferTextureLayerARB),
    ("glFramebufferTextureFaceARB", &retrace_glFramebufferTextureFaceARB),
    ("glGetProgramBinary", &retrace::ignore),
    ("glProgramBinary", &retrace_glProgramBinary),
    ("glProgramParameteri", &retrace_glProgramParameteri),
    ("glGetTextureSubImage", &retrace_glGetTextureSubImage),
    ("glGetCompressedTextureSubImage", &retrace_glGetCompressedTextureSubImage),
    ("glSpecializeShaderARB", &retrace_glSpecializeShaderARB),
    ("glUniform1d", &retrace_glUniform1d),
    ("glUniform2d", &retrace_glUniform2d),
    ("glUniform3d", &retrace_glUniform3d),
    ("glUniform4d", &retrace_glUniform4d),
    ("glUniform1dv", &retrace_glUniform1dv),
    ("glUniform2dv", &retrace_glUniform2dv),
    ("glUniform3dv", &retrace_glUniform3dv),
    ("glUniform4dv", &retrace_glUniform4dv),
    ("glUniformMatrix2dv", &retrace_glUniformMatrix2dv),
    ("glUniformMatrix3dv", &retrace_glUniformMatrix3dv),
    ("glUniformMatrix4dv", &retrace_glUniformMatrix4dv),
    ("glUniformMatrix2x3dv", &retrace_glUniformMatrix2x3dv),
    ("glUniformMatrix2x4dv", &retrace_glUniformMatrix2x4dv),
    ("glUniformMatrix3x2dv", &retrace_glUniformMatrix3x2dv),
    ("glUniformMatrix3x4dv", &retrace_glUniformMatrix3x4dv),
    ("glUniformMatrix4x2dv", &retrace_glUniformMatrix4x2dv),
    ("glUniformMatrix4x3dv", &retrace_glUniformMatrix4x3dv),
    ("glGetUniformdv", &retrace::ignore),
    ("glUniform1i64ARB", &retrace_glUniform1i64ARB),
    ("glUniform2i64ARB", &retrace_glUniform2i64ARB),
    ("glUniform3i64ARB", &retrace_glUniform3i64ARB),
    ("glUniform4i64ARB", &retrace_glUniform4i64ARB),
    ("glUniform1i64vARB", &retrace_glUniform1i64vARB),
    ("glUniform2i64vARB", &retrace_glUniform2i64vARB),
    ("glUniform3i64vARB", &retrace_glUniform3i64vARB),
    ("glUniform4i64vARB", &retrace_glUniform4i64vARB),
    ("glUniform1ui64ARB", &retrace_glUniform1ui64ARB),
    ("glUniform2ui64ARB", &retrace_glUniform2ui64ARB),
    ("glUniform3ui64ARB", &retrace_glUniform3ui64ARB),
    ("glUniform4ui64ARB", &retrace_glUniform4ui64ARB),
    ("glUniform1ui64vARB", &retrace_glUniform1ui64vARB),
    ("glUniform2ui64vARB", &retrace_glUniform2ui64vARB),
    ("glUniform3ui64vARB", &retrace_glUniform3ui64vARB),
    ("glUniform4ui64vARB", &retrace_glUniform4ui64vARB),
    ("glGetUniformi64vARB", &retrace::ignore),
    ("glGetUniformui64vARB", &retrace::ignore),
    ("glGetnUniformi64vARB", &retrace::ignore),
    ("glGetnUniformui64vARB", &retrace::ignore),
    ("glProgramUniform1i64ARB", &retrace_glProgramUniform1i64ARB),
    ("glProgramUniform2i64ARB", &retrace_glProgramUniform2i64ARB),
    ("glProgramUniform3i64ARB", &retrace_glProgramUniform3i64ARB),
    ("glProgramUniform4i64ARB", &retrace_glProgramUniform4i64ARB),
    ("glProgramUniform1i64vARB", &retrace_glProgramUniform1i64vARB),
    ("glProgramUniform2i64vARB", &retrace_glProgramUniform2i64vARB),
    ("glProgramUniform3i64vARB", &retrace_glProgramUniform3i64vARB),
    ("glProgramUniform4i64vARB", &retrace_glProgramUniform4i64vARB),
    ("glProgramUniform1ui64ARB", &retrace_glProgramUniform1ui64ARB),
    ("glProgramUniform2ui64ARB", &retrace_glProgramUniform2ui64ARB),
    ("glProgramUniform3ui64ARB", &retrace_glProgramUniform3ui64ARB),
    ("glProgramUniform4ui64ARB", &retrace_glProgramUniform4ui64ARB),
    ("glProgramUniform1ui64vARB", &retrace_glProgramUniform1ui64vARB),
    ("glProgramUniform2ui64vARB", &retrace_glProgramUniform2ui64vARB),
    ("glProgramUniform3ui64vARB", &retrace_glProgramUniform3ui64vARB),
    ("glProgramUniform4ui64vARB", &retrace_glProgramUniform4ui64vARB),
    ("glMultiDrawArraysIndirectCountARB", &retrace_glMultiDrawArraysIndirectCountARB),
    ("glMultiDrawElementsIndirectCountARB", &retrace_glMultiDrawElementsIndirectCountARB),
    ("glVertexAttribDivisorARB", &retrace_glVertexAttribDivisorARB),
    ("glGetInternalformativ", &retrace::ignore),
    ("glGetInternalformati64v", &retrace::ignore),
    ("glInvalidateTexSubImage", &retrace_glInvalidateTexSubImage),
    ("glInvalidateTexImage", &retrace_glInvalidateTexImage),
    ("glInvalidateBufferSubData", &retrace_glInvalidateBufferSubData),
    ("glInvalidateBufferData", &retrace_glInvalidateBufferData),
    ("glInvalidateFramebuffer", &retrace_glInvalidateFramebuffer),
    ("glInvalidateSubFramebuffer", &retrace_glInvalidateSubFramebuffer),
    ("glMapBufferRange", &retrace_glMapBufferRange),
    ("glFlushMappedBufferRange", &retrace_glFlushMappedBufferRange),
    ("glCurrentPaletteMatrixARB", &retrace_glCurrentPaletteMatrixARB),
    ("glMatrixIndexubvARB", &retrace_glMatrixIndexubvARB),
    ("glMatrixIndexusvARB", &retrace_glMatrixIndexusvARB),
    ("glMatrixIndexuivARB", &retrace_glMatrixIndexuivARB),
    ("glMatrixIndexPointerARB", &retrace_glMatrixIndexPointerARB),
    ("glBindBuffersBase", &retrace_glBindBuffersBase),
    ("glBindBuffersRange", &retrace_glBindBuffersRange),
    ("glBindTextures", &retrace_glBindTextures),
    ("glBindSamplers", &retrace_glBindSamplers),
    ("glBindImageTextures", &retrace_glBindImageTextures),
    ("glBindVertexBuffers", &retrace_glBindVertexBuffers),
    ("glMultiDrawArraysIndirect", &retrace_glMultiDrawArraysIndirect),
    ("glMultiDrawElementsIndirect", &retrace_glMultiDrawElementsIndirect),
    ("glSampleCoverageARB", &retrace_glSampleCoverageARB),
    ("glActiveTextureARB", &retrace_glActiveTextureARB),
    ("glClientActiveTextureARB", &retrace_glClientActiveTextureARB),
    ("glMultiTexCoord1dARB", &retrace_glMultiTexCoord1dARB),
    ("glMultiTexCoord1dvARB", &retrace_glMultiTexCoord1dvARB),
    ("glMultiTexCoord1fARB", &retrace_glMultiTexCoord1fARB),
    ("glMultiTexCoord1fvARB", &retrace_glMultiTexCoord1fvARB),
    ("glMultiTexCoord1iARB", &retrace_glMultiTexCoord1iARB),
    ("glMultiTexCoord1ivARB", &retrace_glMultiTexCoord1ivARB),
    ("glMultiTexCoord1sARB", &retrace_glMultiTexCoord1sARB),
    ("glMultiTexCoord1svARB", &retrace_glMultiTexCoord1svARB),
    ("glMultiTexCoord2dARB", &retrace_glMultiTexCoord2dARB),
    ("glMultiTexCoord2dvARB", &retrace_glMultiTexCoord2dvARB),
    ("glMultiTexCoord2fARB", &retrace_glMultiTexCoord2fARB),
    ("glMultiTexCoord2fvARB", &retrace_glMultiTexCoord2fvARB),
    ("glMultiTexCoord2iARB", &retrace_glMultiTexCoord2iARB),
    ("glMultiTexCoord2ivARB", &retrace_glMultiTexCoord2ivARB),
    ("glMultiTexCoord2sARB", &retrace_glMultiTexCoord2sARB),
    ("glMultiTexCoord2svARB", &retrace_glMultiTexCoord2svARB),
    ("glMultiTexCoord3dARB", &retrace_glMultiTexCoord3dARB),
    ("glMultiTexCoord3dvARB", &retrace_glMultiTexCoord3dvARB),
    ("glMultiTexCoord3fARB", &retrace_glMultiTexCoord3fARB),
    ("glMultiTexCoord3fvARB", &retrace_glMultiTexCoord3fvARB),
    ("glMultiTexCoord3iARB", &retrace_glMultiTexCoord3iARB),
    ("glMultiTexCoord3ivARB", &retrace_glMultiTexCoord3ivARB),
    ("glMultiTexCoord3sARB", &retrace_glMultiTexCoord3sARB),
    ("glMultiTexCoord3svARB", &retrace_glMultiTexCoord3svARB),
    ("glMultiTexCoord4dARB", &retrace_glMultiTexCoord4dARB),
    ("glMultiTexCoord4dvARB", &retrace_glMultiTexCoord4dvARB),
    ("glMultiTexCoord4fARB", &retrace_glMultiTexCoord4fARB),
    ("glMultiTexCoord4fvARB", &retrace_glMultiTexCoord4fvARB),
    ("glMultiTexCoord4iARB", &retrace_glMultiTexCoord4iARB),
    ("glMultiTexCoord4ivARB", &retrace_glMultiTexCoord4ivARB),
    ("glMultiTexCoord4sARB", &retrace_glMultiTexCoord4sARB),
    ("glMultiTexCoord4svARB", &retrace_glMultiTexCoord4svARB),
    ("glGenQueriesARB", &retrace_glGenQueriesARB),
    ("glDeleteQueriesARB", &retrace_glDeleteQueriesARB),
    ("glIsQueryARB", &retrace::ignore),
    ("glBeginQueryARB", &retrace_glBeginQueryARB),
    ("glEndQueryARB", &retrace_glEndQueryARB),
    ("glGetQueryivARB", &retrace::ignore),
    ("glGetQueryObjectivARB", &retrace_glGetQueryObjectivARB),
    ("glGetQueryObjectuivARB", &retrace_glGetQueryObjectuivARB),
    ("glMaxShaderCompilerThreadsARB", &retrace_glMaxShaderCompilerThreadsARB),
    ("glPointParameterfARB", &retrace_glPointParameterfARB),
    ("glPointParameterfvARB", &retrace_glPointParameterfvARB),
    ("glGetProgramInterfaceiv", &retrace::ignore),
    ("glGetProgramResourceIndex", &retrace::ignore),
    ("glGetProgramResourceName", &retrace_glGetProgramResourceName),
    ("glGetProgramResourceiv", &retrace_glGetProgramResourceiv),
    ("glGetProgramResourceLocation", &retrace_glGetProgramResourceLocation),
    ("glGetProgramResourceLocationIndex", &retrace::ignore),
    ("glProvokingVertex", &retrace_glProvokingVertex),
    ("glGetGraphicsResetStatusARB", &retrace::ignore),
    ("glGetnMapdvARB", &retrace::ignore),
    ("glGetnMapfvARB", &retrace::ignore),
    ("glGetnMapivARB", &retrace::ignore),
    ("glGetnPixelMapfvARB", &retrace_glGetnPixelMapfvARB),
    ("glGetnPixelMapuivARB", &retrace_glGetnPixelMapuivARB),
    ("glGetnPixelMapusvARB", &retrace_glGetnPixelMapusvARB),
    ("glGetnPolygonStippleARB", &retrace_glGetnPolygonStippleARB),
    ("glGetnColorTableARB", &retrace::ignore),
    ("glGetnConvolutionFilterARB", &retrace_glGetnConvolutionFilterARB),
    ("glGetnSeparableFilterARB", &retrace_glGetnSeparableFilterARB),
    ("glGetnHistogramARB", &retrace_glGetnHistogramARB),
    ("glGetnMinmaxARB", &retrace_glGetnMinmaxARB),
    ("glGetnTexImageARB", &retrace_glGetnTexImageARB),
    ("glReadnPixelsARB", &retrace_glReadnPixelsARB),
    ("glGetnCompressedTexImageARB", &retrace_glGetnCompressedTexImageARB),
    ("glGetnUniformfvARB", &retrace::ignore),
    ("glGetnUniformivARB", &retrace::ignore),
    ("glGetnUniformuivARB", &retrace::ignore),
    ("glGetnUniformdvARB", &retrace::ignore),
    ("glFramebufferSampleLocationsfvARB", &retrace_glFramebufferSampleLocationsfvARB),
    ("glNamedFramebufferSampleLocationsfvARB", &retrace_glNamedFramebufferSampleLocationsfvARB),
    ("glEvaluateDepthValuesARB", &retrace_glEvaluateDepthValuesARB),
    ("glMinSampleShadingARB", &retrace_glMinSampleShadingARB),
    ("glGenSamplers", &retrace_glGenSamplers),
    ("glDeleteSamplers", &retrace_glDeleteSamplers),
    ("glIsSampler", &retrace::ignore),
    ("glBindSampler", &retrace_glBindSampler),
    ("glSamplerParameteri", &retrace_glSamplerParameteri),
    ("glSamplerParameteriv", &retrace_glSamplerParameteriv),
    ("glSamplerParameterf", &retrace_glSamplerParameterf),
    ("glSamplerParameterfv", &retrace_glSamplerParameterfv),
    ("glSamplerParameterIiv", &retrace_glSamplerParameterIiv),
    ("glSamplerParameterIuiv", &retrace_glSamplerParameterIuiv),
    ("glGetSamplerParameteriv", &retrace::ignore),
    ("glGetSamplerParameterIiv", &retrace::ignore),
    ("glGetSamplerParameterfv", &retrace::ignore),
    ("glGetSamplerParameterIuiv", &retrace::ignore),
    ("glUseProgramStages", &retrace_glUseProgramStages),
    ("glActiveShaderProgram", &retrace_glActiveShaderProgram),
    ("glCreateShaderProgramv", &retrace_glCreateShaderProgramv),
    ("glBindProgramPipeline", &retrace_glBindProgramPipeline),
    ("glDeleteProgramPipelines", &retrace_glDeleteProgramPipelines),
    ("glGenProgramPipelines", &retrace_glGenProgramPipelines),
    ("glIsProgramPipeline", &retrace::ignore),
    ("glGetProgramPipelineiv", &retrace::ignore),
    ("glProgramUniform1i", &retrace_glProgramUniform1i),
    ("glProgramUniform1iv", &retrace_glProgramUniform1iv),
    ("glProgramUniform1f", &retrace_glProgramUniform1f),
    ("glProgramUniform1fv", &retrace_glProgramUniform1fv),
    ("glProgramUniform1d", &retrace_glProgramUniform1d),
    ("glProgramUniform1dv", &retrace_glProgramUniform1dv),
    ("glProgramUniform1ui", &retrace_glProgramUniform1ui),
    ("glProgramUniform1uiv", &retrace_glProgramUniform1uiv),
    ("glProgramUniform2i", &retrace_glProgramUniform2i),
    ("glProgramUniform2iv", &retrace_glProgramUniform2iv),
    ("glProgramUniform2f", &retrace_glProgramUniform2f),
    ("glProgramUniform2fv", &retrace_glProgramUniform2fv),
    ("glProgramUniform2d", &retrace_glProgramUniform2d),
    ("glProgramUniform2dv", &retrace_glProgramUniform2dv),
    ("glProgramUniform2ui", &retrace_glProgramUniform2ui),
    ("glProgramUniform2uiv", &retrace_glProgramUniform2uiv),
    ("glProgramUniform3i", &retrace_glProgramUniform3i),
    ("glProgramUniform3iv", &retrace_glProgramUniform3iv),
    ("glProgramUniform3f", &retrace_glProgramUniform3f),
    ("glProgramUniform3fv", &retrace_glProgramUniform3fv),
    ("glProgramUniform3d", &retrace_glProgramUniform3d),
    ("glProgramUniform3dv", &retrace_glProgramUniform3dv),
    ("glProgramUniform3ui", &retrace_glProgramUniform3ui),
    ("glProgramUniform3uiv", &retrace_glProgramUniform3uiv),
    ("glProgramUniform4i", &retrace_glProgramUniform4i),
    ("glProgramUniform4iv", &retrace_glProgramUniform4iv),
    ("glProgramUniform4f", &retrace_glProgramUniform4f),
    ("glProgramUniform4fv", &retrace_glProgramUniform4fv),
    ("glProgramUniform4d", &retrace_glProgramUniform4d),
    ("glProgramUniform4dv", &retrace_glProgramUniform4dv),
    ("glProgramUniform4ui", &retrace_glProgramUniform4ui),
    ("glProgramUniform4uiv", &retrace_glProgramUniform4uiv),
    ("glProgramUniformMatrix2fv", &retrace_glProgramUniformMatrix2fv),
    ("glProgramUniformMatrix3fv", &retrace_glProgramUniformMatrix3fv),
    ("glProgramUniformMatrix4fv", &retrace_glProgramUniformMatrix4fv),
    ("glProgramUniformMatrix2dv", &retrace_glProgramUniformMatrix2dv),
    ("glProgramUniformMatrix3dv", &retrace_glProgramUniformMatrix3dv),
    ("glProgramUniformMatrix4dv", &retrace_glProgramUniformMatrix4dv),
    ("glProgramUniformMatrix2x3fv", &retrace_glProgramUniformMatrix2x3fv),
    ("glProgramUniformMatrix3x2fv", &retrace_glProgramUniformMatrix3x2fv),
    ("glProgramUniformMatrix2x4fv", &retrace_glProgramUniformMatrix2x4fv),
    ("glProgramUniformMatrix4x2fv", &retrace_glProgramUniformMatrix4x2fv),
    ("glProgramUniformMatrix3x4fv", &retrace_glProgramUniformMatrix3x4fv),
    ("glProgramUniformMatrix4x3fv", &retrace_glProgramUniformMatrix4x3fv),
    ("glProgramUniformMatrix2x3dv", &retrace_glProgramUniformMatrix2x3dv),
    ("glProgramUniformMatrix3x2dv", &retrace_glProgramUniformMatrix3x2dv),
    ("glProgramUniformMatrix2x4dv", &retrace_glProgramUniformMatrix2x4dv),
    ("glProgramUniformMatrix4x2dv", &retrace_glProgramUniformMatrix4x2dv),
    ("glProgramUniformMatrix3x4dv", &retrace_glProgramUniformMatrix3x4dv),
    ("glProgramUniformMatrix4x3dv", &retrace_glProgramUniformMatrix4x3dv),
    ("glValidateProgramPipeline", &retrace_glValidateProgramPipeline),
    ("glGetProgramPipelineInfoLog", &retrace::ignore),
    ("glGetActiveAtomicCounterBufferiv", &retrace::ignore),
    ("glBindImageTexture", &retrace_glBindImageTexture),
    ("glMemoryBarrier", &retrace_glMemoryBarrier),
    ("glDeleteObjectARB", &retrace_glDeleteObjectARB),
    ("glGetHandleARB", &retrace::ignore),
    ("glDetachObjectARB", &retrace_glDetachObjectARB),
    ("glCreateShaderObjectARB", &retrace_glCreateShaderObjectARB),
    ("glShaderSourceARB", &retrace_glShaderSourceARB),
    ("glCompileShaderARB", &retrace_glCompileShaderARB),
    ("glCreateProgramObjectARB", &retrace_glCreateProgramObjectARB),
    ("glAttachObjectARB", &retrace_glAttachObjectARB),
    ("glLinkProgramARB", &retrace_glLinkProgramARB),
    ("glUseProgramObjectARB", &retrace_glUseProgramObjectARB),
    ("glValidateProgramARB", &retrace_glValidateProgramARB),
    ("glUniform1fARB", &retrace_glUniform1fARB),
    ("glUniform2fARB", &retrace_glUniform2fARB),
    ("glUniform3fARB", &retrace_glUniform3fARB),
    ("glUniform4fARB", &retrace_glUniform4fARB),
    ("glUniform1iARB", &retrace_glUniform1iARB),
    ("glUniform2iARB", &retrace_glUniform2iARB),
    ("glUniform3iARB", &retrace_glUniform3iARB),
    ("glUniform4iARB", &retrace_glUniform4iARB),
    ("glUniform1fvARB", &retrace_glUniform1fvARB),
    ("glUniform2fvARB", &retrace_glUniform2fvARB),
    ("glUniform3fvARB", &retrace_glUniform3fvARB),
    ("glUniform4fvARB", &retrace_glUniform4fvARB),
    ("glUniform1ivARB", &retrace_glUniform1ivARB),
    ("glUniform2ivARB", &retrace_glUniform2ivARB),
    ("glUniform3ivARB", &retrace_glUniform3ivARB),
    ("glUniform4ivARB", &retrace_glUniform4ivARB),
    ("glUniformMatrix2fvARB", &retrace_glUniformMatrix2fvARB),
    ("glUniformMatrix3fvARB", &retrace_glUniformMatrix3fvARB),
    ("glUniformMatrix4fvARB", &retrace_glUniformMatrix4fvARB),
    ("glGetObjectParameterfvARB", &retrace::ignore),
    ("glGetObjectParameterivARB", &retrace::ignore),
    ("glGetInfoLogARB", &retrace::ignore),
    ("glGetAttachedObjectsARB", &retrace::ignore),
    ("glGetUniformLocationARB", &retrace_glGetUniformLocationARB),
    ("glGetActiveUniformARB", &retrace::ignore),
    ("glGetUniformfvARB", &retrace::ignore),
    ("glGetUniformivARB", &retrace::ignore),
    ("glGetShaderSourceARB", &retrace::ignore),
    ("glShaderStorageBlockBinding", &retrace_glShaderStorageBlockBinding),
    ("glGetSubroutineUniformLocation", &retrace_glGetSubroutineUniformLocation),
    ("glGetSubroutineIndex", &retrace_glGetSubroutineIndex),
    ("glGetActiveSubroutineUniformiv", &retrace::ignore),
    ("glGetActiveSubroutineUniformName", &retrace::ignore),
    ("glGetActiveSubroutineName", &retrace::ignore),
    ("glUniformSubroutinesuiv", &retrace_glUniformSubroutinesuiv),
    ("glGetUniformSubroutineuiv", &retrace::ignore),
    ("glGetProgramStageiv", &retrace::ignore),
    ("glNamedStringARB", &retrace_glNamedStringARB),
    ("glDeleteNamedStringARB", &retrace_glDeleteNamedStringARB),
    ("glCompileShaderIncludeARB", &retrace_glCompileShaderIncludeARB),
    ("glIsNamedStringARB", &retrace::ignore),
    ("glGetNamedStringARB", &retrace::ignore),
    ("glGetNamedStringivARB", &retrace::ignore),
    ("glBufferPageCommitmentARB", &retrace_glBufferPageCommitmentARB),
    ("glNamedBufferPageCommitmentEXT", &retrace_glNamedBufferPageCommitmentEXT),
    ("glNamedBufferPageCommitmentARB", &retrace_glNamedBufferPageCommitmentARB),
    ("glTexPageCommitmentARB", &retrace_glTexPageCommitmentARB),
    ("glFenceSync", &retrace_glFenceSync),
    ("glIsSync", &retrace::ignore),
    ("glDeleteSync", &retrace_glDeleteSync),
    ("glClientWaitSync", &retrace_glClientWaitSync),
    ("glWaitSync", &retrace_glWaitSync),
    ("glGetInteger64v", &retrace::ignore),
    ("glGetSynciv", &retrace_glGetSynciv),
    ("glPatchParameteri", &retrace_glPatchParameteri),
    ("glPatchParameterfv", &retrace_glPatchParameterfv),
    ("glTextureBarrier", &retrace_glTextureBarrier),
    ("glTexBufferARB", &retrace_glTexBufferARB),
    ("glTexBufferRange", &retrace_glTexBufferRange),
    ("glCompressedTexImage3DARB", &retrace_glCompressedTexImage3DARB),
    ("glCompressedTexImage2DARB", &retrace_glCompressedTexImage2DARB),
    ("glCompressedTexImage1DARB", &retrace_glCompressedTexImage1DARB),
    ("glCompressedTexSubImage3DARB", &retrace_glCompressedTexSubImage3DARB),
    ("glCompressedTexSubImage2DARB", &retrace_glCompressedTexSubImage2DARB),
    ("glCompressedTexSubImage1DARB", &retrace_glCompressedTexSubImage1DARB),
    ("glGetCompressedTexImageARB", &retrace_glGetCompressedTexImageARB),
    ("glTexImage2DMultisample", &retrace_glTexImage2DMultisample),
    ("glTexImage3DMultisample", &retrace_glTexImage3DMultisample),
    ("glGetMultisamplefv", &retrace::ignore),
    ("glSampleMaski", &retrace_glSampleMaski),
    ("glTexStorage1D", &retrace_glTexStorage1D),
    ("glTexStorage2D", &retrace_glTexStorage2D),
    ("glTexStorage3D", &retrace_glTexStorage3D),
    ("glTexStorageAttribs2DEXT", &retrace_glTexStorageAttribs2DEXT),
    ("glTexStorageAttribs3DEXT", &retrace_glTexStorageAttribs3DEXT),
    ("glTexStorage2DMultisample", &retrace_glTexStorage2DMultisample),
    ("glTexStorage3DMultisample", &retrace_glTexStorage3DMultisample),
    ("glEGLImageTargetTexStorageEXT", &retrace_glEGLImageTargetTexStorageEXT),
    ("glEGLImageTargetTextureStorageEXT", &retrace_glEGLImageTargetTextureStorageEXT),
    ("glTextureView", &retrace_glTextureView),
    ("glQueryCounter", &retrace_glQueryCounter),
    ("glGetQueryObjecti64v", &retrace_glGetQueryObjecti64v),
    ("glGetQueryObjectui64v", &retrace_glGetQueryObjectui64v),
    ("glBindTransformFeedback", &retrace_glBindTransformFeedback),
    ("glDeleteTransformFeedbacks", &retrace_glDeleteTransformFeedbacks),
    ("glGenTransformFeedbacks", &retrace_glGenTransformFeedbacks),
    ("glIsTransformFeedback", &retrace::ignore),
    ("glPauseTransformFeedback", &retrace_glPauseTransformFeedback),
    ("glResumeTransformFeedback", &retrace_glResumeTransformFeedback),
    ("glDrawTransformFeedback", &retrace_glDrawTransformFeedback),
    ("glDrawTransformFeedbackStream", &retrace_glDrawTransformFeedbackStream),
    ("glBeginQueryIndexed", &retrace_glBeginQueryIndexed),
    ("glEndQueryIndexed", &retrace_glEndQueryIndexed),
    ("glGetQueryIndexediv", &retrace::ignore),
    ("glDrawTransformFeedbackInstanced", &retrace_glDrawTransformFeedbackInstanced),
    ("glDrawTransformFeedbackStreamInstanced", &retrace_glDrawTransformFeedbackStreamInstanced),
    ("glLoadTransposeMatrixfARB", &retrace_glLoadTransposeMatrixfARB),
    ("glLoadTransposeMatrixdARB", &retrace_glLoadTransposeMatrixdARB),
    ("glMultTransposeMatrixfARB", &retrace_glMultTransposeMatrixfARB),
    ("glMultTransposeMatrixdARB", &retrace_glMultTransposeMatrixdARB),
    ("glGetUniformIndices", &retrace::ignore),
    ("glGetActiveUniformsiv", &retrace::ignore),
    ("glGetActiveUniformName", &retrace::ignore),
    ("glGetUniformBlockIndex", &retrace_glGetUniformBlockIndex),
    ("glGetActiveUniformBlockiv", &retrace::ignore),
    ("glGetActiveUniformBlockName", &retrace_glGetActiveUniformBlockName),
    ("glUniformBlockBinding", &retrace_glUniformBlockBinding),
    ("glBindVertexArray", &retrace_glBindVertexArray),
    ("glDeleteVertexArrays", &retrace_glDeleteVertexArrays),
    ("glGenVertexArrays", &retrace_glGenVertexArrays),
    ("glIsVertexArray", &retrace::ignore),
    ("glVertexAttribL1d", &retrace_glVertexAttribL1d),
    ("glVertexAttribL2d", &retrace_glVertexAttribL2d),
    ("glVertexAttribL3d", &retrace_glVertexAttribL3d),
    ("glVertexAttribL4d", &retrace_glVertexAttribL4d),
    ("glVertexAttribL1dv", &retrace_glVertexAttribL1dv),
    ("glVertexAttribL2dv", &retrace_glVertexAttribL2dv),
    ("glVertexAttribL3dv", &retrace_glVertexAttribL3dv),
    ("glVertexAttribL4dv", &retrace_glVertexAttribL4dv),
    ("glVertexAttribLPointer", &retrace_glVertexAttribLPointer),
    ("glGetVertexAttribLdv", &retrace::ignore),
    ("glBindVertexBuffer", &retrace_glBindVertexBuffer),
    ("glVertexAttribFormat", &retrace_glVertexAttribFormat),
    ("glVertexAttribIFormat", &retrace_glVertexAttribIFormat),
    ("glVertexAttribLFormat", &retrace_glVertexAttribLFormat),
    ("glVertexAttribBinding", &retrace_glVertexAttribBinding),
    ("glVertexBindingDivisor", &retrace_glVertexBindingDivisor),
    ("glWeightbvARB", &retrace_glWeightbvARB),
    ("glWeightsvARB", &retrace_glWeightsvARB),
    ("glWeightivARB", &retrace_glWeightivARB),
    ("glWeightfvARB", &retrace_glWeightfvARB),
    ("glWeightdvARB", &retrace_glWeightdvARB),
    ("glWeightubvARB", &retrace_glWeightubvARB),
    ("glWeightusvARB", &retrace_glWeightusvARB),
    ("glWeightuivARB", &retrace_glWeightuivARB),
    ("glWeightPointerARB", &retrace_glWeightPointerARB),
    ("glVertexBlendARB", &retrace_glVertexBlendARB),
    ("glBindBufferARB", &retrace_glBindBufferARB),
    ("glDeleteBuffersARB", &retrace_glDeleteBuffersARB),
    ("glGenBuffersARB", &retrace_glGenBuffersARB),
    ("glIsBufferARB", &retrace::ignore),
    ("glBufferDataARB", &retrace_glBufferDataARB),
    ("glBufferSubDataARB", &retrace_glBufferSubDataARB),
    ("glGetBufferSubDataARB", &retrace::ignore),
    ("glMapBufferARB", &retrace_glMapBufferARB),
    ("glUnmapBufferARB", &retrace_glUnmapBufferARB),
    ("glGetBufferParameterivARB", &retrace::ignore),
    ("glGetBufferPointervARB", &retrace::ignore),
    ("glVertexAttrib1dARB", &retrace_glVertexAttrib1dARB),
    ("glVertexAttrib1dvARB", &retrace_glVertexAttrib1dvARB),
    ("glVertexAttrib1fARB", &retrace_glVertexAttrib1fARB),
    ("glVertexAttrib1fvARB", &retrace_glVertexAttrib1fvARB),
    ("glVertexAttrib1sARB", &retrace_glVertexAttrib1sARB),
    ("glVertexAttrib1svARB", &retrace_glVertexAttrib1svARB),
    ("glVertexAttrib2dARB", &retrace_glVertexAttrib2dARB),
    ("glVertexAttrib2dvARB", &retrace_glVertexAttrib2dvARB),
    ("glVertexAttrib2fARB", &retrace_glVertexAttrib2fARB),
    ("glVertexAttrib2fvARB", &retrace_glVertexAttrib2fvARB),
    ("glVertexAttrib2sARB", &retrace_glVertexAttrib2sARB),
    ("glVertexAttrib2svARB", &retrace_glVertexAttrib2svARB),
    ("glVertexAttrib3dARB", &retrace_glVertexAttrib3dARB),
    ("glVertexAttrib3dvARB", &retrace_glVertexAttrib3dvARB),
    ("glVertexAttrib3fARB", &retrace_glVertexAttrib3fARB),
    ("glVertexAttrib3fvARB", &retrace_glVertexAttrib3fvARB),
    ("glVertexAttrib3sARB", &retrace_glVertexAttrib3sARB),
    ("glVertexAttrib3svARB", &retrace_glVertexAttrib3svARB),
    ("glVertexAttrib4NbvARB", &retrace_glVertexAttrib4NbvARB),
    ("glVertexAttrib4NivARB", &retrace_glVertexAttrib4NivARB),
    ("glVertexAttrib4NsvARB", &retrace_glVertexAttrib4NsvARB),
    ("glVertexAttrib4NubARB", &retrace_glVertexAttrib4NubARB),
    ("glVertexAttrib4NubvARB", &retrace_glVertexAttrib4NubvARB),
    ("glVertexAttrib4NuivARB", &retrace_glVertexAttrib4NuivARB),
    ("glVertexAttrib4NusvARB", &retrace_glVertexAttrib4NusvARB),
    ("glVertexAttrib4bvARB", &retrace_glVertexAttrib4bvARB),
    ("glVertexAttrib4dARB", &retrace_glVertexAttrib4dARB),
    ("glVertexAttrib4dvARB", &retrace_glVertexAttrib4dvARB),
    ("glVertexAttrib4fARB", &retrace_glVertexAttrib4fARB),
    ("glVertexAttrib4fvARB", &retrace_glVertexAttrib4fvARB),
    ("glVertexAttrib4ivARB", &retrace_glVertexAttrib4ivARB),
    ("glVertexAttrib4sARB", &retrace_glVertexAttrib4sARB),
    ("glVertexAttrib4svARB", &retrace_glVertexAttrib4svARB),
    ("glVertexAttrib4ubvARB", &retrace_glVertexAttrib4ubvARB),
    ("glVertexAttrib4uivARB", &retrace_glVertexAttrib4uivARB),
    ("glVertexAttrib4usvARB", &retrace_glVertexAttrib4usvARB),
    ("glVertexAttribPointerARB", &retrace_glVertexAttribPointerARB),
    ("glEnableVertexAttribArrayARB", &retrace_glEnableVertexAttribArrayARB),
    ("glDisableVertexAttribArrayARB", &retrace_glDisableVertexAttribArrayARB),
    ("glProgramStringARB", &retrace_glProgramStringARB),
    ("glBindProgramARB", &retrace_glBindProgramARB),
    ("glDeleteProgramsARB", &retrace_glDeleteProgramsARB),
    ("glGenProgramsARB", &retrace_glGenProgramsARB),
    ("glProgramEnvParameter4dARB", &retrace_glProgramEnvParameter4dARB),
    ("glProgramEnvParameter4dvARB", &retrace_glProgramEnvParameter4dvARB),
    ("glProgramEnvParameter4fARB", &retrace_glProgramEnvParameter4fARB),
    ("glProgramEnvParameter4fvARB", &retrace_glProgramEnvParameter4fvARB),
    ("glProgramLocalParameter4dARB", &retrace_glProgramLocalParameter4dARB),
    ("glProgramLocalParameter4dvARB", &retrace_glProgramLocalParameter4dvARB),
    ("glProgramLocalParameter4fARB", &retrace_glProgramLocalParameter4fARB),
    ("glProgramLocalParameter4fvARB", &retrace_glProgramLocalParameter4fvARB),
    ("glGetProgramEnvParameterdvARB", &retrace::ignore),
    ("glGetProgramEnvParameterfvARB", &retrace::ignore),
    ("glGetProgramLocalParameterdvARB", &retrace::ignore),
    ("glGetProgramLocalParameterfvARB", &retrace::ignore),
    ("glGetProgramivARB", &retrace::ignore),
    ("glGetProgramStringARB", &retrace::ignore),
    ("glGetVertexAttribdvARB", &retrace::ignore),
    ("glGetVertexAttribfvARB", &retrace::ignore),
    ("glGetVertexAttribivARB", &retrace::ignore),
    ("glGetVertexAttribPointervARB", &retrace::ignore),
    ("glIsProgramARB", &retrace::ignore),
    ("glBindAttribLocationARB", &retrace_glBindAttribLocationARB),
    ("glGetActiveAttribARB", &retrace::ignore),
    ("glGetAttribLocationARB", &retrace_glGetAttribLocationARB),
    ("glVertexAttribP1ui", &retrace_glVertexAttribP1ui),
    ("glVertexAttribP1uiv", &retrace_glVertexAttribP1uiv),
    ("glVertexAttribP2ui", &retrace_glVertexAttribP2ui),
    ("glVertexAttribP2uiv", &retrace_glVertexAttribP2uiv),
    ("glVertexAttribP3ui", &retrace_glVertexAttribP3ui),
    ("glVertexAttribP3uiv", &retrace_glVertexAttribP3uiv),
    ("glVertexAttribP4ui", &retrace_glVertexAttribP4ui),
    ("glVertexAttribP4uiv", &retrace_glVertexAttribP4uiv),
    ("glVertexP2ui", &retrace_glVertexP2ui),
    ("glVertexP2uiv", &retrace_glVertexP2uiv),
    ("glVertexP3ui", &retrace_glVertexP3ui),
    ("glVertexP3uiv", &retrace_glVertexP3uiv),
    ("glVertexP4ui", &retrace_glVertexP4ui),
    ("glVertexP4uiv", &retrace_glVertexP4uiv),
    ("glTexCoordP1ui", &retrace_glTexCoordP1ui),
    ("glTexCoordP1uiv", &retrace_glTexCoordP1uiv),
    ("glTexCoordP2ui", &retrace_glTexCoordP2ui),
    ("glTexCoordP2uiv", &retrace_glTexCoordP2uiv),
    ("glTexCoordP3ui", &retrace_glTexCoordP3ui),
    ("glTexCoordP3uiv", &retrace_glTexCoordP3uiv),
    ("glTexCoordP4ui", &retrace_glTexCoordP4ui),
    ("glTexCoordP4uiv", &retrace_glTexCoordP4uiv),
    ("glMultiTexCoordP1ui", &retrace_glMultiTexCoordP1ui),
    ("glMultiTexCoordP1uiv", &retrace_glMultiTexCoordP1uiv),
    ("glMultiTexCoordP2ui", &retrace_glMultiTexCoordP2ui),
    ("glMultiTexCoordP2uiv", &retrace_glMultiTexCoordP2uiv),
    ("glMultiTexCoordP3ui", &retrace_glMultiTexCoordP3ui),
    ("glMultiTexCoordP3uiv", &retrace_glMultiTexCoordP3uiv),
    ("glMultiTexCoordP4ui", &retrace_glMultiTexCoordP4ui),
    ("glMultiTexCoordP4uiv", &retrace_glMultiTexCoordP4uiv),
    ("glNormalP3ui", &retrace_glNormalP3ui),
    ("glNormalP3uiv", &retrace_glNormalP3uiv),
    ("glColorP3ui", &retrace_glColorP3ui),
    ("glColorP3uiv", &retrace_glColorP3uiv),
    ("glColorP4ui", &retrace_glColorP4ui),
    ("glColorP4uiv", &retrace_glColorP4uiv),
    ("glSecondaryColorP3ui", &retrace_glSecondaryColorP3ui),
    ("glSecondaryColorP3uiv", &retrace_glSecondaryColorP3uiv),
    ("glViewportArrayv", &retrace_glViewportArrayv),
    ("glViewportIndexedf", &retrace_glViewportIndexedf),
    ("glViewportIndexedfv", &retrace_glViewportIndexedfv),
    ("glScissorArrayv", &retrace_glScissorArrayv),
    ("glScissorIndexed", &retrace_glScissorIndexed),
    ("glScissorIndexedv", &retrace_glScissorIndexedv),
    ("glDepthRangeArrayv", &retrace_glDepthRangeArrayv),
    ("glDepthRangeIndexed", &retrace_glDepthRangeIndexed),
    ("glGetFloati_v", &retrace::ignore),
    ("glGetDoublei_v", &retrace::ignore),
    ("glWindowPos2dARB", &retrace_glWindowPos2dARB),
    ("glWindowPos2dvARB", &retrace_glWindowPos2dvARB),
    ("glWindowPos2fARB", &retrace_glWindowPos2fARB),
    ("glWindowPos2fvARB", &retrace_glWindowPos2fvARB),
    ("glWindowPos2iARB", &retrace_glWindowPos2iARB),
    ("glWindowPos2ivARB", &retrace_glWindowPos2ivARB),
    ("glWindowPos2sARB", &retrace_glWindowPos2sARB),
    ("glWindowPos2svARB", &retrace_glWindowPos2svARB),
    ("glWindowPos3dARB", &retrace_glWindowPos3dARB),
    ("glWindowPos3dvARB", &retrace_glWindowPos3dvARB),
    ("glWindowPos3fARB", &retrace_glWindowPos3fARB),
    ("glWindowPos3fvARB", &retrace_glWindowPos3fvARB),
    ("glWindowPos3iARB", &retrace_glWindowPos3iARB),
    ("glWindowPos3ivARB", &retrace_glWindowPos3ivARB),
    ("glWindowPos3sARB", &retrace_glWindowPos3sARB),
    ("glWindowPos3svARB", &retrace_glWindowPos3svARB),
    ("glDrawBuffersATI", &retrace_glDrawBuffersATI),
    ("glElementPointerATI", &retrace_glElementPointerATI),
    ("glDrawElementArrayATI", &retrace_glDrawElementArrayATI),
    ("glDrawRangeElementArrayATI", &retrace_glDrawRangeElementArrayATI),
    ("glTexBumpParameterivATI", &retrace_glTexBumpParameterivATI),
    ("glTexBumpParameterfvATI", &retrace_glTexBumpParameterfvATI),
    ("glGetTexBumpParameterivATI", &retrace::ignore),
    ("glGetTexBumpParameterfvATI", &retrace::ignore),
    ("glBlendEquationSeparateATI", &retrace_glBlendEquationSeparateATI),
    ("glGenFragmentShadersATI", &retrace_glGenFragmentShadersATI),
    ("glBindFragmentShaderATI", &retrace_glBindFragmentShaderATI),
    ("glDeleteFragmentShaderATI", &retrace_glDeleteFragmentShaderATI),
    ("glBeginFragmentShaderATI", &retrace_glBeginFragmentShaderATI),
    ("glEndFragmentShaderATI", &retrace_glEndFragmentShaderATI),
    ("glPassTexCoordATI", &retrace_glPassTexCoordATI),
    ("glSampleMapATI", &retrace_glSampleMapATI),
    ("glColorFragmentOp1ATI", &retrace_glColorFragmentOp1ATI),
    ("glColorFragmentOp2ATI", &retrace_glColorFragmentOp2ATI),
    ("glColorFragmentOp3ATI", &retrace_glColorFragmentOp3ATI),
    ("glAlphaFragmentOp1ATI", &retrace_glAlphaFragmentOp1ATI),
    ("glAlphaFragmentOp2ATI", &retrace_glAlphaFragmentOp2ATI),
    ("glAlphaFragmentOp3ATI", &retrace_glAlphaFragmentOp3ATI),
    ("glSetFragmentShaderConstantATI", &retrace_glSetFragmentShaderConstantATI),
    ("glMapObjectBufferATI", &retrace_glMapObjectBufferATI),
    ("glUnmapObjectBufferATI", &retrace_glUnmapObjectBufferATI),
    ("glPNTrianglesiATI", &retrace_glPNTrianglesiATI),
    ("glPNTrianglesfATI", &retrace_glPNTrianglesfATI),
    ("glPNTrianglesiATIX", &retrace_glPNTrianglesiATIX),
    ("glPNTrianglesfATIX", &retrace_glPNTrianglesfATIX),
    ("glStencilOpSeparateATI", &retrace_glStencilOpSeparateATI),
    ("glStencilFuncSeparateATI", &retrace_glStencilFuncSeparateATI),
    ("glNewObjectBufferATI", &retrace_glNewObjectBufferATI),
    ("glIsObjectBufferATI", &retrace::ignore),
    ("glUpdateObjectBufferATI", &retrace_glUpdateObjectBufferATI),
    ("glGetObjectBufferfvATI", &retrace::ignore),
    ("glGetObjectBufferivATI", &retrace::ignore),
    ("glFreeObjectBufferATI", &retrace_glFreeObjectBufferATI),
    ("glArrayObjectATI", &retrace_glArrayObjectATI),
    ("glGetArrayObjectfvATI", &retrace::ignore),
    ("glGetArrayObjectivATI", &retrace::ignore),
    ("glVariantArrayObjectATI", &retrace_glVariantArrayObjectATI),
    ("glGetVariantArrayObjectfvATI", &retrace::ignore),
    ("glGetVariantArrayObjectivATI", &retrace::ignore),
    ("glVertexAttribArrayObjectATI", &retrace_glVertexAttribArrayObjectATI),
    ("glGetVertexAttribArrayObjectfvATI", &retrace::ignore),
    ("glGetVertexAttribArrayObjectivATI", &retrace::ignore),
    ("glVertexStream1sATI", &retrace_glVertexStream1sATI),
    ("glVertexStream1svATI", &retrace_glVertexStream1svATI),
    ("glVertexStream1iATI", &retrace_glVertexStream1iATI),
    ("glVertexStream1ivATI", &retrace_glVertexStream1ivATI),
    ("glVertexStream1fATI", &retrace_glVertexStream1fATI),
    ("glVertexStream1fvATI", &retrace_glVertexStream1fvATI),
    ("glVertexStream1dATI", &retrace_glVertexStream1dATI),
    ("glVertexStream1dvATI", &retrace_glVertexStream1dvATI),
    ("glVertexStream2sATI", &retrace_glVertexStream2sATI),
    ("glVertexStream2svATI", &retrace_glVertexStream2svATI),
    ("glVertexStream2iATI", &retrace_glVertexStream2iATI),
    ("glVertexStream2ivATI", &retrace_glVertexStream2ivATI),
    ("glVertexStream2fATI", &retrace_glVertexStream2fATI),
    ("glVertexStream2fvATI", &retrace_glVertexStream2fvATI),
    ("glVertexStream2dATI", &retrace_glVertexStream2dATI),
    ("glVertexStream2dvATI", &retrace_glVertexStream2dvATI),
    ("glVertexStream3sATI", &retrace_glVertexStream3sATI),
    ("glVertexStream3svATI", &retrace_glVertexStream3svATI),
    ("glVertexStream3iATI", &retrace_glVertexStream3iATI),
    ("glVertexStream3ivATI", &retrace_glVertexStream3ivATI),
    ("glVertexStream3fATI", &retrace_glVertexStream3fATI),
    ("glVertexStream3fvATI", &retrace_glVertexStream3fvATI),
    ("glVertexStream3dATI", &retrace_glVertexStream3dATI),
    ("glVertexStream3dvATI", &retrace_glVertexStream3dvATI),
    ("glVertexStream4sATI", &retrace_glVertexStream4sATI),
    ("glVertexStream4svATI", &retrace_glVertexStream4svATI),
    ("glVertexStream4iATI", &retrace_glVertexStream4iATI),
    ("glVertexStream4ivATI", &retrace_glVertexStream4ivATI),
    ("glVertexStream4fATI", &retrace_glVertexStream4fATI),
    ("glVertexStream4fvATI", &retrace_glVertexStream4fvATI),
    ("glVertexStream4dATI", &retrace_glVertexStream4dATI),
    ("glVertexStream4dvATI", &retrace_glVertexStream4dvATI),
    ("glNormalStream3bATI", &retrace_glNormalStream3bATI),
    ("glNormalStream3bvATI", &retrace_glNormalStream3bvATI),
    ("glNormalStream3sATI", &retrace_glNormalStream3sATI),
    ("glNormalStream3svATI", &retrace_glNormalStream3svATI),
    ("glNormalStream3iATI", &retrace_glNormalStream3iATI),
    ("glNormalStream3ivATI", &retrace_glNormalStream3ivATI),
    ("glNormalStream3fATI", &retrace_glNormalStream3fATI),
    ("glNormalStream3fvATI", &retrace_glNormalStream3fvATI),
    ("glNormalStream3dATI", &retrace_glNormalStream3dATI),
    ("glNormalStream3dvATI", &retrace_glNormalStream3dvATI),
    ("glClientActiveVertexStreamATI", &retrace_glClientActiveVertexStreamATI),
    ("glVertexBlendEnviATI", &retrace_glVertexBlendEnviATI),
    ("glVertexBlendEnvfATI", &retrace_glVertexBlendEnvfATI),
    ("glDrawArraysInstancedBaseInstanceEXT", &retrace_glDrawArraysInstancedBaseInstanceEXT),
    ("glDrawElementsInstancedBaseInstanceEXT", &retrace_glDrawElementsInstancedBaseInstanceEXT),
    ("glDrawElementsInstancedBaseVertexBaseInstanceEXT", &retrace_glDrawElementsInstancedBaseVertexBaseInstanceEXT),
    ("glUniformBufferEXT", &retrace_glUniformBufferEXT),
    ("glGetUniformBufferSizeEXT", &retrace_glGetUniformBufferSizeEXT),
    ("glGetUniformOffsetEXT", &retrace_glGetUniformOffsetEXT),
    ("glBlendColorEXT", &retrace_glBlendColorEXT),
    ("glBlendEquationSeparateEXT", &retrace_glBlendEquationSeparateEXT),
    ("glBindFragDataLocationIndexedEXT", &retrace_glBindFragDataLocationIndexedEXT),
    ("glBindFragDataLocationEXT", &retrace_glBindFragDataLocationEXT),
    ("glGetProgramResourceLocationIndexEXT", &retrace_glGetProgramResourceLocationIndexEXT),
    ("glGetFragDataIndexEXT", &retrace_glGetFragDataIndexEXT),
    ("glBlendFuncSeparateEXT", &retrace_glBlendFuncSeparateEXT),
    ("glBlendEquationEXT", &retrace_glBlendEquationEXT),
    ("glBufferStorageEXT", &retrace_glBufferStorageEXT),
    ("glClearTexImageEXT", &retrace_glClearTexImageEXT),
    ("glClearTexSubImageEXT", &retrace_glClearTexSubImageEXT),
    ("glClipControlEXT", &retrace_glClipControlEXT),
    ("glColorSubTableEXT", &retrace_glColorSubTableEXT),
    ("glCopyColorSubTableEXT", &retrace_glCopyColorSubTableEXT),
    ("glLockArraysEXT", &retrace_glLockArraysEXT),
    ("glUnlockArraysEXT", &retrace_glUnlockArraysEXT),
    ("glConvolutionFilter1DEXT", &retrace_glConvolutionFilter1DEXT),
    ("glConvolutionFilter2DEXT", &retrace_glConvolutionFilter2DEXT),
    ("glConvolutionParameterfEXT", &retrace_glConvolutionParameterfEXT),
    ("glConvolutionParameterfvEXT", &retrace_glConvolutionParameterfvEXT),
    ("glConvolutionParameteriEXT", &retrace_glConvolutionParameteriEXT),
    ("glConvolutionParameterivEXT", &retrace_glConvolutionParameterivEXT),
    ("glCopyConvolutionFilter1DEXT", &retrace_glCopyConvolutionFilter1DEXT),
    ("glCopyConvolutionFilter2DEXT", &retrace_glCopyConvolutionFilter2DEXT),
    ("glGetConvolutionFilterEXT", &retrace_glGetConvolutionFilterEXT),
    ("glGetConvolutionParameterfvEXT", &retrace::ignore),
    ("glGetConvolutionParameterivEXT", &retrace::ignore),
    ("glGetSeparableFilterEXT", &retrace_glGetSeparableFilterEXT),
    ("glSeparableFilter2DEXT", &retrace_glSeparableFilter2DEXT),
    ("glTangent3bEXT", &retrace_glTangent3bEXT),
    ("glTangent3bvEXT", &retrace_glTangent3bvEXT),
    ("glTangent3dEXT", &retrace_glTangent3dEXT),
    ("glTangent3dvEXT", &retrace_glTangent3dvEXT),
    ("glTangent3fEXT", &retrace_glTangent3fEXT),
    ("glTangent3fvEXT", &retrace_glTangent3fvEXT),
    ("glTangent3iEXT", &retrace_glTangent3iEXT),
    ("glTangent3ivEXT", &retrace_glTangent3ivEXT),
    ("glTangent3sEXT", &retrace_glTangent3sEXT),
    ("glTangent3svEXT", &retrace_glTangent3svEXT),
    ("glBinormal3bEXT", &retrace_glBinormal3bEXT),
    ("glBinormal3bvEXT", &retrace_glBinormal3bvEXT),
    ("glBinormal3dEXT", &retrace_glBinormal3dEXT),
    ("glBinormal3dvEXT", &retrace_glBinormal3dvEXT),
    ("glBinormal3fEXT", &retrace_glBinormal3fEXT),
    ("glBinormal3fvEXT", &retrace_glBinormal3fvEXT),
    ("glBinormal3iEXT", &retrace_glBinormal3iEXT),
    ("glBinormal3ivEXT", &retrace_glBinormal3ivEXT),
    ("glBinormal3sEXT", &retrace_glBinormal3sEXT),
    ("glBinormal3svEXT", &retrace_glBinormal3svEXT),
    ("glTangentPointerEXT", &retrace_glTangentPointerEXT),
    ("glBinormalPointerEXT", &retrace_glBinormalPointerEXT),
    ("glCopyImageSubDataEXT", &retrace_glCopyImageSubDataEXT),
    ("glCopyTexImage1DEXT", &retrace_glCopyTexImage1DEXT),
    ("glCopyTexImage2DEXT", &retrace_glCopyTexImage2DEXT),
    ("glCopyTexSubImage1DEXT", &retrace_glCopyTexSubImage1DEXT),
    ("glCopyTexSubImage2DEXT", &retrace_glCopyTexSubImage2DEXT),
    ("glCopyTexSubImage3DEXT", &retrace_glCopyTexSubImage3DEXT),
    ("glCullParameterdvEXT", &retrace_glCullParameterdvEXT),
    ("glCullParameterfvEXT", &retrace_glCullParameterfvEXT),
    ("glLabelObjectEXT", &retrace_glLabelObjectEXT),
    ("glGetObjectLabelEXT", &retrace::ignore),
    ("glInsertEventMarkerEXT", &retrace_glInsertEventMarkerEXT),
    ("glPushGroupMarkerEXT", &retrace_glPushGroupMarkerEXT),
    ("glPopGroupMarkerEXT", &retrace_glPopGroupMarkerEXT),
    ("glDepthBoundsEXT", &retrace_glDepthBoundsEXT),
    ("glBindMultiTextureEXT", &retrace_glBindMultiTextureEXT),
    ("glCheckNamedFramebufferStatusEXT", &retrace_glCheckNamedFramebufferStatusEXT),
    ("glClearNamedBufferDataEXT", &retrace_glClearNamedBufferDataEXT),
    ("glClearNamedBufferSubDataEXT", &retrace_glClearNamedBufferSubDataEXT),
    ("glClientAttribDefaultEXT", &retrace_glClientAttribDefaultEXT),
    ("glCompressedMultiTexImage1DEXT", &retrace_glCompressedMultiTexImage1DEXT),
    ("glCompressedMultiTexImage2DEXT", &retrace_glCompressedMultiTexImage2DEXT),
    ("glCompressedMultiTexImage3DEXT", &retrace_glCompressedMultiTexImage3DEXT),
    ("glCompressedMultiTexSubImage1DEXT", &retrace_glCompressedMultiTexSubImage1DEXT),
    ("glCompressedMultiTexSubImage2DEXT", &retrace_glCompressedMultiTexSubImage2DEXT),
    ("glCompressedMultiTexSubImage3DEXT", &retrace_glCompressedMultiTexSubImage3DEXT),
    ("glCompressedTextureImage1DEXT", &retrace_glCompressedTextureImage1DEXT),
    ("glCompressedTextureImage2DEXT", &retrace_glCompressedTextureImage2DEXT),
    ("glCompressedTextureImage3DEXT", &retrace_glCompressedTextureImage3DEXT),
    ("glCompressedTextureSubImage1DEXT", &retrace_glCompressedTextureSubImage1DEXT),
    ("glCompressedTextureSubImage2DEXT", &retrace_glCompressedTextureSubImage2DEXT),
    ("glCompressedTextureSubImage3DEXT", &retrace_glCompressedTextureSubImage3DEXT),
    ("glCopyMultiTexImage1DEXT", &retrace_glCopyMultiTexImage1DEXT),
    ("glCopyMultiTexImage2DEXT", &retrace_glCopyMultiTexImage2DEXT),
    ("glCopyMultiTexSubImage1DEXT", &retrace_glCopyMultiTexSubImage1DEXT),
    ("glCopyMultiTexSubImage2DEXT", &retrace_glCopyMultiTexSubImage2DEXT),
    ("glCopyMultiTexSubImage3DEXT", &retrace_glCopyMultiTexSubImage3DEXT),
    ("glCopyTextureImage1DEXT", &retrace_glCopyTextureImage1DEXT),
    ("glCopyTextureImage2DEXT", &retrace_glCopyTextureImage2DEXT),
    ("glCopyTextureSubImage1DEXT", &retrace_glCopyTextureSubImage1DEXT),
    ("glCopyTextureSubImage2DEXT", &retrace_glCopyTextureSubImage2DEXT),
    ("glCopyTextureSubImage3DEXT", &retrace_glCopyTextureSubImage3DEXT),
    ("glDisableClientStateIndexedEXT", &retrace_glDisableClientStateIndexedEXT),
    ("glDisableClientStateiEXT", &retrace_glDisableClientStateiEXT),
    ("glDisableVertexArrayAttribEXT", &retrace_glDisableVertexArrayAttribEXT),
    ("glDisableVertexArrayEXT", &retrace_glDisableVertexArrayEXT),
    ("glEnableClientStateIndexedEXT", &retrace_glEnableClientStateIndexedEXT),
    ("glEnableClientStateiEXT", &retrace_glEnableClientStateiEXT),
    ("glEnableVertexArrayAttribEXT", &retrace_glEnableVertexArrayAttribEXT),
    ("glEnableVertexArrayEXT", &retrace_glEnableVertexArrayEXT),
    ("glFlushMappedNamedBufferRangeEXT", &retrace_glFlushMappedNamedBufferRangeEXT),
    ("glFramebufferDrawBufferEXT", &retrace_glFramebufferDrawBufferEXT),
    ("glFramebufferDrawBuffersEXT", &retrace_glFramebufferDrawBuffersEXT),
    ("glFramebufferReadBufferEXT", &retrace_glFramebufferReadBufferEXT),
    ("glGenerateMultiTexMipmapEXT", &retrace_glGenerateMultiTexMipmapEXT),
    ("glGenerateTextureMipmapEXT", &retrace_glGenerateTextureMipmapEXT),
    ("glGetCompressedMultiTexImageEXT", &retrace_glGetCompressedMultiTexImageEXT),
    ("glGetCompressedTextureImageEXT", &retrace_glGetCompressedTextureImageEXT),
    ("glGetDoubleIndexedvEXT", &retrace::ignore),
    ("glGetDoublei_vEXT", &retrace::ignore),
    ("glGetFloatIndexedvEXT", &retrace::ignore),
    ("glGetFloati_vEXT", &retrace::ignore),
    ("glGetFramebufferParameterivEXT", &retrace::ignore),
    ("glGetMultiTexEnvfvEXT", &retrace::ignore),
    ("glGetMultiTexEnvivEXT", &retrace::ignore),
    ("glGetMultiTexGendvEXT", &retrace::ignore),
    ("glGetMultiTexGenfvEXT", &retrace::ignore),
    ("glGetMultiTexGenivEXT", &retrace::ignore),
    ("glGetMultiTexImageEXT", &retrace_glGetMultiTexImageEXT),
    ("glGetMultiTexLevelParameterfvEXT", &retrace::ignore),
    ("glGetMultiTexLevelParameterivEXT", &retrace::ignore),
    ("glGetMultiTexParameterIivEXT", &retrace::ignore),
    ("glGetMultiTexParameterIuivEXT", &retrace::ignore),
    ("glGetMultiTexParameterfvEXT", &retrace::ignore),
    ("glGetMultiTexParameterivEXT", &retrace::ignore),
    ("glGetNamedBufferParameterivEXT", &retrace::ignore),
    ("glGetNamedBufferPointervEXT", &retrace::ignore),
    ("glGetNamedBufferSubDataEXT", &retrace::ignore),
    ("glGetNamedFramebufferAttachmentParameterivEXT", &retrace::ignore),
    ("glGetNamedFramebufferParameterivEXT", &retrace::ignore),
    ("glGetNamedProgramLocalParameterIivEXT", &retrace::ignore),
    ("glGetNamedProgramLocalParameterIuivEXT", &retrace::ignore),
    ("glGetNamedProgramLocalParameterdvEXT", &retrace::ignore),
    ("glGetNamedProgramLocalParameterfvEXT", &retrace::ignore),
    ("glGetNamedProgramStringEXT", &retrace::ignore),
    ("glGetNamedProgramivEXT", &retrace::ignore),
    ("glGetNamedRenderbufferParameterivEXT", &retrace::ignore),
    ("glGetPointerIndexedvEXT", &retrace::ignore),
    ("glGetPointeri_vEXT", &retrace::ignore),
    ("glGetTextureImageEXT", &retrace_glGetTextureImageEXT),
    ("glGetTextureLevelParameterfvEXT", &retrace::ignore),
    ("glGetTextureLevelParameterivEXT", &retrace::ignore),
    ("glGetTextureParameterIivEXT", &retrace::ignore),
    ("glGetTextureParameterIuivEXT", &retrace::ignore),
    ("glGetTextureParameterfvEXT", &retrace::ignore),
    ("glGetTextureParameterivEXT", &retrace::ignore),
    ("glGetVertexArrayIntegeri_vEXT", &retrace::ignore),
    ("glGetVertexArrayIntegervEXT", &retrace::ignore),
    ("glGetVertexArrayPointeri_vEXT", &retrace::ignore),
    ("glGetVertexArrayPointervEXT", &retrace::ignore),
    ("glMapNamedBufferEXT", &retrace_glMapNamedBufferEXT),
    ("glMapNamedBufferRangeEXT", &retrace_glMapNamedBufferRangeEXT),
    ("glMatrixFrustumEXT", &retrace_glMatrixFrustumEXT),
    ("glMatrixLoadIdentityEXT", &retrace_glMatrixLoadIdentityEXT),
    ("glMatrixLoadTransposedEXT", &retrace_glMatrixLoadTransposedEXT),
    ("glMatrixLoadTransposefEXT", &retrace_glMatrixLoadTransposefEXT),
    ("glMatrixLoaddEXT", &retrace_glMatrixLoaddEXT),
    ("glMatrixLoadfEXT", &retrace_glMatrixLoadfEXT),
    ("glMatrixMultTransposedEXT", &retrace_glMatrixMultTransposedEXT),
    ("glMatrixMultTransposefEXT", &retrace_glMatrixMultTransposefEXT),
    ("glMatrixMultdEXT", &retrace_glMatrixMultdEXT),
    ("glMatrixMultfEXT", &retrace_glMatrixMultfEXT),
    ("glMatrixOrthoEXT", &retrace_glMatrixOrthoEXT),
    ("glMatrixPopEXT", &retrace_glMatrixPopEXT),
    ("glMatrixPushEXT", &retrace_glMatrixPushEXT),
    ("glMatrixRotatedEXT", &retrace_glMatrixRotatedEXT),
    ("glMatrixRotatefEXT", &retrace_glMatrixRotatefEXT),
    ("glMatrixScaledEXT", &retrace_glMatrixScaledEXT),
    ("glMatrixScalefEXT", &retrace_glMatrixScalefEXT),
    ("glMatrixTranslatedEXT", &retrace_glMatrixTranslatedEXT),
    ("glMatrixTranslatefEXT", &retrace_glMatrixTranslatefEXT),
    ("glMultiTexBufferEXT", &retrace_glMultiTexBufferEXT),
    ("glMultiTexCoordPointerEXT", &retrace_glMultiTexCoordPointerEXT),
    ("glMultiTexEnvfEXT", &retrace_glMultiTexEnvfEXT),
    ("glMultiTexEnvfvEXT", &retrace_glMultiTexEnvfvEXT),
    ("glMultiTexEnviEXT", &retrace_glMultiTexEnviEXT),
    ("glMultiTexEnvivEXT", &retrace_glMultiTexEnvivEXT),
    ("glMultiTexGendEXT", &retrace_glMultiTexGendEXT),
    ("glMultiTexGendvEXT", &retrace_glMultiTexGendvEXT),
    ("glMultiTexGenfEXT", &retrace_glMultiTexGenfEXT),
    ("glMultiTexGenfvEXT", &retrace_glMultiTexGenfvEXT),
    ("glMultiTexGeniEXT", &retrace_glMultiTexGeniEXT),
    ("glMultiTexGenivEXT", &retrace_glMultiTexGenivEXT),
    ("glMultiTexImage1DEXT", &retrace_glMultiTexImage1DEXT),
    ("glMultiTexImage2DEXT", &retrace_glMultiTexImage2DEXT),
    ("glMultiTexImage3DEXT", &retrace_glMultiTexImage3DEXT),
    ("glMultiTexParameterIivEXT", &retrace_glMultiTexParameterIivEXT),
    ("glMultiTexParameterIuivEXT", &retrace_glMultiTexParameterIuivEXT),
    ("glMultiTexParameterfEXT", &retrace_glMultiTexParameterfEXT),
    ("glMultiTexParameterfvEXT", &retrace_glMultiTexParameterfvEXT),
    ("glMultiTexParameteriEXT", &retrace_glMultiTexParameteriEXT),
    ("glMultiTexParameterivEXT", &retrace_glMultiTexParameterivEXT),
    ("glMultiTexRenderbufferEXT", &retrace_glMultiTexRenderbufferEXT),
    ("glMultiTexSubImage1DEXT", &retrace_glMultiTexSubImage1DEXT),
    ("glMultiTexSubImage2DEXT", &retrace_glMultiTexSubImage2DEXT),
    ("glMultiTexSubImage3DEXT", &retrace_glMultiTexSubImage3DEXT),
    ("glNamedBufferDataEXT", &retrace_glNamedBufferDataEXT),
    ("glNamedBufferStorageEXT", &retrace_glNamedBufferStorageEXT),
    ("glNamedBufferSubDataEXT", &retrace_glNamedBufferSubDataEXT),
    ("glNamedCopyBufferSubDataEXT", &retrace_glNamedCopyBufferSubDataEXT),
    ("glNamedFramebufferParameteriEXT", &retrace_glNamedFramebufferParameteriEXT),
    ("glNamedFramebufferRenderbufferEXT", &retrace_glNamedFramebufferRenderbufferEXT),
    ("glNamedFramebufferTexture1DEXT", &retrace_glNamedFramebufferTexture1DEXT),
    ("glNamedFramebufferTexture2DEXT", &retrace_glNamedFramebufferTexture2DEXT),
    ("glNamedFramebufferTexture3DEXT", &retrace_glNamedFramebufferTexture3DEXT),
    ("glNamedFramebufferTextureEXT", &retrace_glNamedFramebufferTextureEXT),
    ("glNamedFramebufferTextureFaceEXT", &retrace_glNamedFramebufferTextureFaceEXT),
    ("glNamedFramebufferTextureLayerEXT", &retrace_glNamedFramebufferTextureLayerEXT),
    ("glNamedProgramLocalParameter4dEXT", &retrace_glNamedProgramLocalParameter4dEXT),
    ("glNamedProgramLocalParameter4dvEXT", &retrace_glNamedProgramLocalParameter4dvEXT),
    ("glNamedProgramLocalParameter4fEXT", &retrace_glNamedProgramLocalParameter4fEXT),
    ("glNamedProgramLocalParameter4fvEXT", &retrace_glNamedProgramLocalParameter4fvEXT),
    ("glNamedProgramLocalParameterI4iEXT", &retrace_glNamedProgramLocalParameterI4iEXT),
    ("glNamedProgramLocalParameterI4ivEXT", &retrace_glNamedProgramLocalParameterI4ivEXT),
    ("glNamedProgramLocalParameterI4uiEXT", &retrace_glNamedProgramLocalParameterI4uiEXT),
    ("glNamedProgramLocalParameterI4uivEXT", &retrace_glNamedProgramLocalParameterI4uivEXT),
    ("glNamedProgramLocalParameters4fvEXT", &retrace_glNamedProgramLocalParameters4fvEXT),
    ("glNamedProgramLocalParametersI4ivEXT", &retrace_glNamedProgramLocalParametersI4ivEXT),
    ("glNamedProgramLocalParametersI4uivEXT", &retrace_glNamedProgramLocalParametersI4uivEXT),
    ("glNamedProgramStringEXT", &retrace_glNamedProgramStringEXT),
    ("glNamedRenderbufferStorageEXT", &retrace_glNamedRenderbufferStorageEXT),
    ("glNamedRenderbufferStorageMultisampleCoverageEXT", &retrace_glNamedRenderbufferStorageMultisampleCoverageEXT),
    ("glNamedRenderbufferStorageMultisampleEXT", &retrace_glNamedRenderbufferStorageMultisampleEXT),
    ("glProgramUniform1dEXT", &retrace_glProgramUniform1dEXT),
    ("glProgramUniform1dvEXT", &retrace_glProgramUniform1dvEXT),
    ("glProgramUniform1fEXT", &retrace_glProgramUniform1fEXT),
    ("glProgramUniform1fvEXT", &retrace_glProgramUniform1fvEXT),
    ("glProgramUniform1iEXT", &retrace_glProgramUniform1iEXT),
    ("glProgramUniform1ivEXT", &retrace_glProgramUniform1ivEXT),
    ("glProgramUniform1uiEXT", &retrace_glProgramUniform1uiEXT),
    ("glProgramUniform1uivEXT", &retrace_glProgramUniform1uivEXT),
    ("glProgramUniform2dEXT", &retrace_glProgramUniform2dEXT),
    ("glProgramUniform2dvEXT", &retrace_glProgramUniform2dvEXT),
    ("glProgramUniform2fEXT", &retrace_glProgramUniform2fEXT),
    ("glProgramUniform2fvEXT", &retrace_glProgramUniform2fvEXT),
    ("glProgramUniform2iEXT", &retrace_glProgramUniform2iEXT),
    ("glProgramUniform2ivEXT", &retrace_glProgramUniform2ivEXT),
    ("glProgramUniform2uiEXT", &retrace_glProgramUniform2uiEXT),
    ("glProgramUniform2uivEXT", &retrace_glProgramUniform2uivEXT),
    ("glProgramUniform3dEXT", &retrace_glProgramUniform3dEXT),
    ("glProgramUniform3dvEXT", &retrace_glProgramUniform3dvEXT),
    ("glProgramUniform3fEXT", &retrace_glProgramUniform3fEXT),
    ("glProgramUniform3fvEXT", &retrace_glProgramUniform3fvEXT),
    ("glProgramUniform3iEXT", &retrace_glProgramUniform3iEXT),
    ("glProgramUniform3ivEXT", &retrace_glProgramUniform3ivEXT),
    ("glProgramUniform3uiEXT", &retrace_glProgramUniform3uiEXT),
    ("glProgramUniform3uivEXT", &retrace_glProgramUniform3uivEXT),
    ("glProgramUniform4dEXT", &retrace_glProgramUniform4dEXT),
    ("glProgramUniform4dvEXT", &retrace_glProgramUniform4dvEXT),
    ("glProgramUniform4fEXT", &retrace_glProgramUniform4fEXT),
    ("glProgramUniform4fvEXT", &retrace_glProgramUniform4fvEXT),
    ("glProgramUniform4iEXT", &retrace_glProgramUniform4iEXT),
    ("glProgramUniform4ivEXT", &retrace_glProgramUniform4ivEXT),
    ("glProgramUniform4uiEXT", &retrace_glProgramUniform4uiEXT),
    ("glProgramUniform4uivEXT", &retrace_glProgramUniform4uivEXT),
    ("glProgramUniformMatrix2dvEXT", &retrace_glProgramUniformMatrix2dvEXT),
    ("glProgramUniformMatrix2fvEXT", &retrace_glProgramUniformMatrix2fvEXT),
    ("glProgramUniformMatrix2x3dvEXT", &retrace_glProgramUniformMatrix2x3dvEXT),
    ("glProgramUniformMatrix2x3fvEXT", &retrace_glProgramUniformMatrix2x3fvEXT),
    ("glProgramUniformMatrix2x4dvEXT", &retrace_glProgramUniformMatrix2x4dvEXT),
    ("glProgramUniformMatrix2x4fvEXT", &retrace_glProgramUniformMatrix2x4fvEXT),
    ("glProgramUniformMatrix3dvEXT", &retrace_glProgramUniformMatrix3dvEXT),
    ("glProgramUniformMatrix3fvEXT", &retrace_glProgramUniformMatrix3fvEXT),
    ("glProgramUniformMatrix3x2dvEXT", &retrace_glProgramUniformMatrix3x2dvEXT),
    ("glProgramUniformMatrix3x2fvEXT", &retrace_glProgramUniformMatrix3x2fvEXT),
    ("glProgramUniformMatrix3x4dvEXT", &retrace_glProgramUniformMatrix3x4dvEXT),
    ("glProgramUniformMatrix3x4fvEXT", &retrace_glProgramUniformMatrix3x4fvEXT),
    ("glProgramUniformMatrix4dvEXT", &retrace_glProgramUniformMatrix4dvEXT),
    ("glProgramUniformMatrix4fvEXT", &retrace_glProgramUniformMatrix4fvEXT),
    ("glProgramUniformMatrix4x2dvEXT", &retrace_glProgramUniformMatrix4x2dvEXT),
    ("glProgramUniformMatrix4x2fvEXT", &retrace_glProgramUniformMatrix4x2fvEXT),
    ("glProgramUniformMatrix4x3dvEXT", &retrace_glProgramUniformMatrix4x3dvEXT),
    ("glProgramUniformMatrix4x3fvEXT", &retrace_glProgramUniformMatrix4x3fvEXT),
    ("glPushClientAttribDefaultEXT", &retrace_glPushClientAttribDefaultEXT),
    ("glTextureBufferEXT", &retrace_glTextureBufferEXT),
    ("glTextureBufferRangeEXT", &retrace_glTextureBufferRangeEXT),
    ("glTextureImage1DEXT", &retrace_glTextureImage1DEXT),
    ("glTextureImage2DEXT", &retrace_glTextureImage2DEXT),
    ("glTextureImage3DEXT", &retrace_glTextureImage3DEXT),
    ("glTexturePageCommitmentEXT", &retrace_glTexturePageCommitmentEXT),
    ("glTextureParameterIivEXT", &retrace_glTextureParameterIivEXT),
    ("glTextureParameterIuivEXT", &retrace_glTextureParameterIuivEXT),
    ("glTextureParameterfEXT", &retrace_glTextureParameterfEXT),
    ("glTextureParameterfvEXT", &retrace_glTextureParameterfvEXT),
    ("glTextureParameteriEXT", &retrace_glTextureParameteriEXT),
    ("glTextureParameterivEXT", &retrace_glTextureParameterivEXT),
    ("glTextureRenderbufferEXT", &retrace_glTextureRenderbufferEXT),
    ("glTextureStorage1DEXT", &retrace_glTextureStorage1DEXT),
    ("glTextureStorage2DEXT", &retrace_glTextureStorage2DEXT),
    ("glTextureStorage2DMultisampleEXT", &retrace_glTextureStorage2DMultisampleEXT),
    ("glTextureStorage3DEXT", &retrace_glTextureStorage3DEXT),
    ("glTextureStorage3DMultisampleEXT", &retrace_glTextureStorage3DMultisampleEXT),
    ("glTextureSubImage1DEXT", &retrace_glTextureSubImage1DEXT),
    ("glTextureSubImage2DEXT", &retrace_glTextureSubImage2DEXT),
    ("glTextureSubImage3DEXT", &retrace_glTextureSubImage3DEXT),
    ("glUnmapNamedBufferEXT", &retrace_glUnmapNamedBufferEXT),
    ("glVertexArrayBindVertexBufferEXT", &retrace_glVertexArrayBindVertexBufferEXT),
    ("glVertexArrayColorOffsetEXT", &retrace_glVertexArrayColorOffsetEXT),
    ("glVertexArrayEdgeFlagOffsetEXT", &retrace_glVertexArrayEdgeFlagOffsetEXT),
    ("glVertexArrayFogCoordOffsetEXT", &retrace_glVertexArrayFogCoordOffsetEXT),
    ("glVertexArrayIndexOffsetEXT", &retrace_glVertexArrayIndexOffsetEXT),
    ("glVertexArrayMultiTexCoordOffsetEXT", &retrace_glVertexArrayMultiTexCoordOffsetEXT),
    ("glVertexArrayNormalOffsetEXT", &retrace_glVertexArrayNormalOffsetEXT),
    ("glVertexArraySecondaryColorOffsetEXT", &retrace_glVertexArraySecondaryColorOffsetEXT),
    ("glVertexArrayTexCoordOffsetEXT", &retrace_glVertexArrayTexCoordOffsetEXT),
    ("glVertexArrayVertexAttribBindingEXT", &retrace_glVertexArrayVertexAttribBindingEXT),
    ("glVertexArrayVertexAttribDivisorEXT", &retrace_glVertexArrayVertexAttribDivisorEXT),
    ("glVertexArrayVertexAttribFormatEXT", &retrace_glVertexArrayVertexAttribFormatEXT),
    ("glVertexArrayVertexAttribIFormatEXT", &retrace_glVertexArrayVertexAttribIFormatEXT),
    ("glVertexArrayVertexAttribIOffsetEXT", &retrace_glVertexArrayVertexAttribIOffsetEXT),
    ("glVertexArrayVertexAttribLFormatEXT", &retrace_glVertexArrayVertexAttribLFormatEXT),
    ("glVertexArrayVertexAttribLOffsetEXT", &retrace_glVertexArrayVertexAttribLOffsetEXT),
    ("glVertexArrayVertexAttribOffsetEXT", &retrace_glVertexArrayVertexAttribOffsetEXT),
    ("glVertexArrayVertexBindingDivisorEXT", &retrace_glVertexArrayVertexBindingDivisorEXT),
    ("glVertexArrayVertexOffsetEXT", &retrace_glVertexArrayVertexOffsetEXT),
    ("glDiscardFramebufferEXT", &retrace_glDiscardFramebufferEXT),
    ("glGenQueriesEXT", &retrace_glGenQueriesEXT),
    ("glDeleteQueriesEXT", &retrace_glDeleteQueriesEXT),
    ("glIsQueryEXT", &retrace::ignore),
    ("glBeginQueryEXT", &retrace_glBeginQueryEXT),
    ("glEndQueryEXT", &retrace_glEndQueryEXT),
    ("glQueryCounterEXT", &retrace_glQueryCounterEXT),
    ("glGetQueryivEXT", &retrace::ignore),
    ("glGetQueryObjectivEXT", &retrace_glGetQueryObjectivEXT),
    ("glGetQueryObjectuivEXT", &retrace_glGetQueryObjectuivEXT),
    ("glGetQueryObjecti64vEXT", &retrace_glGetQueryObjecti64vEXT),
    ("glGetQueryObjectui64vEXT", &retrace_glGetQueryObjectui64vEXT),
    ("glDrawBuffersEXT", &retrace_glDrawBuffersEXT),
    ("glColorMaskIndexedEXT", &retrace_glColorMaskIndexedEXT),
    ("glGetBooleanIndexedvEXT", &retrace::ignore),
    ("glGetIntegerIndexedvEXT", &retrace::ignore),
    ("glEnableIndexedEXT", &retrace_glEnableIndexedEXT),
    ("glDisableIndexedEXT", &retrace_glDisableIndexedEXT),
    ("glIsEnabledIndexedEXT", &retrace::ignore),
    ("glEnableiEXT", &retrace_glEnableiEXT),
    ("glDisableiEXT", &retrace_glDisableiEXT),
    ("glBlendEquationiEXT", &retrace_glBlendEquationiEXT),
    ("glBlendEquationSeparateiEXT", &retrace_glBlendEquationSeparateiEXT),
    ("glBlendFunciEXT", &retrace_glBlendFunciEXT),
    ("glBlendFuncSeparateiEXT", &retrace_glBlendFuncSeparateiEXT),
    ("glColorMaskiEXT", &retrace_glColorMaskiEXT),
    ("glIsEnablediEXT", &retrace::ignore),
    ("glDrawElementsBaseVertexEXT", &retrace_glDrawElementsBaseVertexEXT),
    ("glDrawRangeElementsBaseVertexEXT", &retrace_glDrawRangeElementsBaseVertexEXT),
    ("glDrawElementsInstancedBaseVertexEXT", &retrace_glDrawElementsInstancedBaseVertexEXT),
    ("glMultiDrawElementsBaseVertexEXT", &retrace_glMultiDrawElementsBaseVertexEXT),
    ("glDrawArraysInstancedEXT", &retrace_glDrawArraysInstancedEXT),
    ("glDrawElementsInstancedEXT", &retrace_glDrawElementsInstancedEXT),
    ("glDrawRangeElementsEXT", &retrace_glDrawRangeElementsEXT),
    ("glFogCoordfEXT", &retrace_glFogCoordfEXT),
    ("glFogCoordfvEXT", &retrace_glFogCoordfvEXT),
    ("glFogCoorddEXT", &retrace_glFogCoorddEXT),
    ("glFogCoorddvEXT", &retrace_glFogCoorddvEXT),
    ("glFogCoordPointerEXT", &retrace_glFogCoordPointerEXT),
    ("glBlitFramebufferEXT", &retrace_glBlitFramebufferEXT),
    ("glRenderbufferStorageMultisampleEXT", &retrace_glRenderbufferStorageMultisampleEXT),
    ("glIsRenderbufferEXT", &retrace::ignore),
    ("glBindRenderbufferEXT", &retrace_glBindRenderbufferEXT),
    ("glDeleteRenderbuffersEXT", &retrace_glDeleteRenderbuffersEXT),
    ("glGenRenderbuffersEXT", &retrace_glGenRenderbuffersEXT),
    ("glRenderbufferStorageEXT", &retrace_glRenderbufferStorageEXT),
    ("glGetRenderbufferParameterivEXT", &retrace::ignore),
    ("glIsFramebufferEXT", &retrace::ignore),
    ("glBindFramebufferEXT", &retrace_glBindFramebufferEXT),
    ("glDeleteFramebuffersEXT", &retrace_glDeleteFramebuffersEXT),
    ("glGenFramebuffersEXT", &retrace_glGenFramebuffersEXT),
    ("glCheckFramebufferStatusEXT", &retrace_glCheckFramebufferStatusEXT),
    ("glFramebufferTexture1DEXT", &retrace_glFramebufferTexture1DEXT),
    ("glFramebufferTexture2DEXT", &retrace_glFramebufferTexture2DEXT),
    ("glFramebufferTexture3DEXT", &retrace_glFramebufferTexture3DEXT),
    ("glFramebufferRenderbufferEXT", &retrace_glFramebufferRenderbufferEXT),
    ("glGetFramebufferAttachmentParameterivEXT", &retrace::ignore),
    ("glGenerateMipmapEXT", &retrace_glGenerateMipmapEXT),
    ("glFramebufferTextureEXT", &retrace_glFramebufferTextureEXT),
    ("glProgramParameteriEXT", &retrace_glProgramParameteriEXT),
    ("glProgramEnvParameters4fvEXT", &retrace_glProgramEnvParameters4fvEXT),
    ("glProgramLocalParameters4fvEXT", &retrace_glProgramLocalParameters4fvEXT),
    ("glGetUniformuivEXT", &retrace::ignore),
    ("glGetFragDataLocationEXT", &retrace::ignore),
    ("glUniform1uiEXT", &retrace_glUniform1uiEXT),
    ("glUniform2uiEXT", &retrace_glUniform2uiEXT),
    ("glUniform3uiEXT", &retrace_glUniform3uiEXT),
    ("glUniform4uiEXT", &retrace_glUniform4uiEXT),
    ("glUniform1uivEXT", &retrace_glUniform1uivEXT),
    ("glUniform2uivEXT", &retrace_glUniform2uivEXT),
    ("glUniform3uivEXT", &retrace_glUniform3uivEXT),
    ("glUniform4uivEXT", &retrace_glUniform4uivEXT),
    ("glGetHistogramEXT", &retrace_glGetHistogramEXT),
    ("glGetHistogramParameterfvEXT", &retrace::ignore),
    ("glGetHistogramParameterivEXT", &retrace_glGetHistogramParameterivEXT),
    ("glGetMinmaxEXT", &retrace_glGetMinmaxEXT),
    ("glGetMinmaxParameterfvEXT", &retrace::ignore),
    ("glGetMinmaxParameterivEXT", &retrace::ignore),
    ("glHistogramEXT", &retrace_glHistogramEXT),
    ("glMinmaxEXT", &retrace_glMinmaxEXT),
    ("glResetHistogramEXT", &retrace_glResetHistogramEXT),
    ("glResetMinmaxEXT", &retrace_glResetMinmaxEXT),
    ("glIndexFuncEXT", &retrace_glIndexFuncEXT),
    ("glIndexMaterialEXT", &retrace_glIndexMaterialEXT),
    ("glVertexAttribDivisorEXT", &retrace_glVertexAttribDivisorEXT),
    ("glApplyTextureEXT", &retrace_glApplyTextureEXT),
    ("glTextureLightEXT", &retrace_glTextureLightEXT),
    ("glTextureMaterialEXT", &retrace_glTextureMaterialEXT),
    ("glMapBufferRangeEXT", &retrace_glMapBufferRangeEXT),
    ("glFlushMappedBufferRangeEXT", &retrace_glFlushMappedBufferRangeEXT),
    ("glMultiDrawArraysEXT", &retrace_glMultiDrawArraysEXT),
    ("glMultiDrawElementsEXT", &retrace_glMultiDrawElementsEXT),
    ("glMultiDrawArraysIndirectEXT", &retrace_glMultiDrawArraysIndirectEXT),
    ("glMultiDrawElementsIndirectEXT", &retrace_glMultiDrawElementsIndirectEXT),
    ("glSampleMaskEXT", &retrace_glSampleMaskEXT),
    ("glSamplePatternEXT", &retrace_glSamplePatternEXT),
    ("glFramebufferTexture2DMultisampleEXT", &retrace_glFramebufferTexture2DMultisampleEXT),
    ("glReadBufferIndexedEXT", &retrace_glReadBufferIndexedEXT),
    ("glDrawBuffersIndexedEXT", &retrace_glDrawBuffersIndexedEXT),
    ("glGetIntegeri_vEXT", &retrace::ignore),
    ("glColorTableEXT", &retrace_glColorTableEXT),
    ("glGetColorTableEXT", &retrace::ignore),
    ("glGetColorTableParameterivEXT", &retrace::ignore),
    ("glGetColorTableParameterfvEXT", &retrace::ignore),
    ("glPixelTransformParameteriEXT", &retrace_glPixelTransformParameteriEXT),
    ("glPixelTransformParameterfEXT", &retrace_glPixelTransformParameterfEXT),
    ("glPixelTransformParameterivEXT", &retrace_glPixelTransformParameterivEXT),
    ("glPixelTransformParameterfvEXT", &retrace_glPixelTransformParameterfvEXT),
    ("glGetPixelTransformParameterivEXT", &retrace::ignore),
    ("glGetPixelTransformParameterfvEXT", &retrace::ignore),
    ("glPointParameterfEXT", &retrace_glPointParameterfEXT),
    ("glPointParameterfvEXT", &retrace_glPointParameterfvEXT),
    ("glPolygonOffsetEXT", &retrace_glPolygonOffsetEXT),
    ("glPolygonOffsetClampEXT", &retrace_glPolygonOffsetClampEXT),
    ("glPrimitiveBoundingBoxEXT", &retrace_glPrimitiveBoundingBoxEXT),
    ("glProvokingVertexEXT", &retrace_glProvokingVertexEXT),
    ("glRasterSamplesEXT", &retrace_glRasterSamplesEXT),
    ("glGetGraphicsResetStatusEXT", &retrace::ignore),
    ("glReadnPixelsEXT", &retrace_glReadnPixelsEXT),
    ("glGetnUniformfvEXT", &retrace::ignore),
    ("glGetnUniformivEXT", &retrace::ignore),
    ("glSecondaryColor3bEXT", &retrace_glSecondaryColor3bEXT),
    ("glSecondaryColor3bvEXT", &retrace_glSecondaryColor3bvEXT),
    ("glSecondaryColor3dEXT", &retrace_glSecondaryColor3dEXT),
    ("glSecondaryColor3dvEXT", &retrace_glSecondaryColor3dvEXT),
    ("glSecondaryColor3fEXT", &retrace_glSecondaryColor3fEXT),
    ("glSecondaryColor3fvEXT", &retrace_glSecondaryColor3fvEXT),
    ("glSecondaryColor3iEXT", &retrace_glSecondaryColor3iEXT),
    ("glSecondaryColor3ivEXT", &retrace_glSecondaryColor3ivEXT),
    ("glSecondaryColor3sEXT", &retrace_glSecondaryColor3sEXT),
    ("glSecondaryColor3svEXT", &retrace_glSecondaryColor3svEXT),
    ("glSecondaryColor3ubEXT", &retrace_glSecondaryColor3ubEXT),
    ("glSecondaryColor3ubvEXT", &retrace_glSecondaryColor3ubvEXT),
    ("glSecondaryColor3uiEXT", &retrace_glSecondaryColor3uiEXT),
    ("glSecondaryColor3uivEXT", &retrace_glSecondaryColor3uivEXT),
    ("glSecondaryColor3usEXT", &retrace_glSecondaryColor3usEXT),
    ("glSecondaryColor3usvEXT", &retrace_glSecondaryColor3usvEXT),
    ("glSecondaryColorPointerEXT", &retrace_glSecondaryColorPointerEXT),
    ("glUseShaderProgramEXT", &retrace_glUseShaderProgramEXT),
    ("glActiveProgramEXT", &retrace_glActiveProgramEXT),
    ("glCreateShaderProgramEXT", &retrace_glCreateShaderProgramEXT),
    ("glActiveShaderProgramEXT", &retrace_glActiveShaderProgramEXT),
    ("glBindProgramPipelineEXT", &retrace_glBindProgramPipelineEXT),
    ("glCreateShaderProgramvEXT", &retrace_glCreateShaderProgramvEXT),
    ("glDeleteProgramPipelinesEXT", &retrace_glDeleteProgramPipelinesEXT),
    ("glGenProgramPipelinesEXT", &retrace_glGenProgramPipelinesEXT),
    ("glGetProgramPipelineInfoLogEXT", &retrace::ignore),
    ("glGetProgramPipelineivEXT", &retrace::ignore),
    ("glIsProgramPipelineEXT", &retrace::ignore),
    ("glUseProgramStagesEXT", &retrace_glUseProgramStagesEXT),
    ("glValidateProgramPipelineEXT", &retrace_glValidateProgramPipelineEXT),
    ("glBindImageTextureEXT", &retrace_glBindImageTextureEXT),
    ("glMemoryBarrierEXT", &retrace_glMemoryBarrierEXT),
    ("glFramebufferPixelLocalStorageSizeEXT", &retrace_glFramebufferPixelLocalStorageSizeEXT),
    ("glGetFramebufferPixelLocalStorageSizeEXT", &retrace::ignore),
    ("glClearPixelLocalStorageuiEXT", &retrace_glClearPixelLocalStorageuiEXT),
    ("glTexPageCommitmentEXT", &retrace_glTexPageCommitmentEXT),
    ("glStencilClearTagEXT", &retrace_glStencilClearTagEXT),
    ("glActiveStencilFaceEXT", &retrace_glActiveStencilFaceEXT),
    ("glTexSubImage1DEXT", &retrace_glTexSubImage1DEXT),
    ("glTexSubImage2DEXT", &retrace_glTexSubImage2DEXT),
    ("glPatchParameteriEXT", &retrace_glPatchParameteriEXT),
    ("glTexImage3DEXT", &retrace_glTexImage3DEXT),
    ("glTexSubImage3DEXT", &retrace_glTexSubImage3DEXT),
    ("glFramebufferTextureLayerEXT", &retrace_glFramebufferTextureLayerEXT),
    ("glTexParameterIivEXT", &retrace_glTexParameterIivEXT),
    ("glTexParameterIuivEXT", &retrace_glTexParameterIuivEXT),
    ("glGetTexParameterIivEXT", &retrace::ignore),
    ("glGetTexParameterIuivEXT", &retrace::ignore),
    ("glSamplerParameterIivEXT", &retrace_glSamplerParameterIivEXT),
    ("glSamplerParameterIuivEXT", &retrace_glSamplerParameterIuivEXT),
    ("glGetSamplerParameterIivEXT", &retrace::ignore),
    ("glGetSamplerParameterIuivEXT", &retrace::ignore),
    ("glTexBufferEXT", &retrace_glTexBufferEXT),
    ("glTexBufferRangeEXT", &retrace_glTexBufferRangeEXT),
    ("glClearColorIiEXT", &retrace_glClearColorIiEXT),
    ("glClearColorIuiEXT", &retrace_glClearColorIuiEXT),
    ("glAreTexturesResidentEXT", &retrace::ignore),
    ("glBindTextureEXT", &retrace_glBindTextureEXT),
    ("glDeleteTexturesEXT", &retrace_glDeleteTexturesEXT),
    ("glGenTexturesEXT", &retrace_glGenTexturesEXT),
    ("glIsTextureEXT", &retrace::ignore),
    ("glPrioritizeTexturesEXT", &retrace_glPrioritizeTexturesEXT),
    ("glTextureNormalEXT", &retrace_glTextureNormalEXT),
    ("glTexStorage1DEXT", &retrace_glTexStorage1DEXT),
    ("glTexStorage2DEXT", &retrace_glTexStorage2DEXT),
    ("glTexStorage3DEXT", &retrace_glTexStorage3DEXT),
    ("glTextureViewEXT", &retrace_glTextureViewEXT),
    ("glBeginTransformFeedbackEXT", &retrace_glBeginTransformFeedbackEXT),
    ("glEndTransformFeedbackEXT", &retrace_glEndTransformFeedbackEXT),
    ("glBindBufferRangeEXT", &retrace_glBindBufferRangeEXT),
    ("glBindBufferOffsetEXT", &retrace_glBindBufferOffsetEXT),
    ("glBindBufferBaseEXT", &retrace_glBindBufferBaseEXT),
    ("glTransformFeedbackVaryingsEXT", &retrace_glTransformFeedbackVaryingsEXT),
    ("glGetTransformFeedbackVaryingEXT", &retrace::ignore),
    ("glArrayElementEXT", &retrace_glArrayElementEXT),
    ("glColorPointerEXT", &retrace_glColorPointerEXT),
    ("glDrawArraysEXT", &retrace_glDrawArraysEXT),
    ("glEdgeFlagPointerEXT", &retrace_glEdgeFlagPointerEXT),
    ("glGetPointervEXT", &retrace::ignore),
    ("glIndexPointerEXT", &retrace_glIndexPointerEXT),
    ("glNormalPointerEXT", &retrace_glNormalPointerEXT),
    ("glTexCoordPointerEXT", &retrace_glTexCoordPointerEXT),
    ("glVertexPointerEXT", &retrace_glVertexPointerEXT),
    ("glVertexAttribL1dEXT", &retrace_glVertexAttribL1dEXT),
    ("glVertexAttribL2dEXT", &retrace_glVertexAttribL2dEXT),
    ("glVertexAttribL3dEXT", &retrace_glVertexAttribL3dEXT),
    ("glVertexAttribL4dEXT", &retrace_glVertexAttribL4dEXT),
    ("glVertexAttribL1dvEXT", &retrace_glVertexAttribL1dvEXT),
    ("glVertexAttribL2dvEXT", &retrace_glVertexAttribL2dvEXT),
    ("glVertexAttribL3dvEXT", &retrace_glVertexAttribL3dvEXT),
    ("glVertexAttribL4dvEXT", &retrace_glVertexAttribL4dvEXT),
    ("glVertexAttribLPointerEXT", &retrace_glVertexAttribLPointerEXT),
    ("glGetVertexAttribLdvEXT", &retrace::ignore),
    ("glBeginVertexShaderEXT", &retrace_glBeginVertexShaderEXT),
    ("glEndVertexShaderEXT", &retrace_glEndVertexShaderEXT),
    ("glBindVertexShaderEXT", &retrace_glBindVertexShaderEXT),
    ("glGenVertexShadersEXT", &retrace_glGenVertexShadersEXT),
    ("glDeleteVertexShaderEXT", &retrace_glDeleteVertexShaderEXT),
    ("glShaderOp1EXT", &retrace_glShaderOp1EXT),
    ("glShaderOp2EXT", &retrace_glShaderOp2EXT),
    ("glShaderOp3EXT", &retrace_glShaderOp3EXT),
    ("glSwizzleEXT", &retrace_glSwizzleEXT),
    ("glWriteMaskEXT", &retrace_glWriteMaskEXT),
    ("glInsertComponentEXT", &retrace_glInsertComponentEXT),
    ("glExtractComponentEXT", &retrace_glExtractComponentEXT),
    ("glGenSymbolsEXT", &retrace_glGenSymbolsEXT),
    ("glSetInvariantEXT", &retrace_glSetInvariantEXT),
    ("glSetLocalConstantEXT", &retrace_glSetLocalConstantEXT),
    ("glVariantbvEXT", &retrace_glVariantbvEXT),
    ("glVariantsvEXT", &retrace_glVariantsvEXT),
    ("glVariantivEXT", &retrace_glVariantivEXT),
    ("glVariantfvEXT", &retrace_glVariantfvEXT),
    ("glVariantdvEXT", &retrace_glVariantdvEXT),
    ("glVariantubvEXT", &retrace_glVariantubvEXT),
    ("glVariantusvEXT", &retrace_glVariantusvEXT),
    ("glVariantuivEXT", &retrace_glVariantuivEXT),
    ("glVariantPointerEXT", &retrace_glVariantPointerEXT),
    ("glEnableVariantClientStateEXT", &retrace_glEnableVariantClientStateEXT),
    ("glDisableVariantClientStateEXT", &retrace_glDisableVariantClientStateEXT),
    ("glBindLightParameterEXT", &retrace_glBindLightParameterEXT),
    ("glBindMaterialParameterEXT", &retrace_glBindMaterialParameterEXT),
    ("glBindTexGenParameterEXT", &retrace_glBindTexGenParameterEXT),
    ("glBindTextureUnitParameterEXT", &retrace_glBindTextureUnitParameterEXT),
    ("glBindParameterEXT", &retrace_glBindParameterEXT),
    ("glIsVariantEnabledEXT", &retrace::ignore),
    ("glGetVariantBooleanvEXT", &retrace::ignore),
    ("glGetVariantIntegervEXT", &retrace::ignore),
    ("glGetVariantFloatvEXT", &retrace::ignore),
    ("glGetVariantPointervEXT", &retrace::ignore),
    ("glGetInvariantBooleanvEXT", &retrace::ignore),
    ("glGetInvariantIntegervEXT", &retrace::ignore),
    ("glGetInvariantFloatvEXT", &retrace::ignore),
    ("glGetLocalConstantBooleanvEXT", &retrace::ignore),
    ("glGetLocalConstantIntegervEXT", &retrace::ignore),
    ("glGetLocalConstantFloatvEXT", &retrace::ignore),
    ("glVertexWeightfEXT", &retrace_glVertexWeightfEXT),
    ("glVertexWeightfvEXT", &retrace_glVertexWeightfvEXT),
    ("glVertexWeightPointerEXT", &retrace_glVertexWeightPointerEXT),
    ("glImportSyncEXT", &retrace_glImportSyncEXT),
    ("glFrameTerminatorGREMEDY", &retrace_glFrameTerminatorGREMEDY),
    ("glStringMarkerGREMEDY", &retrace_glStringMarkerGREMEDY),
    ("glImageTransformParameteriHP", &retrace_glImageTransformParameteriHP),
    ("glImageTransformParameterfHP", &retrace_glImageTransformParameterfHP),
    ("glImageTransformParameterivHP", &retrace_glImageTransformParameterivHP),
    ("glImageTransformParameterfvHP", &retrace_glImageTransformParameterfvHP),
    ("glGetImageTransformParameterivHP", &retrace::ignore),
    ("glGetImageTransformParameterfvHP", &retrace::ignore),
    ("glMultiModeDrawArraysIBM", &retrace_glMultiModeDrawArraysIBM),
    ("glMultiModeDrawElementsIBM", &retrace_glMultiModeDrawElementsIBM),
    ("glColorPointerListIBM", &retrace_glColorPointerListIBM),
    ("glSecondaryColorPointerListIBM", &retrace_glSecondaryColorPointerListIBM),
    ("glEdgeFlagPointerListIBM", &retrace_glEdgeFlagPointerListIBM),
    ("glFogCoordPointerListIBM", &retrace_glFogCoordPointerListIBM),
    ("glIndexPointerListIBM", &retrace_glIndexPointerListIBM),
    ("glNormalPointerListIBM", &retrace_glNormalPointerListIBM),
    ("glTexCoordPointerListIBM", &retrace_glTexCoordPointerListIBM),
    ("glVertexPointerListIBM", &retrace_glVertexPointerListIBM),
    ("glRenderbufferStorageMultisampleIMG", &retrace_glRenderbufferStorageMultisampleIMG),
    ("glFramebufferTexture2DMultisampleIMG", &retrace_glFramebufferTexture2DMultisampleIMG),
    ("glBlendFuncSeparateINGR", &retrace_glBlendFuncSeparateINGR),
    ("glSyncTextureINTEL", &retrace_glSyncTextureINTEL),
    ("glUnmapTexture2DINTEL", &retrace_glUnmapTexture2DINTEL),
    ("glMapTexture2DINTEL", &retrace_glMapTexture2DINTEL),
    ("glVertexPointervINTEL", &retrace_glVertexPointervINTEL),
    ("glNormalPointervINTEL", &retrace_glNormalPointervINTEL),
    ("glColorPointervINTEL", &retrace_glColorPointervINTEL),
    ("glTexCoordPointervINTEL", &retrace_glTexCoordPointervINTEL),
    ("glBeginPerfQueryINTEL", &retrace::ignore),
    ("glCreatePerfQueryINTEL", &retrace::ignore),
    ("glDeletePerfQueryINTEL", &retrace::ignore),
    ("glEndPerfQueryINTEL", &retrace::ignore),
    ("glGetFirstPerfQueryIdINTEL", &retrace::ignore),
    ("glGetNextPerfQueryIdINTEL", &retrace::ignore),
    ("glGetPerfCounterInfoINTEL", &retrace::ignore),
    ("glGetPerfQueryDataINTEL", &retrace::ignore),
    ("glGetPerfQueryIdByNameINTEL", &retrace::ignore),
    ("glGetPerfQueryInfoINTEL", &retrace::ignore),
    ("glBlendBarrierKHR", &retrace_glBlendBarrierKHR),
    ("glDebugMessageControl", &retrace_glDebugMessageControl),
    ("glDebugMessageInsert", &retrace_glDebugMessageInsert),
    ("glDebugMessageCallback", &retrace::ignore),
    ("glGetDebugMessageLog", &retrace::ignore),
    ("glPushDebugGroup", &retrace_glPushDebugGroup),
    ("glPopDebugGroup", &retrace_glPopDebugGroup),
    ("glObjectLabel", &retrace_glObjectLabel),
    ("glGetObjectLabel", &retrace::ignore),
    ("glObjectPtrLabel", &retrace_glObjectPtrLabel),
    ("glGetObjectPtrLabel", &retrace::ignore),
    ("glDebugMessageControlKHR", &retrace_glDebugMessageControlKHR),
    ("glDebugMessageInsertKHR", &retrace_glDebugMessageInsertKHR),
    ("glDebugMessageCallbackKHR", &retrace::ignore),
    ("glGetDebugMessageLogKHR", &retrace::ignore),
    ("glPushDebugGroupKHR", &retrace_glPushDebugGroupKHR),
    ("glPopDebugGroupKHR", &retrace_glPopDebugGroupKHR),
    ("glObjectLabelKHR", &retrace_glObjectLabelKHR),
    ("glGetObjectLabelKHR", &retrace::ignore),
    ("glObjectPtrLabelKHR", &retrace_glObjectPtrLabelKHR),
    ("glGetObjectPtrLabelKHR", &retrace::ignore),
    ("glGetPointervKHR", &retrace::ignore),
    ("glGetGraphicsResetStatus", &retrace::ignore),
    ("glReadnPixels", &retrace_glReadnPixels),
    ("glGetnUniformfv", &retrace::ignore),
    ("glGetnUniformiv", &retrace::ignore),
    ("glGetnUniformuiv", &retrace::ignore),
    ("glGetGraphicsResetStatusKHR", &retrace::ignore),
    ("glReadnPixelsKHR", &retrace_glReadnPixelsKHR),
    ("glGetnUniformfvKHR", &retrace::ignore),
    ("glGetnUniformivKHR", &retrace::ignore),
    ("glGetnUniformuivKHR", &retrace::ignore),
    ("glNewBufferRegion", &retrace_glNewBufferRegion),
    ("glDeleteBufferRegion", &retrace_glDeleteBufferRegion),
    ("glReadBufferRegion", &retrace_glReadBufferRegion),
    ("glDrawBufferRegion", &retrace_glDrawBufferRegion),
    ("glBufferRegionEnabled", &retrace::ignore),
    ("glResizeBuffersMESA", &retrace_glResizeBuffersMESA),
    ("glWindowPos2dMESA", &retrace_glWindowPos2dMESA),
    ("glWindowPos2dvMESA", &retrace_glWindowPos2dvMESA),
    ("glWindowPos2fMESA", &retrace_glWindowPos2fMESA),
    ("glWindowPos2fvMESA", &retrace_glWindowPos2fvMESA),
    ("glWindowPos2iMESA", &retrace_glWindowPos2iMESA),
    ("glWindowPos2ivMESA", &retrace_glWindowPos2ivMESA),
    ("glWindowPos2sMESA", &retrace_glWindowPos2sMESA),
    ("glWindowPos2svMESA", &retrace_glWindowPos2svMESA),
    ("glWindowPos3dMESA", &retrace_glWindowPos3dMESA),
    ("glWindowPos3dvMESA", &retrace_glWindowPos3dvMESA),
    ("glWindowPos3fMESA", &retrace_glWindowPos3fMESA),
    ("glWindowPos3fvMESA", &retrace_glWindowPos3fvMESA),
    ("glWindowPos3iMESA", &retrace_glWindowPos3iMESA),
    ("glWindowPos3ivMESA", &retrace_glWindowPos3ivMESA),
    ("glWindowPos3sMESA", &retrace_glWindowPos3sMESA),
    ("glWindowPos3svMESA", &retrace_glWindowPos3svMESA),
    ("glWindowPos4dMESA", &retrace_glWindowPos4dMESA),
    ("glWindowPos4dvMESA", &retrace_glWindowPos4dvMESA),
    ("glWindowPos4fMESA", &retrace_glWindowPos4fMESA),
    ("glWindowPos4fvMESA", &retrace_glWindowPos4fvMESA),
    ("glWindowPos4iMESA", &retrace_glWindowPos4iMESA),
    ("glWindowPos4ivMESA", &retrace_glWindowPos4ivMESA),
    ("glWindowPos4sMESA", &retrace_glWindowPos4sMESA),
    ("glWindowPos4svMESA", &retrace_glWindowPos4svMESA),
    ("glBeginConditionalRenderNVX", &retrace_glBeginConditionalRenderNVX),
    ("glEndConditionalRenderNVX", &retrace_glEndConditionalRenderNVX),
    ("glMultiDrawArraysIndirectBindlessNV", &retrace_glMultiDrawArraysIndirectBindlessNV),
    ("glMultiDrawElementsIndirectBindlessNV", &retrace_glMultiDrawElementsIndirectBindlessNV),
    ("glGetTextureHandleNV", &retrace_glGetTextureHandleNV),
    ("glGetTextureSamplerHandleNV", &retrace_glGetTextureSamplerHandleNV),
    ("glMakeTextureHandleResidentNV", &retrace_glMakeTextureHandleResidentNV),
    ("glMakeTextureHandleNonResidentNV", &retrace_glMakeTextureHandleNonResidentNV),
    ("glGetImageHandleNV", &retrace_glGetImageHandleNV),
    ("glMakeImageHandleResidentNV", &retrace_glMakeImageHandleResidentNV),
    ("glMakeImageHandleNonResidentNV", &retrace_glMakeImageHandleNonResidentNV),
    ("glUniformHandleui64NV", &retrace_glUniformHandleui64NV),
    ("glUniformHandleui64vNV", &retrace_glUniformHandleui64vNV),
    ("glProgramUniformHandleui64NV", &retrace_glProgramUniformHandleui64NV),
    ("glProgramUniformHandleui64vNV", &retrace_glProgramUniformHandleui64vNV),
    ("glIsTextureHandleResidentNV", &retrace::ignore),
    ("glIsImageHandleResidentNV", &retrace::ignore),
    ("glBlendParameteriNV", &retrace_glBlendParameteriNV),
    ("glBlendBarrierNV", &retrace_glBlendBarrierNV),
    ("glBeginConditionalRenderNV", &retrace_glBeginConditionalRenderNV),
    ("glEndConditionalRenderNV", &retrace_glEndConditionalRenderNV),
    ("glCopyImageSubDataNV", &retrace_glCopyImageSubDataNV),
    ("glCoverageMaskNV", &retrace_glCoverageMaskNV),
    ("glCoverageOperationNV", &retrace_glCoverageOperationNV),
    ("glDepthRangedNV", &retrace_glDepthRangedNV),
    ("glClearDepthdNV", &retrace_glClearDepthdNV),
    ("glDepthBoundsdNV", &retrace_glDepthBoundsdNV),
    ("glDrawBuffersNV", &retrace_glDrawBuffersNV),
    ("glDrawTextureNV", &retrace_glDrawTextureNV),
    ("glMapControlPointsNV", &retrace_glMapControlPointsNV),
    ("glMapParameterivNV", &retrace_glMapParameterivNV),
    ("glMapParameterfvNV", &retrace_glMapParameterfvNV),
    ("glGetMapControlPointsNV", &retrace::ignore),
    ("glGetMapParameterivNV", &retrace::ignore),
    ("glGetMapParameterfvNV", &retrace::ignore),
    ("glGetMapAttribParameterivNV", &retrace::ignore),
    ("glGetMapAttribParameterfvNV", &retrace::ignore),
    ("glEvalMapsNV", &retrace_glEvalMapsNV),
    ("glGetMultisamplefvNV", &retrace::ignore),
    ("glSampleMaskIndexedNV", &retrace_glSampleMaskIndexedNV),
    ("glTexRenderbufferNV", &retrace_glTexRenderbufferNV),
    ("glDeleteFencesNV", &retrace_glDeleteFencesNV),
    ("glGenFencesNV", &retrace_glGenFencesNV),
    ("glIsFenceNV", &retrace::ignore),
    ("glTestFenceNV", &retrace_glTestFenceNV),
    ("glGetFenceivNV", &retrace::ignore),
    ("glFinishFenceNV", &retrace_glFinishFenceNV),
    ("glSetFenceNV", &retrace_glSetFenceNV),
    ("glProgramNamedParameter4fNV", &retrace_glProgramNamedParameter4fNV),
    ("glProgramNamedParameter4dNV", &retrace_glProgramNamedParameter4dNV),
    ("glProgramNamedParameter4fvNV", &retrace_glProgramNamedParameter4fvNV),
    ("glProgramNamedParameter4dvNV", &retrace_glProgramNamedParameter4dvNV),
    ("glGetProgramNamedParameterdvNV", &retrace::ignore),
    ("glGetProgramNamedParameterfvNV", &retrace::ignore),
    ("glBlitFramebufferNV", &retrace_glBlitFramebufferNV),
    ("glCoverageModulationTableNV", &retrace_glCoverageModulationTableNV),
    ("glGetCoverageModulationTableNV", &retrace::ignore),
    ("glCoverageModulationNV", &retrace_glCoverageModulationNV),
    ("glRenderbufferStorageMultisampleCoverageNV", &retrace_glRenderbufferStorageMultisampleCoverageNV),
    ("glProgramVertexLimitNV", &retrace_glProgramVertexLimitNV),
    ("glFramebufferTextureFaceEXT", &retrace_glFramebufferTextureFaceEXT),
    ("glProgramLocalParameterI4iNV", &retrace_glProgramLocalParameterI4iNV),
    ("glProgramLocalParameterI4ivNV", &retrace_glProgramLocalParameterI4ivNV),
    ("glProgramLocalParametersI4ivNV", &retrace_glProgramLocalParametersI4ivNV),
    ("glProgramLocalParameterI4uiNV", &retrace_glProgramLocalParameterI4uiNV),
    ("glProgramLocalParameterI4uivNV", &retrace_glProgramLocalParameterI4uivNV),
    ("glProgramLocalParametersI4uivNV", &retrace_glProgramLocalParametersI4uivNV),
    ("glProgramEnvParameterI4iNV", &retrace_glProgramEnvParameterI4iNV),
    ("glProgramEnvParameterI4ivNV", &retrace_glProgramEnvParameterI4ivNV),
    ("glProgramEnvParametersI4ivNV", &retrace_glProgramEnvParametersI4ivNV),
    ("glProgramEnvParameterI4uiNV", &retrace_glProgramEnvParameterI4uiNV),
    ("glProgramEnvParameterI4uivNV", &retrace_glProgramEnvParameterI4uivNV),
    ("glProgramEnvParametersI4uivNV", &retrace_glProgramEnvParametersI4uivNV),
    ("glGetProgramLocalParameterIivNV", &retrace::ignore),
    ("glGetProgramLocalParameterIuivNV", &retrace::ignore),
    ("glGetProgramEnvParameterIivNV", &retrace::ignore),
    ("glGetProgramEnvParameterIuivNV", &retrace::ignore),
    ("glProgramSubroutineParametersuivNV", &retrace_glProgramSubroutineParametersuivNV),
    ("glGetProgramSubroutineParameteruivNV", &retrace::ignore),
    ("glUniform1i64NV", &retrace_glUniform1i64NV),
    ("glUniform2i64NV", &retrace_glUniform2i64NV),
    ("glUniform3i64NV", &retrace_glUniform3i64NV),
    ("glUniform4i64NV", &retrace_glUniform4i64NV),
    ("glUniform1i64vNV", &retrace_glUniform1i64vNV),
    ("glUniform2i64vNV", &retrace_glUniform2i64vNV),
    ("glUniform3i64vNV", &retrace_glUniform3i64vNV),
    ("glUniform4i64vNV", &retrace_glUniform4i64vNV),
    ("glUniform1ui64NV", &retrace_glUniform1ui64NV),
    ("glUniform2ui64NV", &retrace_glUniform2ui64NV),
    ("glUniform3ui64NV", &retrace_glUniform3ui64NV),
    ("glUniform4ui64NV", &retrace_glUniform4ui64NV),
    ("glUniform1ui64vNV", &retrace_glUniform1ui64vNV),
    ("glUniform2ui64vNV", &retrace_glUniform2ui64vNV),
    ("glUniform3ui64vNV", &retrace_glUniform3ui64vNV),
    ("glUniform4ui64vNV", &retrace_glUniform4ui64vNV),
    ("glGetUniformi64vNV", &retrace::ignore),
    ("glProgramUniform1i64NV", &retrace_glProgramUniform1i64NV),
    ("glProgramUniform2i64NV", &retrace_glProgramUniform2i64NV),
    ("glProgramUniform3i64NV", &retrace_glProgramUniform3i64NV),
    ("glProgramUniform4i64NV", &retrace_glProgramUniform4i64NV),
    ("glProgramUniform1i64vNV", &retrace_glProgramUniform1i64vNV),
    ("glProgramUniform2i64vNV", &retrace_glProgramUniform2i64vNV),
    ("glProgramUniform3i64vNV", &retrace_glProgramUniform3i64vNV),
    ("glProgramUniform4i64vNV", &retrace_glProgramUniform4i64vNV),
    ("glProgramUniform1ui64NV", &retrace_glProgramUniform1ui64NV),
    ("glProgramUniform2ui64NV", &retrace_glProgramUniform2ui64NV),
    ("glProgramUniform3ui64NV", &retrace_glProgramUniform3ui64NV),
    ("glProgramUniform4ui64NV", &retrace_glProgramUniform4ui64NV),
    ("glProgramUniform1ui64vNV", &retrace_glProgramUniform1ui64vNV),
    ("glProgramUniform2ui64vNV", &retrace_glProgramUniform2ui64vNV),
    ("glProgramUniform3ui64vNV", &retrace_glProgramUniform3ui64vNV),
    ("glProgramUniform4ui64vNV", &retrace_glProgramUniform4ui64vNV),
    ("glVertex2hNV", &retrace_glVertex2hNV),
    ("glVertex2hvNV", &retrace_glVertex2hvNV),
    ("glVertex3hNV", &retrace_glVertex3hNV),
    ("glVertex3hvNV", &retrace_glVertex3hvNV),
    ("glVertex4hNV", &retrace_glVertex4hNV),
    ("glVertex4hvNV", &retrace_glVertex4hvNV),
    ("glNormal3hNV", &retrace_glNormal3hNV),
    ("glNormal3hvNV", &retrace_glNormal3hvNV),
    ("glColor3hNV", &retrace_glColor3hNV),
    ("glColor3hvNV", &retrace_glColor3hvNV),
    ("glColor4hNV", &retrace_glColor4hNV),
    ("glColor4hvNV", &retrace_glColor4hvNV),
    ("glTexCoord1hNV", &retrace_glTexCoord1hNV),
    ("glTexCoord1hvNV", &retrace_glTexCoord1hvNV),
    ("glTexCoord2hNV", &retrace_glTexCoord2hNV),
    ("glTexCoord2hvNV", &retrace_glTexCoord2hvNV),
    ("glTexCoord3hNV", &retrace_glTexCoord3hNV),
    ("glTexCoord3hvNV", &retrace_glTexCoord3hvNV),
    ("glTexCoord4hNV", &retrace_glTexCoord4hNV),
    ("glTexCoord4hvNV", &retrace_glTexCoord4hvNV),
    ("glMultiTexCoord1hNV", &retrace_glMultiTexCoord1hNV),
    ("glMultiTexCoord1hvNV", &retrace_glMultiTexCoord1hvNV),
    ("glMultiTexCoord2hNV", &retrace_glMultiTexCoord2hNV),
    ("glMultiTexCoord2hvNV", &retrace_glMultiTexCoord2hvNV),
    ("glMultiTexCoord3hNV", &retrace_glMultiTexCoord3hNV),
    ("glMultiTexCoord3hvNV", &retrace_glMultiTexCoord3hvNV),
    ("glMultiTexCoord4hNV", &retrace_glMultiTexCoord4hNV),
    ("glMultiTexCoord4hvNV", &retrace_glMultiTexCoord4hvNV),
    ("glFogCoordhNV", &retrace_glFogCoordhNV),
    ("glFogCoordhvNV", &retrace_glFogCoordhvNV),
    ("glSecondaryColor3hNV", &retrace_glSecondaryColor3hNV),
    ("glSecondaryColor3hvNV", &retrace_glSecondaryColor3hvNV),
    ("glVertexWeighthNV", &retrace_glVertexWeighthNV),
    ("glVertexWeighthvNV", &retrace_glVertexWeighthvNV),
    ("glVertexAttrib1hNV", &retrace_glVertexAttrib1hNV),
    ("glVertexAttrib1hvNV", &retrace_glVertexAttrib1hvNV),
    ("glVertexAttrib2hNV", &retrace_glVertexAttrib2hNV),
    ("glVertexAttrib2hvNV", &retrace_glVertexAttrib2hvNV),
    ("glVertexAttrib3hNV", &retrace_glVertexAttrib3hNV),
    ("glVertexAttrib3hvNV", &retrace_glVertexAttrib3hvNV),
    ("glVertexAttrib4hNV", &retrace_glVertexAttrib4hNV),
    ("glVertexAttrib4hvNV", &retrace_glVertexAttrib4hvNV),
    ("glVertexAttribs1hvNV", &retrace_glVertexAttribs1hvNV),
    ("glVertexAttribs2hvNV", &retrace_glVertexAttribs2hvNV),
    ("glVertexAttribs3hvNV", &retrace_glVertexAttribs3hvNV),
    ("glVertexAttribs4hvNV", &retrace_glVertexAttribs4hvNV),
    ("glGenOcclusionQueriesNV", &retrace_glGenOcclusionQueriesNV),
    ("glDeleteOcclusionQueriesNV", &retrace_glDeleteOcclusionQueriesNV),
    ("glIsOcclusionQueryNV", &retrace::ignore),
    ("glBeginOcclusionQueryNV", &retrace_glBeginOcclusionQueryNV),
    ("glEndOcclusionQueryNV", &retrace_glEndOcclusionQueryNV),
    ("glGetOcclusionQueryivNV", &retrace::ignore),
    ("glGetOcclusionQueryuivNV", &retrace::ignore),
    ("glProgramBufferParametersfvNV", &retrace_glProgramBufferParametersfvNV),
    ("glProgramBufferParametersIivNV", &retrace_glProgramBufferParametersIivNV),
    ("glProgramBufferParametersIuivNV", &retrace_glProgramBufferParametersIuivNV),
    ("glGenPathsNV", &retrace_glGenPathsNV),
    ("glDeletePathsNV", &retrace_glDeletePathsNV),
    ("glIsPathNV", &retrace_glIsPathNV),
    ("glPathCommandsNV", &retrace_glPathCommandsNV),
    ("glPathCoordsNV", &retrace_glPathCoordsNV),
    ("glPathSubCommandsNV", &retrace_glPathSubCommandsNV),
    ("glPathSubCoordsNV", &retrace_glPathSubCoordsNV),
    ("glPathStringNV", &retrace_glPathStringNV),
    ("glPathGlyphsNV", &retrace_glPathGlyphsNV),
    ("glPathGlyphRangeNV", &retrace_glPathGlyphRangeNV),
    ("glWeightPathsNV", &retrace_glWeightPathsNV),
    ("glCopyPathNV", &retrace_glCopyPathNV),
    ("glInterpolatePathsNV", &retrace_glInterpolatePathsNV),
    ("glTransformPathNV", &retrace_glTransformPathNV),
    ("glPathParameterivNV", &retrace_glPathParameterivNV),
    ("glPathParameteriNV", &retrace_glPathParameteriNV),
    ("glPathParameterfvNV", &retrace_glPathParameterfvNV),
    ("glPathParameterfNV", &retrace_glPathParameterfNV),
    ("glPathDashArrayNV", &retrace_glPathDashArrayNV),
    ("glPathStencilFuncNV", &retrace_glPathStencilFuncNV),
    ("glPathStencilDepthOffsetNV", &retrace_glPathStencilDepthOffsetNV),
    ("glStencilFillPathNV", &retrace_glStencilFillPathNV),
    ("glStencilStrokePathNV", &retrace_glStencilStrokePathNV),
    ("glStencilFillPathInstancedNV", &retrace_glStencilFillPathInstancedNV),
    ("glStencilStrokePathInstancedNV", &retrace_glStencilStrokePathInstancedNV),
    ("glPathCoverDepthFuncNV", &retrace_glPathCoverDepthFuncNV),
    ("glPathColorGenNV", &retrace_glPathColorGenNV),
    ("glPathTexGenNV", &retrace_glPathTexGenNV),
    ("glPathFogGenNV", &retrace_glPathFogGenNV),
    ("glCoverFillPathNV", &retrace_glCoverFillPathNV),
    ("glCoverStrokePathNV", &retrace_glCoverStrokePathNV),
    ("glCoverFillPathInstancedNV", &retrace_glCoverFillPathInstancedNV),
    ("glCoverStrokePathInstancedNV", &retrace_glCoverStrokePathInstancedNV),
    ("glGetPathParameterivNV", &retrace::ignore),
    ("glGetPathParameterfvNV", &retrace::ignore),
    ("glGetPathCommandsNV", &retrace::ignore),
    ("glGetPathCoordsNV", &retrace::ignore),
    ("glGetPathDashArrayNV", &retrace::ignore),
    ("glGetPathMetricsNV", &retrace::ignore),
    ("glGetPathMetricRangeNV", &retrace::ignore),
    ("glGetPathSpacingNV", &retrace_glGetPathSpacingNV),
    ("glGetPathColorGenivNV", &retrace::ignore),
    ("glGetPathColorGenfvNV", &retrace::ignore),
    ("glGetPathTexGenivNV", &retrace::ignore),
    ("glGetPathTexGenfvNV", &retrace::ignore),
    ("glIsPointInFillPathNV", &retrace::ignore),
    ("glIsPointInStrokePathNV", &retrace::ignore),
    ("glGetPathLengthNV", &retrace_glGetPathLengthNV),
    ("glPointAlongPathNV", &retrace::ignore),
    ("glMatrixLoad3x2fNV", &retrace_glMatrixLoad3x2fNV),
    ("glMatrixLoad3x3fNV", &retrace_glMatrixLoad3x3fNV),
    ("glMatrixLoadTranspose3x3fNV", &retrace_glMatrixLoadTranspose3x3fNV),
    ("glMatrixMult3x2fNV", &retrace_glMatrixMult3x2fNV),
    ("glMatrixMult3x3fNV", &retrace_glMatrixMult3x3fNV),
    ("glMatrixMultTranspose3x3fNV", &retrace_glMatrixMultTranspose3x3fNV),
    ("glStencilThenCoverFillPathNV", &retrace_glStencilThenCoverFillPathNV),
    ("glStencilThenCoverStrokePathNV", &retrace_glStencilThenCoverStrokePathNV),
    ("glStencilThenCoverFillPathInstancedNV", &retrace_glStencilThenCoverFillPathInstancedNV),
    ("glStencilThenCoverStrokePathInstancedNV", &retrace_glStencilThenCoverStrokePathInstancedNV),
    ("glPathGlyphIndexRangeNV", &retrace_glPathGlyphIndexRangeNV),
    ("glPathGlyphIndexArrayNV", &retrace_glPathGlyphIndexArrayNV),
    ("glPathMemoryGlyphIndexArrayNV", &retrace_glPathMemoryGlyphIndexArrayNV),
    ("glProgramPathFragmentInputGenNV", &retrace_glProgramPathFragmentInputGenNV),
    ("glGetProgramResourcefvNV", &retrace::ignore),
    ("glPixelDataRangeNV", &retrace_glPixelDataRangeNV),
    ("glFlushPixelDataRangeNV", &retrace_glFlushPixelDataRangeNV),
    ("glPointParameteriNV", &retrace_glPointParameteriNV),
    ("glPointParameterivNV", &retrace_glPointParameterivNV),
    ("glPresentFrameKeyedNV", &retrace_glPresentFrameKeyedNV),
    ("glPresentFrameDualFillNV", &retrace_glPresentFrameDualFillNV),
    ("glGetVideoivNV", &retrace::ignore),
    ("glGetVideouivNV", &retrace::ignore),
    ("glGetVideoi64vNV", &retrace::ignore),
    ("glGetVideoui64vNV", &retrace::ignore),
    ("glPrimitiveRestartNV", &retrace_glPrimitiveRestartNV),
    ("glPrimitiveRestartIndexNV", &retrace_glPrimitiveRestartIndexNV),
    ("glReadBufferNV", &retrace_glReadBufferNV),
    ("glCombinerParameterfvNV", &retrace_glCombinerParameterfvNV),
    ("glCombinerParameterfNV", &retrace_glCombinerParameterfNV),
    ("glCombinerParameterivNV", &retrace_glCombinerParameterivNV),
    ("glCombinerParameteriNV", &retrace_glCombinerParameteriNV),
    ("glCombinerInputNV", &retrace_glCombinerInputNV),
    ("glCombinerOutputNV", &retrace_glCombinerOutputNV),
    ("glFinalCombinerInputNV", &retrace_glFinalCombinerInputNV),
    ("glGetCombinerInputParameterfvNV", &retrace::ignore),
    ("glGetCombinerInputParameterivNV", &retrace::ignore),
    ("glGetCombinerOutputParameterfvNV", &retrace::ignore),
    ("glGetCombinerOutputParameterivNV", &retrace::ignore),
    ("glGetFinalCombinerInputParameterfvNV", &retrace::ignore),
    ("glGetFinalCombinerInputParameterivNV", &retrace::ignore),
    ("glCombinerStageParameterfvNV", &retrace_glCombinerStageParameterfvNV),
    ("glGetCombinerStageParameterfvNV", &retrace::ignore),
    ("glMakeBufferResidentNV", &retrace_glMakeBufferResidentNV),
    ("glMakeBufferNonResidentNV", &retrace_glMakeBufferNonResidentNV),
    ("glIsBufferResidentNV", &retrace::ignore),
    ("glMakeNamedBufferResidentNV", &retrace_glMakeNamedBufferResidentNV),
    ("glMakeNamedBufferNonResidentNV", &retrace_glMakeNamedBufferNonResidentNV),
    ("glIsNamedBufferResidentNV", &retrace::ignore),
    ("glGetBufferParameterui64vNV", &retrace::ignore),
    ("glGetNamedBufferParameterui64vNV", &retrace::ignore),
    ("glGetIntegerui64vNV", &retrace::ignore),
    ("glUniformui64NV", &retrace_glUniformui64NV),
    ("glUniformui64vNV", &retrace_glUniformui64vNV),
    ("glGetUniformui64vNV", &retrace::ignore),
    ("glProgramUniformui64NV", &retrace_glProgramUniformui64NV),
    ("glProgramUniformui64vNV", &retrace_glProgramUniformui64vNV),
    ("glTextureBarrierNV", &retrace_glTextureBarrierNV),
    ("glTexImage2DMultisampleCoverageNV", &retrace_glTexImage2DMultisampleCoverageNV),
    ("glTexImage3DMultisampleCoverageNV", &retrace_glTexImage3DMultisampleCoverageNV),
    ("glTextureImage2DMultisampleNV", &retrace_glTextureImage2DMultisampleNV),
    ("glTextureImage3DMultisampleNV", &retrace_glTextureImage3DMultisampleNV),
    ("glTextureImage2DMultisampleCoverageNV", &retrace_glTextureImage2DMultisampleCoverageNV),
    ("glTextureImage3DMultisampleCoverageNV", &retrace_glTextureImage3DMultisampleCoverageNV),
    ("glBeginTransformFeedbackNV", &retrace_glBeginTransformFeedbackNV),
    ("glEndTransformFeedbackNV", &retrace_glEndTransformFeedbackNV),
    ("glTransformFeedbackAttribsNV", &retrace_glTransformFeedbackAttribsNV),
    ("glBindBufferRangeNV", &retrace_glBindBufferRangeNV),
    ("glBindBufferOffsetNV", &retrace_glBindBufferOffsetNV),
    ("glBindBufferBaseNV", &retrace_glBindBufferBaseNV),
    ("glTransformFeedbackVaryingsNV", &retrace_glTransformFeedbackVaryingsNV),
    ("glActiveVaryingNV", &retrace_glActiveVaryingNV),
    ("glGetVaryingLocationNV", &retrace_glGetVaryingLocationNV),
    ("glGetActiveVaryingNV", &retrace::ignore),
    ("glGetTransformFeedbackVaryingNV", &retrace::ignore),
    ("glTransformFeedbackStreamAttribsNV", &retrace_glTransformFeedbackStreamAttribsNV),
    ("glBindTransformFeedbackNV", &retrace_glBindTransformFeedbackNV),
    ("glDeleteTransformFeedbacksNV", &retrace_glDeleteTransformFeedbacksNV),
    ("glGenTransformFeedbacksNV", &retrace_glGenTransformFeedbacksNV),
    ("glIsTransformFeedbackNV", &retrace::ignore),
    ("glPauseTransformFeedbackNV", &retrace_glPauseTransformFeedbackNV),
    ("glResumeTransformFeedbackNV", &retrace_glResumeTransformFeedbackNV),
    ("glDrawTransformFeedbackNV", &retrace_glDrawTransformFeedbackNV),
    ("glVDPAUInitNV", &retrace_glVDPAUInitNV),
    ("glVDPAUFiniNV", &retrace_glVDPAUFiniNV),
    ("glVDPAURegisterVideoSurfaceNV", &retrace_glVDPAURegisterVideoSurfaceNV),
    ("glVDPAURegisterOutputSurfaceNV", &retrace_glVDPAURegisterOutputSurfaceNV),
    ("glVDPAUIsSurfaceNV", &retrace::ignore),
    ("glVDPAUUnregisterSurfaceNV", &retrace_glVDPAUUnregisterSurfaceNV),
    ("glVDPAUGetSurfaceivNV", &retrace_glVDPAUGetSurfaceivNV),
    ("glVDPAUSurfaceAccessNV", &retrace_glVDPAUSurfaceAccessNV),
    ("glVDPAUMapSurfacesNV", &retrace_glVDPAUMapSurfacesNV),
    ("glVDPAUUnmapSurfacesNV", &retrace_glVDPAUUnmapSurfacesNV),
    ("glFlushVertexArrayRangeNV", &retrace_glFlushVertexArrayRangeNV),
    ("glVertexArrayRangeNV", &retrace_glVertexArrayRangeNV),
    ("glVertexAttribL1i64NV", &retrace_glVertexAttribL1i64NV),
    ("glVertexAttribL2i64NV", &retrace_glVertexAttribL2i64NV),
    ("glVertexAttribL3i64NV", &retrace_glVertexAttribL3i64NV),
    ("glVertexAttribL4i64NV", &retrace_glVertexAttribL4i64NV),
    ("glVertexAttribL1i64vNV", &retrace_glVertexAttribL1i64vNV),
    ("glVertexAttribL2i64vNV", &retrace_glVertexAttribL2i64vNV),
    ("glVertexAttribL3i64vNV", &retrace_glVertexAttribL3i64vNV),
    ("glVertexAttribL4i64vNV", &retrace_glVertexAttribL4i64vNV),
    ("glVertexAttribL1ui64NV", &retrace_glVertexAttribL1ui64NV),
    ("glVertexAttribL2ui64NV", &retrace_glVertexAttribL2ui64NV),
    ("glVertexAttribL3ui64NV", &retrace_glVertexAttribL3ui64NV),
    ("glVertexAttribL4ui64NV", &retrace_glVertexAttribL4ui64NV),
    ("glVertexAttribL1ui64vNV", &retrace_glVertexAttribL1ui64vNV),
    ("glVertexAttribL2ui64vNV", &retrace_glVertexAttribL2ui64vNV),
    ("glVertexAttribL3ui64vNV", &retrace_glVertexAttribL3ui64vNV),
    ("glVertexAttribL4ui64vNV", &retrace_glVertexAttribL4ui64vNV),
    ("glGetVertexAttribLi64vNV", &retrace::ignore),
    ("glGetVertexAttribLui64vNV", &retrace::ignore),
    ("glVertexAttribLFormatNV", &retrace_glVertexAttribLFormatNV),
    ("glBufferAddressRangeNV", &retrace_glBufferAddressRangeNV),
    ("glVertexFormatNV", &retrace_glVertexFormatNV),
    ("glNormalFormatNV", &retrace_glNormalFormatNV),
    ("glColorFormatNV", &retrace_glColorFormatNV),
    ("glIndexFormatNV", &retrace_glIndexFormatNV),
    ("glTexCoordFormatNV", &retrace_glTexCoordFormatNV),
    ("glEdgeFlagFormatNV", &retrace_glEdgeFlagFormatNV),
    ("glSecondaryColorFormatNV", &retrace_glSecondaryColorFormatNV),
    ("glFogCoordFormatNV", &retrace_glFogCoordFormatNV),
    ("glVertexAttribFormatNV", &retrace_glVertexAttribFormatNV),
    ("glVertexAttribIFormatNV", &retrace_glVertexAttribIFormatNV),
    ("glGetIntegerui64i_vNV", &retrace::ignore),
    ("glAreProgramsResidentNV", &retrace::ignore),
    ("glBindProgramNV", &retrace_glBindProgramNV),
    ("glDeleteProgramsNV", &retrace_glDeleteProgramsNV),
    ("glExecuteProgramNV", &retrace_glExecuteProgramNV),
    ("glGenProgramsNV", &retrace_glGenProgramsNV),
    ("glGetProgramParameterdvNV", &retrace::ignore),
    ("glGetProgramParameterfvNV", &retrace::ignore),
    ("glGetProgramivNV", &retrace::ignore),
    ("glGetProgramStringNV", &retrace::ignore),
    ("glGetTrackMatrixivNV", &retrace::ignore),
    ("glGetVertexAttribdvNV", &retrace::ignore),
    ("glGetVertexAttribfvNV", &retrace::ignore),
    ("glGetVertexAttribivNV", &retrace::ignore),
    ("glGetVertexAttribPointervNV", &retrace::ignore),
    ("glIsProgramNV", &retrace::ignore),
    ("glLoadProgramNV", &retrace_glLoadProgramNV),
    ("glProgramParameter4dNV", &retrace_glProgramParameter4dNV),
    ("glProgramParameter4dvNV", &retrace_glProgramParameter4dvNV),
    ("glProgramParameter4fNV", &retrace_glProgramParameter4fNV),
    ("glProgramParameter4fvNV", &retrace_glProgramParameter4fvNV),
    ("glProgramParameters4dvNV", &retrace_glProgramParameters4dvNV),
    ("glProgramParameters4fvNV", &retrace_glProgramParameters4fvNV),
    ("glRequestResidentProgramsNV", &retrace_glRequestResidentProgramsNV),
    ("glTrackMatrixNV", &retrace_glTrackMatrixNV),
    ("glVertexAttribPointerNV", &retrace_glVertexAttribPointerNV),
    ("glVertexAttrib1dNV", &retrace_glVertexAttrib1dNV),
    ("glVertexAttrib1dvNV", &retrace_glVertexAttrib1dvNV),
    ("glVertexAttrib1fNV", &retrace_glVertexAttrib1fNV),
    ("glVertexAttrib1fvNV", &retrace_glVertexAttrib1fvNV),
    ("glVertexAttrib1sNV", &retrace_glVertexAttrib1sNV),
    ("glVertexAttrib1svNV", &retrace_glVertexAttrib1svNV),
    ("glVertexAttrib2dNV", &retrace_glVertexAttrib2dNV),
    ("glVertexAttrib2dvNV", &retrace_glVertexAttrib2dvNV),
    ("glVertexAttrib2fNV", &retrace_glVertexAttrib2fNV),
    ("glVertexAttrib2fvNV", &retrace_glVertexAttrib2fvNV),
    ("glVertexAttrib2sNV", &retrace_glVertexAttrib2sNV),
    ("glVertexAttrib2svNV", &retrace_glVertexAttrib2svNV),
    ("glVertexAttrib3dNV", &retrace_glVertexAttrib3dNV),
    ("glVertexAttrib3dvNV", &retrace_glVertexAttrib3dvNV),
    ("glVertexAttrib3fNV", &retrace_glVertexAttrib3fNV),
    ("glVertexAttrib3fvNV", &retrace_glVertexAttrib3fvNV),
    ("glVertexAttrib3sNV", &retrace_glVertexAttrib3sNV),
    ("glVertexAttrib3svNV", &retrace_glVertexAttrib3svNV),
    ("glVertexAttrib4dNV", &retrace_glVertexAttrib4dNV),
    ("glVertexAttrib4dvNV", &retrace_glVertexAttrib4dvNV),
    ("glVertexAttrib4fNV", &retrace_glVertexAttrib4fNV),
    ("glVertexAttrib4fvNV", &retrace_glVertexAttrib4fvNV),
    ("glVertexAttrib4sNV", &retrace_glVertexAttrib4sNV),
    ("glVertexAttrib4svNV", &retrace_glVertexAttrib4svNV),
    ("glVertexAttrib4ubNV", &retrace_glVertexAttrib4ubNV),
    ("glVertexAttrib4ubvNV", &retrace_glVertexAttrib4ubvNV),
    ("glVertexAttribs1dvNV", &retrace_glVertexAttribs1dvNV),
    ("glVertexAttribs1fvNV", &retrace_glVertexAttribs1fvNV),
    ("glVertexAttribs1svNV", &retrace_glVertexAttribs1svNV),
    ("glVertexAttribs2dvNV", &retrace_glVertexAttribs2dvNV),
    ("glVertexAttribs2fvNV", &retrace_glVertexAttribs2fvNV),
    ("glVertexAttribs2svNV", &retrace_glVertexAttribs2svNV),
    ("glVertexAttribs3dvNV", &retrace_glVertexAttribs3dvNV),
    ("glVertexAttribs3fvNV", &retrace_glVertexAttribs3fvNV),
    ("glVertexAttribs3svNV", &retrace_glVertexAttribs3svNV),
    ("glVertexAttribs4dvNV", &retrace_glVertexAttribs4dvNV),
    ("glVertexAttribs4fvNV", &retrace_glVertexAttribs4fvNV),
    ("glVertexAttribs4svNV", &retrace_glVertexAttribs4svNV),
    ("glVertexAttribs4ubvNV", &retrace_glVertexAttribs4ubvNV),
    ("glVertexAttribI1iEXT", &retrace_glVertexAttribI1iEXT),
    ("glVertexAttribI2iEXT", &retrace_glVertexAttribI2iEXT),
    ("glVertexAttribI3iEXT", &retrace_glVertexAttribI3iEXT),
    ("glVertexAttribI4iEXT", &retrace_glVertexAttribI4iEXT),
    ("glVertexAttribI1uiEXT", &retrace_glVertexAttribI1uiEXT),
    ("glVertexAttribI2uiEXT", &retrace_glVertexAttribI2uiEXT),
    ("glVertexAttribI3uiEXT", &retrace_glVertexAttribI3uiEXT),
    ("glVertexAttribI4uiEXT", &retrace_glVertexAttribI4uiEXT),
    ("glVertexAttribI1ivEXT", &retrace_glVertexAttribI1ivEXT),
    ("glVertexAttribI2ivEXT", &retrace_glVertexAttribI2ivEXT),
    ("glVertexAttribI3ivEXT", &retrace_glVertexAttribI3ivEXT),
    ("glVertexAttribI4ivEXT", &retrace_glVertexAttribI4ivEXT),
    ("glVertexAttribI1uivEXT", &retrace_glVertexAttribI1uivEXT),
    ("glVertexAttribI2uivEXT", &retrace_glVertexAttribI2uivEXT),
    ("glVertexAttribI3uivEXT", &retrace_glVertexAttribI3uivEXT),
    ("glVertexAttribI4uivEXT", &retrace_glVertexAttribI4uivEXT),
    ("glVertexAttribI4bvEXT", &retrace_glVertexAttribI4bvEXT),
    ("glVertexAttribI4svEXT", &retrace_glVertexAttribI4svEXT),
    ("glVertexAttribI4ubvEXT", &retrace_glVertexAttribI4ubvEXT),
    ("glVertexAttribI4usvEXT", &retrace_glVertexAttribI4usvEXT),
    ("glVertexAttribIPointerEXT", &retrace_glVertexAttribIPointerEXT),
    ("glGetVertexAttribIivEXT", &retrace::ignore),
    ("glGetVertexAttribIuivEXT", &retrace::ignore),
    ("glBeginVideoCaptureNV", &retrace_glBeginVideoCaptureNV),
    ("glBindVideoCaptureStreamBufferNV", &retrace_glBindVideoCaptureStreamBufferNV),
    ("glBindVideoCaptureStreamTextureNV", &retrace_glBindVideoCaptureStreamTextureNV),
    ("glEndVideoCaptureNV", &retrace_glEndVideoCaptureNV),
    ("glGetVideoCaptureivNV", &retrace::ignore),
    ("glGetVideoCaptureStreamivNV", &retrace::ignore),
    ("glGetVideoCaptureStreamfvNV", &retrace::ignore),
    ("glGetVideoCaptureStreamdvNV", &retrace::ignore),
    ("glVideoCaptureNV", &retrace_glVideoCaptureNV),
    ("glVideoCaptureStreamParameterivNV", &retrace_glVideoCaptureStreamParameterivNV),
    ("glVideoCaptureStreamParameterfvNV", &retrace_glVideoCaptureStreamParameterfvNV),
    ("glVideoCaptureStreamParameterdvNV", &retrace_glVideoCaptureStreamParameterdvNV),
    ("glBlendEquationSeparateOES", &retrace_glBlendEquationSeparateOES),
    ("glBlendFuncSeparateOES", &retrace_glBlendFuncSeparateOES),
    ("glBlendEquationOES", &retrace_glBlendEquationOES),
    ("glDrawTexfOES", &retrace_glDrawTexfOES),
    ("glDrawTexfvOES", &retrace_glDrawTexfvOES),
    ("glDrawTexiOES", &retrace_glDrawTexiOES),
    ("glDrawTexivOES", &retrace_glDrawTexivOES),
    ("glDrawTexsOES", &retrace_glDrawTexsOES),
    ("glDrawTexsvOES", &retrace_glDrawTexsvOES),
    ("glIsRenderbufferOES", &retrace::ignore),
    ("glBindRenderbufferOES", &retrace_glBindRenderbufferOES),
    ("glDeleteRenderbuffersOES", &retrace_glDeleteRenderbuffersOES),
    ("glGenRenderbuffersOES", &retrace_glGenRenderbuffersOES),
    ("glRenderbufferStorageOES", &retrace_glRenderbufferStorageOES),
    ("glGetRenderbufferParameterivOES", &retrace::ignore),
    ("glIsFramebufferOES", &retrace::ignore),
    ("glBindFramebufferOES", &retrace_glBindFramebufferOES),
    ("glDeleteFramebuffersOES", &retrace_glDeleteFramebuffersOES),
    ("glGenFramebuffersOES", &retrace_glGenFramebuffersOES),
    ("glCheckFramebufferStatusOES", &retrace_glCheckFramebufferStatusOES),
    ("glFramebufferTexture2DOES", &retrace_glFramebufferTexture2DOES),
    ("glFramebufferRenderbufferOES", &retrace_glFramebufferRenderbufferOES),
    ("glGetFramebufferAttachmentParameterivOES", &retrace::ignore),
    ("glGenerateMipmapOES", &retrace_glGenerateMipmapOES),
    ("glGetProgramBinaryOES", &retrace::ignore),
    ("glProgramBinaryOES", &retrace_glProgramBinaryOES),
    ("glGetBufferPointervOES", &retrace::ignore),
    ("glMapBufferOES", &retrace_glMapBufferOES),
    ("glUnmapBufferOES", &retrace_glUnmapBufferOES),
    ("glCurrentPaletteMatrixOES", &retrace_glCurrentPaletteMatrixOES),
    ("glLoadPaletteFromModelViewMatrixOES", &retrace_glLoadPaletteFromModelViewMatrixOES),
    ("glMatrixIndexPointerOES", &retrace_glMatrixIndexPointerOES),
    ("glWeightPointerOES", &retrace_glWeightPointerOES),
    ("glPointSizePointerOES", &retrace_glPointSizePointerOES),
    ("glQueryMatrixxOES", &retrace_glQueryMatrixxOES),
    ("glClearDepthfOES", &retrace_glClearDepthfOES),
    ("glClipPlanefOES", &retrace_glClipPlanefOES),
    ("glDepthRangefOES", &retrace_glDepthRangefOES),
    ("glFrustumfOES", &retrace_glFrustumfOES),
    ("glGetClipPlanefOES", &retrace::ignore),
    ("glOrthofOES", &retrace_glOrthofOES),
    ("glTexImage3DOES", &retrace_glTexImage3DOES),
    ("glTexSubImage3DOES", &retrace_glTexSubImage3DOES),
    ("glCopyTexSubImage3DOES", &retrace_glCopyTexSubImage3DOES),
    ("glCompressedTexImage3DOES", &retrace_glCompressedTexImage3DOES),
    ("glCompressedTexSubImage3DOES", &retrace_glCompressedTexSubImage3DOES),
    ("glFramebufferTexture3DOES", &retrace_glFramebufferTexture3DOES),
    ("glTexGenfOES", &retrace_glTexGenfOES),
    ("glTexGenfvOES", &retrace_glTexGenfvOES),
    ("glTexGeniOES", &retrace_glTexGeniOES),
    ("glTexGenivOES", &retrace_glTexGenivOES),
    ("glTexGenxOES", &retrace_glTexGenxOES),
    ("glTexGenxvOES", &retrace_glTexGenxvOES),
    ("glGetTexGenfvOES", &retrace::ignore),
    ("glGetTexGenivOES", &retrace::ignore),
    ("glGetTexGenxvOES", &retrace::ignore),
    ("glBindVertexArrayOES", &retrace_glBindVertexArrayOES),
    ("glDeleteVertexArraysOES", &retrace_glDeleteVertexArraysOES),
    ("glGenVertexArraysOES", &retrace_glGenVertexArraysOES),
    ("glIsVertexArrayOES", &retrace::ignore),
    ("glViewportArrayvOES", &retrace_glViewportArrayvOES),
    ("glViewportIndexedfOES", &retrace_glViewportIndexedfOES),
    ("glViewportIndexedfvOES", &retrace_glViewportIndexedfvOES),
    ("glScissorArrayvOES", &retrace_glScissorArrayvOES),
    ("glScissorIndexedOES", &retrace_glScissorIndexedOES),
    ("glScissorIndexedvOES", &retrace_glScissorIndexedvOES),
    ("glDepthRangeArrayfvOES", &retrace_glDepthRangeArrayfvOES),
    ("glDepthRangeIndexedfOES", &retrace_glDepthRangeIndexedfOES),
    ("glGetFloati_vOES", &retrace::ignore),
    ("glFramebufferTextureMultiviewOVR", &retrace_glFramebufferTextureMultiviewOVR),
    ("glNamedFramebufferTextureMultiviewOVR", &retrace_glNamedFramebufferTextureMultiviewOVR),
    ("glHintPGI", &retrace_glHintPGI),
    ("glDetailTexFuncSGIS", &retrace_glDetailTexFuncSGIS),
    ("glGetDetailTexFuncSGIS", &retrace::ignore),
    ("glFogFuncSGIS", &retrace_glFogFuncSGIS),
    ("glGetFogFuncSGIS", &retrace::ignore),
    ("glSampleMaskSGIS", &retrace_glSampleMaskSGIS),
    ("glSamplePatternSGIS", &retrace_glSamplePatternSGIS),
    ("glPixelTexGenParameteriSGIS", &retrace_glPixelTexGenParameteriSGIS),
    ("glPixelTexGenParameterivSGIS", &retrace_glPixelTexGenParameterivSGIS),
    ("glPixelTexGenParameterfSGIS", &retrace_glPixelTexGenParameterfSGIS),
    ("glPixelTexGenParameterfvSGIS", &retrace_glPixelTexGenParameterfvSGIS),
    ("glGetPixelTexGenParameterivSGIS", &retrace::ignore),
    ("glGetPixelTexGenParameterfvSGIS", &retrace::ignore),
    ("glPointParameterfSGIS", &retrace_glPointParameterfSGIS),
    ("glPointParameterfvSGIS", &retrace_glPointParameterfvSGIS),
    ("glSharpenTexFuncSGIS", &retrace_glSharpenTexFuncSGIS),
    ("glGetSharpenTexFuncSGIS", &retrace::ignore),
    ("glTexImage4DSGIS", &retrace_glTexImage4DSGIS),
    ("glTexSubImage4DSGIS", &retrace_glTexSubImage4DSGIS),
    ("glTextureColorMaskSGIS", &retrace_glTextureColorMaskSGIS),
    ("glGetTexFilterFuncSGIS", &retrace::ignore),
    ("glTexFilterFuncSGIS", &retrace_glTexFilterFuncSGIS),
    ("glAsyncMarkerSGIX", &retrace_glAsyncMarkerSGIX),
    ("glFinishAsyncSGIX", &retrace_glFinishAsyncSGIX),
    ("glPollAsyncSGIX", &retrace_glPollAsyncSGIX),
    ("glGenAsyncMarkersSGIX", &retrace_glGenAsyncMarkersSGIX),
    ("glDeleteAsyncMarkersSGIX", &retrace_glDeleteAsyncMarkersSGIX),
    ("glIsAsyncMarkerSGIX", &retrace::ignore),
    ("glFlushRasterSGIX", &retrace_glFlushRasterSGIX),
    ("glFragmentColorMaterialSGIX", &retrace_glFragmentColorMaterialSGIX),
    ("glFragmentLightfSGIX", &retrace_glFragmentLightfSGIX),
    ("glFragmentLightfvSGIX", &retrace_glFragmentLightfvSGIX),
    ("glFragmentLightiSGIX", &retrace_glFragmentLightiSGIX),
    ("glFragmentLightivSGIX", &retrace_glFragmentLightivSGIX),
    ("glFragmentLightModelfSGIX", &retrace_glFragmentLightModelfSGIX),
    ("glFragmentLightModelfvSGIX", &retrace_glFragmentLightModelfvSGIX),
    ("glFragmentLightModeliSGIX", &retrace_glFragmentLightModeliSGIX),
    ("glFragmentLightModelivSGIX", &retrace_glFragmentLightModelivSGIX),
    ("glFragmentMaterialfSGIX", &retrace_glFragmentMaterialfSGIX),
    ("glFragmentMaterialfvSGIX", &retrace_glFragmentMaterialfvSGIX),
    ("glFragmentMaterialiSGIX", &retrace_glFragmentMaterialiSGIX),
    ("glFragmentMaterialivSGIX", &retrace_glFragmentMaterialivSGIX),
    ("glGetFragmentLightfvSGIX", &retrace::ignore),
    ("glGetFragmentLightivSGIX", &retrace::ignore),
    ("glGetFragmentMaterialfvSGIX", &retrace::ignore),
    ("glGetFragmentMaterialivSGIX", &retrace::ignore),
    ("glLightEnviSGIX", &retrace_glLightEnviSGIX),
    ("glFrameZoomSGIX", &retrace_glFrameZoomSGIX),
    ("glIglooInterfaceSGIX", &retrace_glIglooInterfaceSGIX),
    ("glGetInstrumentsSGIX", &retrace::ignore),
    ("glInstrumentsBufferSGIX", &retrace_glInstrumentsBufferSGIX),
    ("glPollInstrumentsSGIX", &retrace_glPollInstrumentsSGIX),
    ("glReadInstrumentsSGIX", &retrace_glReadInstrumentsSGIX),
    ("glStartInstrumentsSGIX", &retrace_glStartInstrumentsSGIX),
    ("glStopInstrumentsSGIX", &retrace_glStopInstrumentsSGIX),
    ("glGetListParameterfvSGIX", &retrace::ignore),
    ("glGetListParameterivSGIX", &retrace::ignore),
    ("glListParameterfSGIX", &retrace_glListParameterfSGIX),
    ("glListParameterfvSGIX", &retrace_glListParameterfvSGIX),
    ("glListParameteriSGIX", &retrace_glListParameteriSGIX),
    ("glListParameterivSGIX", &retrace_glListParameterivSGIX),
    ("glPixelTexGenSGIX", &retrace_glPixelTexGenSGIX),
    ("glDeformationMap3dSGIX", &retrace_glDeformationMap3dSGIX),
    ("glDeformationMap3fSGIX", &retrace_glDeformationMap3fSGIX),
    ("glDeformSGIX", &retrace_glDeformSGIX),
    ("glLoadIdentityDeformationMapSGIX", &retrace_glLoadIdentityDeformationMapSGIX),
    ("glReferencePlaneSGIX", &retrace_glReferencePlaneSGIX),
    ("glSpriteParameterfSGIX", &retrace_glSpriteParameterfSGIX),
    ("glSpriteParameterfvSGIX", &retrace_glSpriteParameterfvSGIX),
    ("glSpriteParameteriSGIX", &retrace_glSpriteParameteriSGIX),
    ("glSpriteParameterivSGIX", &retrace_glSpriteParameterivSGIX),
    ("glTagSampleBufferSGIX", &retrace_glTagSampleBufferSGIX),
    ("glColorTableSGI", &retrace_glColorTableSGI),
    ("glColorTableParameterfvSGI", &retrace_glColorTableParameterfvSGI),
    ("glColorTableParameterivSGI", &retrace_glColorTableParameterivSGI),
    ("glCopyColorTableSGI", &retrace_glCopyColorTableSGI),
    ("glGetColorTableSGI", &retrace::ignore),
    ("glGetColorTableParameterfvSGI", &retrace::ignore),
    ("glGetColorTableParameterivSGI", &retrace::ignore),
    ("glFinishTextureSUNX", &retrace_glFinishTextureSUNX),
    ("glGlobalAlphaFactorbSUN", &retrace_glGlobalAlphaFactorbSUN),
    ("glGlobalAlphaFactorsSUN", &retrace_glGlobalAlphaFactorsSUN),
    ("glGlobalAlphaFactoriSUN", &retrace_glGlobalAlphaFactoriSUN),
    ("glGlobalAlphaFactorfSUN", &retrace_glGlobalAlphaFactorfSUN),
    ("glGlobalAlphaFactordSUN", &retrace_glGlobalAlphaFactordSUN),
    ("glGlobalAlphaFactorubSUN", &retrace_glGlobalAlphaFactorubSUN),
    ("glGlobalAlphaFactorusSUN", &retrace_glGlobalAlphaFactorusSUN),
    ("glGlobalAlphaFactoruiSUN", &retrace_glGlobalAlphaFactoruiSUN),
    ("glDrawMeshArraysSUN", &retrace_glDrawMeshArraysSUN),
    ("glReplacementCodeuiSUN", &retrace_glReplacementCodeuiSUN),
    ("glReplacementCodeusSUN", &retrace_glReplacementCodeusSUN),
    ("glReplacementCodeubSUN", &retrace_glReplacementCodeubSUN),
    ("glReplacementCodeuivSUN", &retrace_glReplacementCodeuivSUN),
    ("glReplacementCodeusvSUN", &retrace_glReplacementCodeusvSUN),
    ("glReplacementCodeubvSUN", &retrace_glReplacementCodeubvSUN),
    ("glReplacementCodePointerSUN", &retrace_glReplacementCodePointerSUN),
    ("glColor4ubVertex2fSUN", &retrace_glColor4ubVertex2fSUN),
    ("glColor4ubVertex2fvSUN", &retrace_glColor4ubVertex2fvSUN),
    ("glColor4ubVertex3fSUN", &retrace_glColor4ubVertex3fSUN),
    ("glColor4ubVertex3fvSUN", &retrace_glColor4ubVertex3fvSUN),
    ("glColor3fVertex3fSUN", &retrace_glColor3fVertex3fSUN),
    ("glColor3fVertex3fvSUN", &retrace_glColor3fVertex3fvSUN),
    ("glNormal3fVertex3fSUN", &retrace_glNormal3fVertex3fSUN),
    ("glNormal3fVertex3fvSUN", &retrace_glNormal3fVertex3fvSUN),
    ("glColor4fNormal3fVertex3fSUN", &retrace_glColor4fNormal3fVertex3fSUN),
    ("glColor4fNormal3fVertex3fvSUN", &retrace_glColor4fNormal3fVertex3fvSUN),
    ("glTexCoord2fVertex3fSUN", &retrace_glTexCoord2fVertex3fSUN),
    ("glTexCoord2fVertex3fvSUN", &retrace_glTexCoord2fVertex3fvSUN),
    ("glTexCoord4fVertex4fSUN", &retrace_glTexCoord4fVertex4fSUN),
    ("glTexCoord4fVertex4fvSUN", &retrace_glTexCoord4fVertex4fvSUN),
    ("glTexCoord2fColor4ubVertex3fSUN", &retrace_glTexCoord2fColor4ubVertex3fSUN),
    ("glTexCoord2fColor4ubVertex3fvSUN", &retrace_glTexCoord2fColor4ubVertex3fvSUN),
    ("glTexCoord2fColor3fVertex3fSUN", &retrace_glTexCoord2fColor3fVertex3fSUN),
    ("glTexCoord2fColor3fVertex3fvSUN", &retrace_glTexCoord2fColor3fVertex3fvSUN),
    ("glTexCoord2fNormal3fVertex3fSUN", &retrace_glTexCoord2fNormal3fVertex3fSUN),
    ("glTexCoord2fNormal3fVertex3fvSUN", &retrace_glTexCoord2fNormal3fVertex3fvSUN),
    ("glTexCoord2fColor4fNormal3fVertex3fSUN", &retrace_glTexCoord2fColor4fNormal3fVertex3fSUN),
    ("glTexCoord2fColor4fNormal3fVertex3fvSUN", &retrace_glTexCoord2fColor4fNormal3fVertex3fvSUN),
    ("glTexCoord4fColor4fNormal3fVertex4fSUN", &retrace_glTexCoord4fColor4fNormal3fVertex4fSUN),
    ("glTexCoord4fColor4fNormal3fVertex4fvSUN", &retrace_glTexCoord4fColor4fNormal3fVertex4fvSUN),
    ("glReplacementCodeuiVertex3fSUN", &retrace_glReplacementCodeuiVertex3fSUN),
    ("glReplacementCodeuiVertex3fvSUN", &retrace_glReplacementCodeuiVertex3fvSUN),
    ("glReplacementCodeuiColor4ubVertex3fSUN", &retrace_glReplacementCodeuiColor4ubVertex3fSUN),
    ("glReplacementCodeuiColor4ubVertex3fvSUN", &retrace_glReplacementCodeuiColor4ubVertex3fvSUN),
    ("glReplacementCodeuiColor3fVertex3fSUN", &retrace_glReplacementCodeuiColor3fVertex3fSUN),
    ("glReplacementCodeuiColor3fVertex3fvSUN", &retrace_glReplacementCodeuiColor3fVertex3fvSUN),
    ("glReplacementCodeuiNormal3fVertex3fSUN", &retrace_glReplacementCodeuiNormal3fVertex3fSUN),
    ("glReplacementCodeuiNormal3fVertex3fvSUN", &retrace_glReplacementCodeuiNormal3fVertex3fvSUN),
    ("glReplacementCodeuiColor4fNormal3fVertex3fSUN", &retrace_glReplacementCodeuiColor4fNormal3fVertex3fSUN),
    ("glReplacementCodeuiColor4fNormal3fVertex3fvSUN", &retrace_glReplacementCodeuiColor4fNormal3fVertex3fvSUN),
    ("glReplacementCodeuiTexCoord2fVertex3fSUN", &retrace_glReplacementCodeuiTexCoord2fVertex3fSUN),
    ("glReplacementCodeuiTexCoord2fVertex3fvSUN", &retrace_glReplacementCodeuiTexCoord2fVertex3fvSUN),
    ("glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN", &retrace_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN),
    ("glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN", &retrace_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN),
    ("glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN", &retrace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN),
    ("glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN", &retrace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN),
    ("glAddSwapHintRectWIN", &retrace_glAddSwapHintRectWIN),
];


static GLint
_getActiveProgram(void)
{
    GLint program = -1;
    glretrace::Context *currentContext = glretrace::getCurrentContext();
    if (currentContext) {
        GLint pipeline = currentContext->currentPipeline;
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            program = currentContext->currentProgram;
            assert(program == _glGetInteger(GL_CURRENT_PROGRAM));
        }
    }
    return program;
}

static void
_validateActiveProgram(trace::Call &call)
{
    assert(retrace::debug > 0);

    glretrace::Context *currentContext = glretrace::getCurrentContext();
    if (!currentContext ||
        currentContext->insideList ||
        currentContext->insideBeginEnd ||
        currentContext->wsContext->profile.major < 2) {
        return;
    }

    GLint pipeline = currentContext->currentPipeline;
    if (pipeline) {
        // TODO
    } else {
        GLint program = currentContext->currentProgram;
        assert(program == _glGetInteger(GL_CURRENT_PROGRAM));
        if (!program) {
            return;
        }

        GLint validate_status = GL_FALSE;
        glGetProgramiv(program, GL_VALIDATE_STATUS, &validate_status);
        if (validate_status) {
            // Validate only once
            return;
        }

        glValidateProgram(program);
        glGetProgramiv(program, GL_VALIDATE_STATUS, &validate_status);
        if (!validate_status) {
            retrace::warning(call) << "program validation failed\n";
        }

        GLint info_log_length = 0;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
        if (info_log_length > 1) {
             GLchar *infoLog = new GLchar[info_log_length];
             glGetProgramInfoLog(program, info_log_length, NULL, infoLog);
             retrace::warning(call) << infoLog << "\n";
             delete [] infoLog;
        }
    }
}


